<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","media","hdd","home","projects","hls_m3u8","src","attribute.rs"],"content":"use std::collections::HashMap;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::Error;\n\n#[derive(Clone, Debug, Default, Eq, PartialEq)]\npub struct AttributePairs(HashMap\u003cString, String\u003e);\n\nimpl AttributePairs {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n}\n\nimpl Deref for AttributePairs {\n    type Target = HashMap\u003cString, String\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for AttributePairs {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\nimpl IntoIterator for AttributePairs {\n    type Item = (String, String);\n    type IntoIter = ::std::collections::hash_map::IntoIter\u003cString, String\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\nimpl\u003c'a\u003e IntoIterator for \u0026'a AttributePairs {\n    type Item = (\u0026'a String, \u0026'a String);\n    type IntoIter = ::std::collections::hash_map::Iter\u003c'a, String, String\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.0.iter()\n    }\n}\n\nimpl FromStr for AttributePairs {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut result = AttributePairs::new();\n\n        for line in split(input, ',') {\n            let pair = split(line.trim(), '=');\n\n            if pair.len() \u003c 2 {\n                continue;\n            }\n\n            let key = pair[0].trim().to_uppercase();\n            let value = pair[1].trim().to_string();\n            if value.is_empty() {\n                continue;\n            }\n\n            result.insert(key.trim().to_string(), value.trim().to_string());\n        }\n\n        #[cfg(test)] // this is very useful, when a test fails!\n        dbg!(\u0026result);\n        Ok(result)\n    }\n}\n\nfn split(value: \u0026str, terminator: char) -\u003e Vec\u003cString\u003e {\n    let mut result = vec![];\n\n    let mut inside_quotes = false;\n    let mut temp_string = String::new();\n\n    for c in value.chars() {\n        match c {\n            '\"' =\u003e {\n                if inside_quotes {\n                    inside_quotes = false;\n                } else {\n                    inside_quotes = true;\n                }\n                temp_string.push(c);\n            }\n            k if (k == terminator) =\u003e {\n                if !inside_quotes {\n                    result.push(temp_string);\n                    temp_string = String::new();\n                } else {\n                    temp_string.push(c);\n                }\n            }\n            _ =\u003e {\n                temp_string.push(c);\n            }\n        }\n    }\n    result.push(temp_string);\n\n    result\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parser() {\n        let pairs = \"FOO=BAR,BAR=\\\"baz,qux\\\",ABC=12.3\"\n            .parse::\u003cAttributePairs\u003e()\n            .unwrap();\n\n        let mut iterator = pairs.iter();\n        assert!(iterator.any(|(k, v)| k == \"FOO\" \u0026\u0026 \"BAR\" == v));\n\n        let mut iterator = pairs.iter();\n        assert!(iterator.any(|(k, v)| k == \"BAR\" \u0026\u0026 v == \"\\\"baz,qux\\\"\"));\n\n        let mut iterator = pairs.iter();\n        assert!(iterator.any(|(k, v)| k == \"ABC\" \u0026\u0026 v == \"12.3\"));\n\n        let mut pairs = AttributePairs::new();\n        pairs.insert(\"FOO\".to_string(), \"BAR\".to_string());\n\n        assert_eq!(\"FOO=BAR,VAL\".parse::\u003cAttributePairs\u003e().unwrap(), pairs);\n    }\n\n    #[test]\n    fn test_iterator() {\n        let mut attrs = AttributePairs::new();\n        attrs.insert(\"key_01\".to_string(), \"value_01\".to_string());\n        attrs.insert(\"key_02\".to_string(), \"value_02\".to_string());\n\n        let mut iterator = attrs.iter();\n        assert!(iterator.any(|(k, v)| k == \"key_01\" \u0026\u0026 v == \"value_01\"));\n\n        let mut iterator = attrs.iter();\n        assert!(iterator.any(|(k, v)| k == \"key_02\" \u0026\u0026 v == \"value_02\"));\n    }\n\n    #[test]\n    fn test_into_iter() {\n        let mut map = HashMap::new();\n        map.insert(\"k\".to_string(), \"v\".to_string());\n\n        let mut attrs = AttributePairs::new();\n        attrs.insert(\"k\".to_string(), \"v\".to_string());\n\n        assert_eq!(\n            attrs.into_iter().collect::\u003cVec\u003c_\u003e\u003e(),\n            map.into_iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n    }\n}\n","traces":[{"line":11,"address":4264224,"length":1,"stats":{"Line":1}},{"line":19,"address":4264256,"length":1,"stats":{"Line":1}},{"line":20,"address":4264261,"length":1,"stats":{"Line":1}},{"line":25,"address":4264272,"length":1,"stats":{"Line":1}},{"line":26,"address":4264277,"length":1,"stats":{"Line":1}},{"line":34,"address":4264288,"length":1,"stats":{"Line":1}},{"line":35,"address":4264295,"length":1,"stats":{"Line":1}},{"line":43,"address":4264368,"length":1,"stats":{"Line":0}},{"line":44,"address":4264380,"length":1,"stats":{"Line":0}},{"line":51,"address":4264416,"length":1,"stats":{"Line":1}},{"line":52,"address":4264442,"length":1,"stats":{"Line":1}},{"line":54,"address":4264508,"length":1,"stats":{"Line":1}},{"line":55,"address":4264970,"length":1,"stats":{"Line":1}},{"line":57,"address":4265092,"length":1,"stats":{"Line":1}},{"line":58,"address":4265184,"length":1,"stats":{"Line":1}},{"line":61,"address":4265145,"length":1,"stats":{"Line":1}},{"line":62,"address":4265441,"length":1,"stats":{"Line":1}},{"line":63,"address":null,"length":0,"stats":{"Line":1}},{"line":64,"address":4265509,"length":1,"stats":{"Line":1}},{"line":67,"address":null,"length":0,"stats":{"Line":1}},{"line":70,"address":4264571,"length":1,"stats":{"Line":0}},{"line":71,"address":null,"length":0,"stats":{"Line":1}},{"line":72,"address":null,"length":0,"stats":{"Line":1}},{"line":76,"address":4266400,"length":1,"stats":{"Line":1}},{"line":77,"address":4266410,"length":1,"stats":{"Line":1}},{"line":79,"address":4266417,"length":1,"stats":{"Line":1}},{"line":80,"address":4266735,"length":1,"stats":{"Line":1}},{"line":82,"address":4266697,"length":1,"stats":{"Line":1}},{"line":83,"address":4266711,"length":1,"stats":{"Line":1}},{"line":84,"address":4267183,"length":1,"stats":{"Line":1}},{"line":85,"address":4266704,"length":1,"stats":{"Line":1}},{"line":86,"address":4267207,"length":1,"stats":{"Line":1}},{"line":88,"address":4267200,"length":1,"stats":{"Line":1}},{"line":90,"address":4266786,"length":1,"stats":{"Line":1}},{"line":92,"address":4266907,"length":1,"stats":{"Line":1}},{"line":93,"address":4267282,"length":1,"stats":{"Line":1}},{"line":94,"address":4266819,"length":1,"stats":{"Line":1}},{"line":95,"address":4267403,"length":1,"stats":{"Line":1}},{"line":97,"address":4267315,"length":1,"stats":{"Line":1}},{"line":101,"address":4267296,"length":1,"stats":{"Line":1}},{"line":105,"address":4266452,"length":1,"stats":{"Line":1}},{"line":107,"address":4267421,"length":1,"stats":{"Line":1}},{"line":115,"address":4245584,"length":1,"stats":{"Line":2}},{"line":116,"address":4245598,"length":1,"stats":{"Line":1}},{"line":120,"address":4245667,"length":1,"stats":{"Line":1}},{"line":121,"address":4245719,"length":1,"stats":{"Line":2}},{"line":123,"address":4245745,"length":1,"stats":{"Line":1}},{"line":124,"address":4245818,"length":1,"stats":{"Line":2}},{"line":126,"address":4245844,"length":1,"stats":{"Line":1}},{"line":127,"address":4245917,"length":1,"stats":{"Line":2}},{"line":129,"address":4245946,"length":1,"stats":{"Line":1}},{"line":130,"address":4245994,"length":1,"stats":{"Line":1}},{"line":132,"address":4246153,"length":1,"stats":{"Line":1}},{"line":136,"address":4246800,"length":1,"stats":{"Line":2}},{"line":137,"address":4246807,"length":1,"stats":{"Line":1}},{"line":138,"address":4246855,"length":1,"stats":{"Line":1}},{"line":139,"address":4247007,"length":1,"stats":{"Line":1}},{"line":141,"address":4247153,"length":1,"stats":{"Line":1}},{"line":142,"address":4247193,"length":1,"stats":{"Line":2}},{"line":144,"address":4247219,"length":1,"stats":{"Line":1}},{"line":145,"address":4247292,"length":1,"stats":{"Line":2}},{"line":149,"address":4247504,"length":1,"stats":{"Line":2}},{"line":150,"address":4247511,"length":1,"stats":{"Line":1}},{"line":151,"address":4247578,"length":1,"stats":{"Line":1}},{"line":153,"address":4247715,"length":1,"stats":{"Line":1}},{"line":154,"address":4247722,"length":1,"stats":{"Line":1}},{"line":156,"address":4248080,"length":1,"stats":{"Line":0}},{"line":157,"address":4247879,"length":1,"stats":{"Line":1}},{"line":158,"address":4247997,"length":1,"stats":{"Line":1}}],"covered":65,"coverable":69},{"path":["/","media","hdd","home","projects","hls_m3u8","src","error.rs"],"content":"use std::fmt;\n\nuse failure::{Backtrace, Context, Fail};\n\n/// This crate specific `Result` type.\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n/// The ErrorKind.\n#[derive(Debug, Fail, Clone, PartialEq, Eq)]\npub enum ErrorKind {\n    #[fail(display = \"ChronoParseError: {}\", _0)]\n    /// An error from the [Chrono](chrono) crate.\n    ChronoParseError(String),\n\n    #[fail(display = \"UnknownError: {}\", _0)]\n    /// An unknown error occured.\n    UnknownError(String),\n\n    #[fail(display = \"A value is missing for the attribute {}\", _0)]\n    /// A required value is missing.\n    MissingValue(String),\n\n    #[fail(display = \"Invalid Input\")]\n    /// Error for anything.\n    InvalidInput,\n\n    #[fail(display = \"ParseIntError: {}\", _0)]\n    /// Failed to parse a String to int.\n    ParseIntError(String),\n\n    #[fail(display = \"ParseFloatError: {}\", _0)]\n    /// Failed to parse a String to float.\n    ParseFloatError(String),\n\n    #[fail(display = \"MissingTag: Expected {} at the start of {:?}\", tag, input)]\n    /// A tag is missing, that is required at the start of the input.\n    MissingTag {\n        /// The required tag.\n        tag: String,\n        /// The unparsed input data.\n        input: String,\n    },\n\n    #[fail(display = \"CustomError: {}\", _0)]\n    /// A custom error.\n    Custom(String),\n\n    #[fail(display = \"Unmatched Group: {:?}\", _0)]\n    /// Unmatched Group\n    UnmatchedGroup(String),\n\n    #[fail(display = \"Unknown Protocol version: {:?}\", _0)]\n    /// Unknown m3u8 version. This library supports up to ProtocolVersion 7.\n    UnknownProtocolVersion(String),\n\n    #[fail(display = \"IoError: {}\", _0)]\n    /// Some io error\n    Io(String),\n\n    #[fail(\n        display = \"VersionError: required_version: {:?}, specified_version: {:?}\",\n        _0, _1\n    )]\n    /// This error occurs, if there is a ProtocolVersion mismatch.\n    VersionError(String, String),\n\n    #[fail(display = \"BuilderError: {}\", _0)]\n    /// An Error from a Builder.\n    BuilderError(String),\n\n    #[fail(display = \"Missing Attribute: {}\", _0)]\n    /// An attribute is missing.\n    MissingAttribute(String),\n\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    #[fail(display = \"Invalid error\")]\n    __Nonexhaustive,\n}\n\n#[derive(Debug)]\n/// The Error type of this library.\npub struct Error {\n    inner: Context\u003cErrorKind\u003e,\n}\n\nimpl Fail for Error {\n    fn cause(\u0026self) -\u003e Option\u003c\u0026dyn Fail\u003e {\n        self.inner.cause()\n    }\n\n    fn backtrace(\u0026self) -\u003e Option\u003c\u0026Backtrace\u003e {\n        self.inner.backtrace()\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        self.inner.fmt(f)\n    }\n}\n\nimpl From\u003cErrorKind\u003e for Error {\n    fn from(kind: ErrorKind) -\u003e Error {\n        Error::from(Context::new(kind))\n    }\n}\n\nimpl From\u003cContext\u003cErrorKind\u003e\u003e for Error {\n    fn from(inner: Context\u003cErrorKind\u003e) -\u003e Error {\n        Error { inner }\n    }\n}\n\nimpl Error {\n    pub(crate) fn missing_value\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::MissingValue(value.to_string()))\n    }\n\n    pub(crate) fn invalid_input() -\u003e Self {\n        Self::from(ErrorKind::InvalidInput)\n    }\n\n    pub(crate) fn parse_int_error\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::ParseIntError(value.to_string()))\n    }\n\n    pub(crate) fn parse_float_error\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::ParseFloatError(value.to_string()))\n    }\n\n    pub(crate) fn missing_tag\u003cT, U\u003e(tag: T, input: U) -\u003e Self\n    where\n        T: ToString,\n        U: ToString,\n    {\n        Self::from(ErrorKind::MissingTag {\n            tag: tag.to_string(),\n            input: input.to_string(),\n        })\n    }\n\n    pub(crate) fn unmatched_group\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::UnmatchedGroup(value.to_string()))\n    }\n\n    pub(crate) fn custom\u003cT\u003e(value: T) -\u003e Self\n    where\n        T: fmt::Display,\n    {\n        Self::from(ErrorKind::Custom(value.to_string()))\n    }\n\n    pub(crate) fn unknown_protocol_version\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::UnknownProtocolVersion(value.to_string()))\n    }\n\n    pub(crate) fn io\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::Io(value.to_string()))\n    }\n\n    pub(crate) fn required_version\u003cT, U\u003e(required_version: T, specified_version: U) -\u003e Self\n    where\n        T: ToString,\n        U: ToString,\n    {\n        Self::from(ErrorKind::VersionError(\n            required_version.to_string(),\n            specified_version.to_string(),\n        ))\n    }\n\n    pub(crate) fn builder_error\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::BuilderError(value.to_string()))\n    }\n\n    pub(crate) fn chrono\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::ChronoParseError(value.to_string()))\n    }\n\n    pub(crate) fn missing_attribute\u003cT: ToString\u003e(value: T) -\u003e Self {\n        Self::from(ErrorKind::MissingAttribute(value.to_string()))\n    }\n}\n\nimpl From\u003c::std::num::ParseIntError\u003e for Error {\n    fn from(value: ::std::num::ParseIntError) -\u003e Self {\n        Error::parse_int_error(value)\n    }\n}\n\nimpl From\u003c::std::num::ParseFloatError\u003e for Error {\n    fn from(value: ::std::num::ParseFloatError) -\u003e Self {\n        Error::parse_float_error(value)\n    }\n}\n\nimpl From\u003c::std::io::Error\u003e for Error {\n    fn from(value: ::std::io::Error) -\u003e Self {\n        Error::io(value)\n    }\n}\n\nimpl From\u003c::chrono::ParseError\u003e for Error {\n    fn from(value: ::chrono::ParseError) -\u003e Self {\n        Error::chrono(value)\n    }\n}\n\nimpl From\u003c::strum::ParseError\u003e for Error {\n    fn from(value: ::strum::ParseError) -\u003e Self {\n        Error::custom(value) // TODO!\n    }\n}\n","traces":[{"line":92,"address":4214496,"length":1,"stats":{"Line":0}},{"line":93,"address":4214505,"length":1,"stats":{"Line":0}},{"line":96,"address":4214544,"length":1,"stats":{"Line":0}},{"line":97,"address":4214553,"length":1,"stats":{"Line":0}},{"line":102,"address":4214592,"length":1,"stats":{"Line":1}},{"line":103,"address":4214606,"length":1,"stats":{"Line":1}},{"line":108,"address":4214656,"length":1,"stats":{"Line":1}},{"line":109,"address":4214666,"length":1,"stats":{"Line":1}},{"line":114,"address":4214752,"length":1,"stats":{"Line":1}},{"line":120,"address":4215856,"length":1,"stats":{"Line":1}},{"line":121,"address":4215876,"length":1,"stats":{"Line":1}},{"line":124,"address":4214848,"length":1,"stats":{"Line":1}},{"line":125,"address":4214855,"length":1,"stats":{"Line":1}},{"line":128,"address":4216016,"length":1,"stats":{"Line":1}},{"line":129,"address":4216028,"length":1,"stats":{"Line":1}},{"line":132,"address":4216160,"length":1,"stats":{"Line":1}},{"line":133,"address":4216176,"length":1,"stats":{"Line":1}},{"line":136,"address":4216304,"length":1,"stats":{"Line":1}},{"line":141,"address":4216410,"length":1,"stats":{"Line":1}},{"line":142,"address":4216334,"length":1,"stats":{"Line":1}},{"line":143,"address":4216382,"length":1,"stats":{"Line":1}},{"line":147,"address":4216560,"length":1,"stats":{"Line":0}},{"line":148,"address":4216572,"length":1,"stats":{"Line":0}},{"line":151,"address":4216704,"length":1,"stats":{"Line":3}},{"line":155,"address":4216711,"length":1,"stats":{"Line":3}},{"line":158,"address":4217568,"length":1,"stats":{"Line":1}},{"line":159,"address":4217588,"length":1,"stats":{"Line":1}},{"line":162,"address":4217728,"length":1,"stats":{"Line":0}},{"line":163,"address":4217735,"length":1,"stats":{"Line":0}},{"line":166,"address":4217888,"length":1,"stats":{"Line":0}},{"line":171,"address":4217981,"length":1,"stats":{"Line":0}},{"line":172,"address":4217907,"length":1,"stats":{"Line":0}},{"line":173,"address":4217956,"length":1,"stats":{"Line":0}},{"line":177,"address":4218128,"length":1,"stats":{"Line":1}},{"line":178,"address":4218145,"length":1,"stats":{"Line":1}},{"line":181,"address":4218272,"length":1,"stats":{"Line":0}},{"line":182,"address":4218284,"length":1,"stats":{"Line":0}},{"line":185,"address":4218416,"length":1,"stats":{"Line":0}},{"line":186,"address":4218436,"length":1,"stats":{"Line":0}},{"line":191,"address":4214896,"length":1,"stats":{"Line":1}},{"line":192,"address":4214908,"length":1,"stats":{"Line":1}},{"line":197,"address":4214944,"length":1,"stats":{"Line":1}},{"line":198,"address":4214960,"length":1,"stats":{"Line":1}},{"line":203,"address":4214992,"length":1,"stats":{"Line":0}},{"line":204,"address":4214999,"length":1,"stats":{"Line":0}},{"line":209,"address":4215040,"length":1,"stats":{"Line":0}},{"line":210,"address":4215052,"length":1,"stats":{"Line":0}},{"line":215,"address":4215088,"length":1,"stats":{"Line":0}},{"line":216,"address":4215100,"length":1,"stats":{"Line":0}}],"covered":27,"coverable":49},{"path":["/","media","hdd","home","projects","hls_m3u8","src","lib.rs"],"content":"#![forbid(unsafe_code)]\n#![warn(\n    //clippy::pedantic,\n    clippy::nursery,\n    clippy::cargo\n)]\n#![allow(clippy::multiple_crate_versions)]\n#![warn(\n    missing_docs,\n    missing_copy_implementations,\n    missing_debug_implementations,\n    trivial_casts, // TODO (needed?)\n    trivial_numeric_casts\n)]\n//! [HLS] m3u8 parser/generator.\n//!\n//! [HLS]: https://tools.ietf.org/html/rfc8216\n//!\n//! # Examples\n//!\n//! ```\n//! use hls_m3u8::MediaPlaylist;\n//!\n//! let m3u8 = \"#EXTM3U\n//! #EXT-X-TARGETDURATION:10\n//! #EXT-X-VERSION:3\n//! #EXTINF:9.009,\n//! http://media.example.com/first.ts\n//! #EXTINF:9.009,\n//! http://media.example.com/second.ts\n//! #EXTINF:3.003,\n//! http://media.example.com/third.ts\n//! #EXT-X-ENDLIST\";\n//!\n//! assert!(m3u8.parse::\u003cMediaPlaylist\u003e().is_ok());\n//! ```\n\npub use error::{Error, ErrorKind};\npub use master_playlist::{MasterPlaylist, MasterPlaylistBuilder};\npub use media_playlist::{MediaPlaylist, MediaPlaylistBuilder};\npub use media_segment::{MediaSegment, MediaSegmentBuilder};\n\npub mod tags;\npub mod types;\n\nmod attribute;\nmod error;\nmod line;\nmod master_playlist;\nmod media_playlist;\nmod media_segment;\nmod utils;\n\npub use error::Result;\n","traces":[{"line":3,"address":4213648,"length":1,"stats":{"Line":1}},{"line":17,"address":4213676,"length":1,"stats":{"Line":1}},{"line":18,"address":4213773,"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","media","hdd","home","projects","hls_m3u8","src","line.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::tags;\nuse crate::Error;\n\n#[derive(Debug, Default)]\npub struct Lines(Vec\u003cLine\u003e);\n\nimpl Lines {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n}\n\nimpl FromStr for Lines {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut result = Lines::new();\n\n        let mut stream_inf = false;\n        let mut stream_inf_line = None;\n\n        for l in input.lines() {\n            let line = l.trim();\n\n            if line.is_empty() {\n                continue;\n            }\n\n            let pline = {\n                if line.starts_with(tags::ExtXStreamInf::PREFIX) {\n                    stream_inf = true;\n                    stream_inf_line = Some(line);\n\n                    continue;\n                } else if line.starts_with(\"#EXT\") {\n                    Line::Tag(line.parse()?)\n                } else if line.starts_with('#') {\n                    continue; // ignore comments\n                } else {\n                    // stream inf line needs special treatment\n                    if stream_inf {\n                        stream_inf = false;\n                        if let Some(first_line) = stream_inf_line {\n                            let res = Line::Tag(format!(\"{}\\n{}\", first_line, line).parse()?);\n                            stream_inf_line = None;\n                            res\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        Line::Uri(line.trim().to_string())\n                    }\n                }\n            };\n\n            result.push(pline);\n        }\n\n        Ok(result)\n    }\n}\n\nimpl IntoIterator for Lines {\n    type Item = Line;\n    type IntoIter = ::std::vec::IntoIter\u003cLine\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\nimpl Deref for Lines {\n    type Target = Vec\u003cLine\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for Lines {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum Line {\n    Tag(Tag),\n    Uri(String),\n}\n\n#[allow(clippy::large_enum_variant)]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Tag {\n    ExtM3u(tags::ExtM3u),\n    ExtXVersion(tags::ExtXVersion),\n    ExtInf(tags::ExtInf),\n    ExtXByteRange(tags::ExtXByteRange),\n    ExtXDiscontinuity(tags::ExtXDiscontinuity),\n    ExtXKey(tags::ExtXKey),\n    ExtXMap(tags::ExtXMap),\n    ExtXProgramDateTime(tags::ExtXProgramDateTime),\n    ExtXDateRange(tags::ExtXDateRange),\n    ExtXTargetDuration(tags::ExtXTargetDuration),\n    ExtXMediaSequence(tags::ExtXMediaSequence),\n    ExtXDiscontinuitySequence(tags::ExtXDiscontinuitySequence),\n    ExtXEndList(tags::ExtXEndList),\n    ExtXPlaylistType(tags::ExtXPlaylistType),\n    ExtXIFramesOnly(tags::ExtXIFramesOnly),\n    ExtXMedia(tags::ExtXMedia),\n    ExtXStreamInf(tags::ExtXStreamInf),\n    ExtXIFrameStreamInf(tags::ExtXIFrameStreamInf),\n    ExtXSessionData(tags::ExtXSessionData),\n    ExtXSessionKey(tags::ExtXSessionKey),\n    ExtXIndependentSegments(tags::ExtXIndependentSegments),\n    ExtXStart(tags::ExtXStart),\n    Unknown(String),\n}\n\nimpl fmt::Display for Tag {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match \u0026self {\n            Tag::ExtM3u(value) =\u003e value.fmt(f),\n            Tag::ExtXVersion(value) =\u003e value.fmt(f),\n            Tag::ExtInf(value) =\u003e value.fmt(f),\n            Tag::ExtXByteRange(value) =\u003e value.fmt(f),\n            Tag::ExtXDiscontinuity(value) =\u003e value.fmt(f),\n            Tag::ExtXKey(value) =\u003e value.fmt(f),\n            Tag::ExtXMap(value) =\u003e value.fmt(f),\n            Tag::ExtXProgramDateTime(value) =\u003e value.fmt(f),\n            Tag::ExtXDateRange(value) =\u003e value.fmt(f),\n            Tag::ExtXTargetDuration(value) =\u003e value.fmt(f),\n            Tag::ExtXMediaSequence(value) =\u003e value.fmt(f),\n            Tag::ExtXDiscontinuitySequence(value) =\u003e value.fmt(f),\n            Tag::ExtXEndList(value) =\u003e value.fmt(f),\n            Tag::ExtXPlaylistType(value) =\u003e value.fmt(f),\n            Tag::ExtXIFramesOnly(value) =\u003e value.fmt(f),\n            Tag::ExtXMedia(value) =\u003e value.fmt(f),\n            Tag::ExtXStreamInf(value) =\u003e value.fmt(f),\n            Tag::ExtXIFrameStreamInf(value) =\u003e value.fmt(f),\n            Tag::ExtXSessionData(value) =\u003e value.fmt(f),\n            Tag::ExtXSessionKey(value) =\u003e value.fmt(f),\n            Tag::ExtXIndependentSegments(value) =\u003e value.fmt(f),\n            Tag::ExtXStart(value) =\u003e value.fmt(f),\n            Tag::Unknown(value) =\u003e value.fmt(f),\n        }\n    }\n}\n\nimpl FromStr for Tag {\n    type Err = Error;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if s.starts_with(tags::ExtM3u::PREFIX) {\n            s.parse().map(Tag::ExtM3u)\n        } else if s.starts_with(tags::ExtXVersion::PREFIX) {\n            s.parse().map(Tag::ExtXVersion)\n        } else if s.starts_with(tags::ExtInf::PREFIX) {\n            s.parse().map(Tag::ExtInf)\n        } else if s.starts_with(tags::ExtXByteRange::PREFIX) {\n            s.parse().map(Tag::ExtXByteRange)\n        } else if s.starts_with(tags::ExtXDiscontinuity::PREFIX) {\n            s.parse().map(Tag::ExtXDiscontinuity)\n        } else if s.starts_with(tags::ExtXKey::PREFIX) {\n            s.parse().map(Tag::ExtXKey)\n        } else if s.starts_with(tags::ExtXMap::PREFIX) {\n            s.parse().map(Tag::ExtXMap)\n        } else if s.starts_with(tags::ExtXProgramDateTime::PREFIX) {\n            s.parse().map(Tag::ExtXProgramDateTime)\n        } else if s.starts_with(tags::ExtXTargetDuration::PREFIX) {\n            s.parse().map(Tag::ExtXTargetDuration)\n        } else if s.starts_with(tags::ExtXDateRange::PREFIX) {\n            s.parse().map(Tag::ExtXDateRange)\n        } else if s.starts_with(tags::ExtXMediaSequence::PREFIX) {\n            s.parse().map(Tag::ExtXMediaSequence)\n        } else if s.starts_with(tags::ExtXDiscontinuitySequence::PREFIX) {\n            s.parse().map(Tag::ExtXDiscontinuitySequence)\n        } else if s.starts_with(tags::ExtXEndList::PREFIX) {\n            s.parse().map(Tag::ExtXEndList)\n        } else if s.starts_with(tags::ExtXPlaylistType::PREFIX) {\n            s.parse().map(Tag::ExtXPlaylistType)\n        } else if s.starts_with(tags::ExtXIFramesOnly::PREFIX) {\n            s.parse().map(Tag::ExtXIFramesOnly)\n        } else if s.starts_with(tags::ExtXMedia::PREFIX) {\n            s.parse().map(Tag::ExtXMedia)\n        } else if s.starts_with(tags::ExtXStreamInf::PREFIX) {\n            s.parse().map(Tag::ExtXStreamInf)\n        } else if s.starts_with(tags::ExtXIFrameStreamInf::PREFIX) {\n            s.parse().map(Tag::ExtXIFrameStreamInf)\n        } else if s.starts_with(tags::ExtXSessionData::PREFIX) {\n            s.parse().map(Tag::ExtXSessionData)\n        } else if s.starts_with(tags::ExtXSessionKey::PREFIX) {\n            s.parse().map(Tag::ExtXSessionKey)\n        } else if s.starts_with(tags::ExtXIndependentSegments::PREFIX) {\n            s.parse().map(Tag::ExtXIndependentSegments)\n        } else if s.starts_with(tags::ExtXStart::PREFIX) {\n            s.parse().map(Tag::ExtXStart)\n        } else {\n            Ok(Tag::Unknown(s.to_string()))\n        }\n    }\n}\n","traces":[{"line":12,"address":4403712,"length":1,"stats":{"Line":3}},{"line":20,"address":4403744,"length":1,"stats":{"Line":3}},{"line":21,"address":4403776,"length":1,"stats":{"Line":3}},{"line":23,"address":4403833,"length":1,"stats":{"Line":3}},{"line":24,"address":4403841,"length":1,"stats":{"Line":3}},{"line":26,"address":4403853,"length":1,"stats":{"Line":3}},{"line":27,"address":4404185,"length":1,"stats":{"Line":3}},{"line":29,"address":4404260,"length":1,"stats":{"Line":3}},{"line":30,"address":4404349,"length":1,"stats":{"Line":2}},{"line":33,"address":null,"length":0,"stats":{"Line":0}},{"line":34,"address":4404303,"length":1,"stats":{"Line":3}},{"line":35,"address":4404415,"length":1,"stats":{"Line":1}},{"line":36,"address":4404423,"length":1,"stats":{"Line":1}},{"line":38,"address":4404463,"length":1,"stats":{"Line":1}},{"line":39,"address":4404369,"length":1,"stats":{"Line":3}},{"line":40,"address":4404520,"length":1,"stats":{"Line":3}},{"line":41,"address":4404478,"length":1,"stats":{"Line":3}},{"line":42,"address":4405194,"length":1,"stats":{"Line":0}},{"line":45,"address":4405182,"length":1,"stats":{"Line":3}},{"line":46,"address":4405243,"length":1,"stats":{"Line":1}},{"line":47,"address":4405251,"length":1,"stats":{"Line":1}},{"line":48,"address":4405319,"length":1,"stats":{"Line":1}},{"line":49,"address":4406205,"length":1,"stats":{"Line":1}},{"line":50,"address":4406217,"length":1,"stats":{"Line":1}},{"line":52,"address":4406259,"length":1,"stats":{"Line":0}},{"line":55,"address":4405199,"length":1,"stats":{"Line":3}},{"line":60,"address":4406359,"length":1,"stats":{"Line":3}},{"line":63,"address":4406467,"length":1,"stats":{"Line":3}},{"line":71,"address":4406992,"length":1,"stats":{"Line":3}},{"line":72,"address":4406999,"length":1,"stats":{"Line":3}},{"line":79,"address":4407056,"length":1,"stats":{"Line":0}},{"line":80,"address":4407061,"length":1,"stats":{"Line":0}},{"line":85,"address":4407072,"length":1,"stats":{"Line":3}},{"line":86,"address":4407077,"length":1,"stats":{"Line":3}},{"line":125,"address":4407088,"length":1,"stats":{"Line":0}},{"line":126,"address":4407110,"length":1,"stats":{"Line":0}},{"line":127,"address":4407115,"length":1,"stats":{"Line":0}},{"line":128,"address":4407202,"length":1,"stats":{"Line":0}},{"line":129,"address":4407248,"length":1,"stats":{"Line":0}},{"line":130,"address":4407294,"length":1,"stats":{"Line":0}},{"line":131,"address":4407340,"length":1,"stats":{"Line":0}},{"line":132,"address":4407386,"length":1,"stats":{"Line":0}},{"line":133,"address":4407432,"length":1,"stats":{"Line":0}},{"line":134,"address":4407478,"length":1,"stats":{"Line":0}},{"line":135,"address":4407524,"length":1,"stats":{"Line":0}},{"line":136,"address":4407570,"length":1,"stats":{"Line":0}},{"line":137,"address":4407616,"length":1,"stats":{"Line":0}},{"line":138,"address":4407668,"length":1,"stats":{"Line":0}},{"line":139,"address":4407720,"length":1,"stats":{"Line":0}},{"line":140,"address":4407772,"length":1,"stats":{"Line":0}},{"line":141,"address":4407824,"length":1,"stats":{"Line":0}},{"line":142,"address":4407876,"length":1,"stats":{"Line":0}},{"line":143,"address":4407928,"length":1,"stats":{"Line":0}},{"line":144,"address":4407980,"length":1,"stats":{"Line":0}},{"line":145,"address":4408032,"length":1,"stats":{"Line":0}},{"line":146,"address":4408084,"length":1,"stats":{"Line":0}},{"line":147,"address":4408136,"length":1,"stats":{"Line":0}},{"line":148,"address":4408185,"length":1,"stats":{"Line":0}},{"line":149,"address":4408234,"length":1,"stats":{"Line":0}},{"line":157,"address":4408304,"length":1,"stats":{"Line":3}},{"line":158,"address":4408331,"length":1,"stats":{"Line":3}},{"line":159,"address":4408419,"length":1,"stats":{"Line":3}},{"line":160,"address":4408389,"length":1,"stats":{"Line":3}},{"line":161,"address":4408508,"length":1,"stats":{"Line":2}},{"line":162,"address":4408478,"length":1,"stats":{"Line":3}},{"line":163,"address":4408603,"length":1,"stats":{"Line":3}},{"line":164,"address":4408573,"length":1,"stats":{"Line":3}},{"line":165,"address":4408698,"length":1,"stats":{"Line":0}},{"line":166,"address":4408668,"length":1,"stats":{"Line":3}},{"line":167,"address":4408793,"length":1,"stats":{"Line":0}},{"line":168,"address":4408763,"length":1,"stats":{"Line":3}},{"line":169,"address":4408888,"length":1,"stats":{"Line":0}},{"line":170,"address":4408858,"length":1,"stats":{"Line":3}},{"line":171,"address":4408983,"length":1,"stats":{"Line":0}},{"line":172,"address":4408953,"length":1,"stats":{"Line":3}},{"line":173,"address":4409078,"length":1,"stats":{"Line":0}},{"line":174,"address":4409048,"length":1,"stats":{"Line":3}},{"line":175,"address":4409173,"length":1,"stats":{"Line":3}},{"line":176,"address":4409143,"length":1,"stats":{"Line":3}},{"line":177,"address":4409268,"length":1,"stats":{"Line":0}},{"line":178,"address":4409238,"length":1,"stats":{"Line":3}},{"line":179,"address":4409363,"length":1,"stats":{"Line":0}},{"line":180,"address":4409333,"length":1,"stats":{"Line":3}},{"line":181,"address":4409458,"length":1,"stats":{"Line":0}},{"line":182,"address":4409428,"length":1,"stats":{"Line":3}},{"line":183,"address":4409553,"length":1,"stats":{"Line":3}},{"line":184,"address":4409523,"length":1,"stats":{"Line":1}},{"line":185,"address":4409648,"length":1,"stats":{"Line":0}},{"line":186,"address":4409618,"length":1,"stats":{"Line":1}},{"line":187,"address":4409743,"length":1,"stats":{"Line":0}},{"line":188,"address":4409713,"length":1,"stats":{"Line":1}},{"line":189,"address":4409838,"length":1,"stats":{"Line":0}},{"line":190,"address":4409808,"length":1,"stats":{"Line":1}},{"line":191,"address":4409933,"length":1,"stats":{"Line":1}},{"line":192,"address":4409903,"length":1,"stats":{"Line":0}},{"line":193,"address":4410028,"length":1,"stats":{"Line":0}},{"line":194,"address":4409998,"length":1,"stats":{"Line":0}},{"line":195,"address":4410123,"length":1,"stats":{"Line":0}},{"line":196,"address":4410093,"length":1,"stats":{"Line":0}},{"line":197,"address":4410218,"length":1,"stats":{"Line":0}},{"line":198,"address":4410188,"length":1,"stats":{"Line":0}},{"line":199,"address":4410313,"length":1,"stats":{"Line":0}},{"line":200,"address":4410283,"length":1,"stats":{"Line":0}},{"line":201,"address":4410396,"length":1,"stats":{"Line":0}},{"line":203,"address":4410371,"length":1,"stats":{"Line":0}}],"covered":53,"coverable":105},{"path":["/","media","hdd","home","projects","hls_m3u8","src","master_playlist.rs"],"content":"use std::collections::HashSet;\nuse std::fmt;\nuse std::iter;\nuse std::str::FromStr;\n\nuse derive_builder::Builder;\n\nuse crate::line::{Line, Lines, Tag};\nuse crate::tags::{\n    ExtM3u, ExtXIFrameStreamInf, ExtXIndependentSegments, ExtXMedia, ExtXSessionData,\n    ExtXSessionKey, ExtXStart, ExtXStreamInf, ExtXVersion,\n};\nuse crate::types::{ClosedCaptions, MediaType, ProtocolVersion, RequiredVersion};\nuse crate::Error;\n\n/// Master playlist.\n#[derive(Debug, Clone, Builder)]\n#[builder(build_fn(validate = \"Self::validate\"))]\n#[builder(setter(into, strip_option))]\npub struct MasterPlaylist {\n    #[builder(default, setter(name = \"version\"))]\n    /// Sets the protocol compatibility version of the resulting playlist.\n    ///\n    /// If the resulting playlist has tags which requires a compatibility version greater than\n    /// `version`,\n    /// `build()` method will fail with an `ErrorKind::InvalidInput` error.\n    ///\n    /// The default is the maximum version among the tags in the playlist.\n    version_tag: ExtXVersion,\n    #[builder(default)]\n    /// Sets the [ExtXIndependentSegments] tag.\n    independent_segments_tag: Option\u003cExtXIndependentSegments\u003e,\n    #[builder(default)]\n    /// Sets the [ExtXStart] tag.\n    start_tag: Option\u003cExtXStart\u003e,\n    /// Sets the [ExtXMedia] tag.\n    media_tags: Vec\u003cExtXMedia\u003e,\n    /// Sets all [ExtXStreamInf]s.\n    stream_inf_tags: Vec\u003cExtXStreamInf\u003e,\n    /// Sets all [ExtXIFrameStreamInf]s.\n    i_frame_stream_inf_tags: Vec\u003cExtXIFrameStreamInf\u003e,\n    /// Sets all [ExtXSessionData]s.\n    session_data_tags: Vec\u003cExtXSessionData\u003e,\n    /// Sets all [ExtXSessionKey]s.\n    session_key_tags: Vec\u003cExtXSessionKey\u003e,\n}\n\nimpl MasterPlaylist {\n    /// Returns a Builder for a MasterPlaylist.\n    pub fn builder() -\u003e MasterPlaylistBuilder {\n        MasterPlaylistBuilder::default()\n    }\n\n    /// Returns the `EXT-X-VERSION` tag contained in the playlist.\n    pub const fn version_tag(\u0026self) -\u003e ExtXVersion {\n        self.version_tag\n    }\n\n    /// Returns the `EXT-X-INDEPENDENT-SEGMENTS` tag contained in the playlist.\n    pub const fn independent_segments_tag(\u0026self) -\u003e Option\u003cExtXIndependentSegments\u003e {\n        self.independent_segments_tag\n    }\n\n    /// Returns the `EXT-X-START` tag contained in the playlist.\n    pub const fn start_tag(\u0026self) -\u003e Option\u003cExtXStart\u003e {\n        self.start_tag\n    }\n\n    /// Returns the `EXT-X-MEDIA` tags contained in the playlist.\n    pub fn media_tags(\u0026self) -\u003e \u0026[ExtXMedia] {\n        \u0026self.media_tags\n    }\n\n    /// Returns the `EXT-X-STREAM-INF` tags contained in the playlist.\n    pub fn stream_inf_tags(\u0026self) -\u003e \u0026[ExtXStreamInf] {\n        \u0026self.stream_inf_tags\n    }\n\n    /// Returns the `EXT-X-I-FRAME-STREAM-INF` tags contained in the playlist.\n    pub fn i_frame_stream_inf_tags(\u0026self) -\u003e \u0026[ExtXIFrameStreamInf] {\n        \u0026self.i_frame_stream_inf_tags\n    }\n\n    /// Returns the `EXT-X-SESSION-DATA` tags contained in the playlist.\n    pub fn session_data_tags(\u0026self) -\u003e \u0026[ExtXSessionData] {\n        \u0026self.session_data_tags\n    }\n\n    /// Returns the `EXT-X-SESSION-KEY` tags contained in the playlist.\n    pub fn session_key_tags(\u0026self) -\u003e \u0026[ExtXSessionKey] {\n        \u0026self.session_key_tags\n    }\n}\n\nimpl RequiredVersion for MasterPlaylist {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        self.version_tag.version()\n    }\n}\n\nimpl MasterPlaylistBuilder {\n    fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n        let required_version = self.required_version();\n        let specified_version = self\n            .version_tag\n            .unwrap_or_else(|| required_version.into())\n            .version();\n\n        if required_version \u003e specified_version {\n            return Err(Error::required_version(required_version, specified_version).to_string());\n        }\n\n        self.validate_stream_inf_tags().map_err(|e| e.to_string())?;\n        self.validate_i_frame_stream_inf_tags()\n            .map_err(|e| e.to_string())?;\n        self.validate_session_data_tags()\n            .map_err(|e| e.to_string())?;\n\n        Ok(())\n    }\n\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        iter::empty()\n            .chain(\n                self.independent_segments_tag\n                    .iter()\n                    .map(|t| t.iter().map(|t| t.required_version()))\n                    .flatten(),\n            )\n            .chain(\n                self.start_tag\n                    .iter()\n                    .map(|t| t.iter().map(|t| t.required_version()))\n                    .flatten(),\n            )\n            .chain(\n                self.media_tags\n                    .iter()\n                    .map(|t| t.iter().map(|t| t.required_version()))\n                    .flatten(),\n            )\n            .chain(\n                self.stream_inf_tags\n                    .iter()\n                    .map(|t| t.iter().map(|t| t.required_version()))\n                    .flatten(),\n            )\n            .chain(\n                self.i_frame_stream_inf_tags\n                    .iter()\n                    .map(|t| t.iter().map(|t| t.required_version()))\n                    .flatten(),\n            )\n            .chain(\n                self.session_data_tags\n                    .iter()\n                    .map(|t| t.iter().map(|t| t.required_version()))\n                    .flatten(),\n            )\n            .chain(\n                self.session_key_tags\n                    .iter()\n                    .map(|t| t.iter().map(|t| t.required_version()))\n                    .flatten(),\n            )\n            .max()\n            .unwrap_or_else(ProtocolVersion::latest)\n    }\n\n    fn validate_stream_inf_tags(\u0026self) -\u003e crate::Result\u003c()\u003e {\n        if let Some(value) = \u0026self.stream_inf_tags {\n            let mut has_none_closed_captions = false;\n\n            for t in value {\n                if let Some(group_id) = t.audio() {\n                    if !self.check_media_group(MediaType::Audio, group_id) {\n                        return Err(Error::unmatched_group(group_id));\n                    }\n                }\n                if let Some(group_id) = t.video() {\n                    if !self.check_media_group(MediaType::Video, group_id) {\n                        return Err(Error::unmatched_group(group_id));\n                    }\n                }\n                if let Some(group_id) = t.subtitles() {\n                    if !self.check_media_group(MediaType::Subtitles, group_id) {\n                        return Err(Error::unmatched_group(group_id));\n                    }\n                }\n                match t.closed_captions() {\n                    Some(\u0026ClosedCaptions::GroupId(ref group_id)) =\u003e {\n                        if !self.check_media_group(MediaType::ClosedCaptions, group_id) {\n                            return Err(Error::unmatched_group(group_id));\n                        }\n                    }\n                    Some(\u0026ClosedCaptions::None) =\u003e {\n                        has_none_closed_captions = true;\n                    }\n                    None =\u003e {}\n                }\n            }\n            if has_none_closed_captions\n                \u0026\u0026 !value\n                    .iter()\n                    .all(|t| t.closed_captions() == Some(\u0026ClosedCaptions::None))\n            {\n                return Err(Error::invalid_input());\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_i_frame_stream_inf_tags(\u0026self) -\u003e crate::Result\u003c()\u003e {\n        if let Some(value) = \u0026self.i_frame_stream_inf_tags {\n            for t in value {\n                if let Some(group_id) = t.video() {\n                    if !self.check_media_group(MediaType::Video, group_id) {\n                        return Err(Error::unmatched_group(group_id));\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_session_data_tags(\u0026self) -\u003e crate::Result\u003c()\u003e {\n        let mut set = HashSet::new();\n        if let Some(value) = \u0026self.session_data_tags {\n            for t in value {\n                if !set.insert((t.data_id(), t.language())) {\n                    return Err(Error::custom(format!(\"Conflict: {}\", t)));\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn check_media_group\u003cT: ToString\u003e(\u0026self, media_type: MediaType, group_id: T) -\u003e bool {\n        if let Some(value) = \u0026self.media_tags {\n            value\n                .iter()\n                .any(|t| t.media_type() == media_type \u0026\u0026 t.group_id() == \u0026group_id.to_string())\n        } else {\n            false\n        }\n    }\n}\n\nimpl fmt::Display for MasterPlaylist {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        writeln!(f, \"{}\", ExtM3u)?;\n        if self.version_tag.version() != ProtocolVersion::V1 {\n            writeln!(f, \"{}\", self.version_tag)?;\n        }\n        for t in \u0026self.media_tags {\n            writeln!(f, \"{}\", t)?;\n        }\n        for t in \u0026self.stream_inf_tags {\n            writeln!(f, \"{}\", t)?;\n        }\n        for t in \u0026self.i_frame_stream_inf_tags {\n            writeln!(f, \"{}\", t)?;\n        }\n        for t in \u0026self.session_data_tags {\n            writeln!(f, \"{}\", t)?;\n        }\n        for t in \u0026self.session_key_tags {\n            writeln!(f, \"{}\", t)?;\n        }\n        if let Some(value) = \u0026self.independent_segments_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.start_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for MasterPlaylist {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut builder = MasterPlaylist::builder();\n\n        let mut media_tags = vec![];\n        let mut stream_inf_tags = vec![];\n        let mut i_frame_stream_inf_tags = vec![];\n        let mut session_data_tags = vec![];\n        let mut session_key_tags = vec![];\n\n        for (i, line) in input.parse::\u003cLines\u003e()?.into_iter().enumerate() {\n            match line {\n                Line::Tag(tag) =\u003e {\n                    if i == 0 {\n                        if tag != Tag::ExtM3u(ExtM3u) {\n                            return Err(Error::invalid_input());\n                        }\n                        continue;\n                    }\n                    match tag {\n                        Tag::ExtM3u(_) =\u003e {\n                            return Err(Error::invalid_input());\n                        }\n                        Tag::ExtXVersion(t) =\u003e {\n                            builder.version(t.version());\n                        }\n                        Tag::ExtInf(_)\n                        | Tag::ExtXByteRange(_)\n                        | Tag::ExtXDiscontinuity(_)\n                        | Tag::ExtXKey(_)\n                        | Tag::ExtXMap(_)\n                        | Tag::ExtXProgramDateTime(_)\n                        | Tag::ExtXDateRange(_)\n                        | Tag::ExtXTargetDuration(_)\n                        | Tag::ExtXMediaSequence(_)\n                        | Tag::ExtXDiscontinuitySequence(_)\n                        | Tag::ExtXEndList(_)\n                        | Tag::ExtXPlaylistType(_)\n                        | Tag::ExtXIFramesOnly(_) =\u003e {\n                            return Err(Error::custom(format!(\n                                \"This tag isn't allowed in a master playlist: {}\",\n                                tag\n                            )));\n                        }\n                        Tag::ExtXMedia(t) =\u003e {\n                            media_tags.push(t);\n                        }\n                        Tag::ExtXStreamInf(t) =\u003e {\n                            stream_inf_tags.push(t);\n                        }\n                        Tag::ExtXIFrameStreamInf(t) =\u003e {\n                            i_frame_stream_inf_tags.push(t);\n                        }\n                        Tag::ExtXSessionData(t) =\u003e {\n                            session_data_tags.push(t);\n                        }\n                        Tag::ExtXSessionKey(t) =\u003e {\n                            session_key_tags.push(t);\n                        }\n                        Tag::ExtXIndependentSegments(t) =\u003e {\n                            builder.independent_segments_tag(t);\n                        }\n                        Tag::ExtXStart(t) =\u003e {\n                            builder.start_tag(t);\n                        }\n                        _ =\u003e {\n                            // [6.3.1. General Client Responsibilities]\n                            // \u003e ignore any unrecognized tags.\n                            // TODO: collect custom tags\n                        }\n                    }\n                }\n                Line::Uri(uri) =\u003e {\n                    return Err(Error::custom(format!(\"Unexpected URI: {:?}\", uri)));\n                }\n            }\n        }\n\n        builder.media_tags(media_tags);\n        builder.stream_inf_tags(stream_inf_tags);\n        builder.i_frame_stream_inf_tags(i_frame_stream_inf_tags);\n        builder.session_data_tags(session_data_tags);\n        builder.session_key_tags(session_key_tags);\n\n        builder.build().map_err(Error::builder_error)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parser() {\n        r#\"#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=150000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=416x234\nhttp://example.com/low/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=240000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=416x234\nhttp://example.com/lo_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=440000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=416x234\nhttp://example.com/hi_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=640000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=640x360\nhttp://example.com/high/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=\"mp4a.40.5\"\nhttp://example.com/audio/index.m3u8\n\"#\n        .parse::\u003cMasterPlaylist\u003e()\n        .unwrap();\n    }\n\n    #[test]\n    fn test_display() {\n        let input = r#\"#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=150000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=416x234\nhttp://example.com/low/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=240000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=416x234\nhttp://example.com/lo_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=440000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=416x234\nhttp://example.com/hi_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=640000,CODECS=\"avc1.42e00a,mp4a.40.2\",RESOLUTION=640x360\nhttp://example.com/high/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=\"mp4a.40.5\"\nhttp://example.com/audio/index.m3u8\n\"#;\n        let playlist = input.parse::\u003cMasterPlaylist\u003e().unwrap();\n        assert_eq!(playlist.to_string(), input);\n    }\n}\n","traces":[{"line":50,"address":4449088,"length":1,"stats":{"Line":1}},{"line":55,"address":4449120,"length":1,"stats":{"Line":0}},{"line":56,"address":4449125,"length":1,"stats":{"Line":0}},{"line":60,"address":4449152,"length":1,"stats":{"Line":0}},{"line":61,"address":4449157,"length":1,"stats":{"Line":0}},{"line":65,"address":4449184,"length":1,"stats":{"Line":0}},{"line":66,"address":4449189,"length":1,"stats":{"Line":0}},{"line":70,"address":4449216,"length":1,"stats":{"Line":0}},{"line":71,"address":4449225,"length":1,"stats":{"Line":0}},{"line":75,"address":4449280,"length":1,"stats":{"Line":0}},{"line":76,"address":4449289,"length":1,"stats":{"Line":0}},{"line":80,"address":4449344,"length":1,"stats":{"Line":0}},{"line":81,"address":4449353,"length":1,"stats":{"Line":0}},{"line":85,"address":4449408,"length":1,"stats":{"Line":0}},{"line":86,"address":4449417,"length":1,"stats":{"Line":0}},{"line":90,"address":4449472,"length":1,"stats":{"Line":0}},{"line":91,"address":4449481,"length":1,"stats":{"Line":0}},{"line":96,"address":4449536,"length":1,"stats":{"Line":0}},{"line":97,"address":4449545,"length":1,"stats":{"Line":0}},{"line":102,"address":4449584,"length":1,"stats":{"Line":1}},{"line":103,"address":4449599,"length":1,"stats":{"Line":1}},{"line":104,"address":4449643,"length":1,"stats":{"Line":1}},{"line":105,"address":null,"length":0,"stats":{"Line":0}},{"line":106,"address":4309568,"length":1,"stats":{"Line":2}},{"line":107,"address":null,"length":0,"stats":{"Line":0}},{"line":109,"address":4449697,"length":1,"stats":{"Line":1}},{"line":110,"address":4449746,"length":1,"stats":{"Line":0}},{"line":113,"address":4309616,"length":1,"stats":{"Line":1}},{"line":114,"address":4450129,"length":1,"stats":{"Line":1}},{"line":115,"address":4309712,"length":1,"stats":{"Line":1}},{"line":116,"address":4450414,"length":1,"stats":{"Line":1}},{"line":117,"address":4309808,"length":1,"stats":{"Line":1}},{"line":119,"address":4450704,"length":1,"stats":{"Line":1}},{"line":122,"address":4450912,"length":1,"stats":{"Line":1}},{"line":123,"address":4450927,"length":1,"stats":{"Line":1}},{"line":167,"address":null,"length":0,"stats":{"Line":0}},{"line":170,"address":4452208,"length":1,"stats":{"Line":1}},{"line":171,"address":4452227,"length":1,"stats":{"Line":1}},{"line":172,"address":4452292,"length":1,"stats":{"Line":1}},{"line":174,"address":4452297,"length":1,"stats":{"Line":1}},{"line":175,"address":4452446,"length":1,"stats":{"Line":1}},{"line":176,"address":4452515,"length":1,"stats":{"Line":0}},{"line":177,"address":4452565,"length":1,"stats":{"Line":0}},{"line":180,"address":4452636,"length":1,"stats":{"Line":1}},{"line":181,"address":4452719,"length":1,"stats":{"Line":0}},{"line":182,"address":4452769,"length":1,"stats":{"Line":0}},{"line":185,"address":4452824,"length":1,"stats":{"Line":1}},{"line":186,"address":4452889,"length":1,"stats":{"Line":0}},{"line":187,"address":4452939,"length":1,"stats":{"Line":0}},{"line":190,"address":4452994,"length":1,"stats":{"Line":1}},{"line":191,"address":4453015,"length":1,"stats":{"Line":1}},{"line":192,"address":4453060,"length":1,"stats":{"Line":0}},{"line":193,"address":4453151,"length":1,"stats":{"Line":0}},{"line":196,"address":null,"length":0,"stats":{"Line":0}},{"line":197,"address":4453100,"length":1,"stats":{"Line":0}},{"line":199,"address":null,"length":0,"stats":{"Line":0}},{"line":202,"address":4452380,"length":1,"stats":{"Line":1}},{"line":203,"address":4453231,"length":1,"stats":{"Line":0}},{"line":204,"address":null,"length":0,"stats":{"Line":0}},{"line":205,"address":4310928,"length":1,"stats":{"Line":0}},{"line":207,"address":4453327,"length":1,"stats":{"Line":0}},{"line":210,"address":4453379,"length":1,"stats":{"Line":1}},{"line":213,"address":4453392,"length":1,"stats":{"Line":1}},{"line":214,"address":4453411,"length":1,"stats":{"Line":1}},{"line":215,"address":4453476,"length":1,"stats":{"Line":1}},{"line":216,"address":4453590,"length":1,"stats":{"Line":0}},{"line":217,"address":4453665,"length":1,"stats":{"Line":0}},{"line":218,"address":4453715,"length":1,"stats":{"Line":0}},{"line":223,"address":4453792,"length":1,"stats":{"Line":1}},{"line":226,"address":4453808,"length":1,"stats":{"Line":1}},{"line":227,"address":4453823,"length":1,"stats":{"Line":1}},{"line":228,"address":4453867,"length":1,"stats":{"Line":1}},{"line":229,"address":4453934,"length":1,"stats":{"Line":1}},{"line":230,"address":4454115,"length":1,"stats":{"Line":0}},{"line":231,"address":4454236,"length":1,"stats":{"Line":0}},{"line":235,"address":4454473,"length":1,"stats":{"Line":1}},{"line":238,"address":4311008,"length":1,"stats":{"Line":0}},{"line":239,"address":4311034,"length":1,"stats":{"Line":0}},{"line":240,"address":4311112,"length":1,"stats":{"Line":0}},{"line":242,"address":4311196,"length":1,"stats":{"Line":0}},{"line":244,"address":4311092,"length":1,"stats":{"Line":0}},{"line":250,"address":4454528,"length":1,"stats":{"Line":1}},{"line":251,"address":4454551,"length":1,"stats":{"Line":1}},{"line":252,"address":4454853,"length":1,"stats":{"Line":1}},{"line":253,"address":4454923,"length":1,"stats":{"Line":0}},{"line":255,"address":4455217,"length":1,"stats":{"Line":1}},{"line":256,"address":4455426,"length":1,"stats":{"Line":0}},{"line":258,"address":4455333,"length":1,"stats":{"Line":1}},{"line":259,"address":4455888,"length":1,"stats":{"Line":1}},{"line":261,"address":4455795,"length":1,"stats":{"Line":1}},{"line":262,"address":4456350,"length":1,"stats":{"Line":0}},{"line":264,"address":4456257,"length":1,"stats":{"Line":1}},{"line":265,"address":4456812,"length":1,"stats":{"Line":0}},{"line":267,"address":4456719,"length":1,"stats":{"Line":1}},{"line":268,"address":4457286,"length":1,"stats":{"Line":0}},{"line":270,"address":4457181,"length":1,"stats":{"Line":1}},{"line":271,"address":4457569,"length":1,"stats":{"Line":0}},{"line":273,"address":4457831,"length":1,"stats":{"Line":1}},{"line":274,"address":4457902,"length":1,"stats":{"Line":0}},{"line":276,"address":4458160,"length":1,"stats":{"Line":1}},{"line":283,"address":4458176,"length":1,"stats":{"Line":1}},{"line":284,"address":4458208,"length":1,"stats":{"Line":1}},{"line":286,"address":4458394,"length":1,"stats":{"Line":1}},{"line":287,"address":4458468,"length":1,"stats":{"Line":1}},{"line":288,"address":4458543,"length":1,"stats":{"Line":1}},{"line":289,"address":4458618,"length":1,"stats":{"Line":1}},{"line":290,"address":4458693,"length":1,"stats":{"Line":1}},{"line":292,"address":4458759,"length":1,"stats":{"Line":1}},{"line":293,"address":4459840,"length":1,"stats":{"Line":0}},{"line":294,"address":4459842,"length":1,"stats":{"Line":1}},{"line":295,"address":4459928,"length":1,"stats":{"Line":1}},{"line":296,"address":4459994,"length":1,"stats":{"Line":1}},{"line":297,"address":4460122,"length":1,"stats":{"Line":0}},{"line":299,"address":4463627,"length":1,"stats":{"Line":1}},{"line":301,"address":4460511,"length":1,"stats":{"Line":0}},{"line":302,"address":4459939,"length":1,"stats":{"Line":1}},{"line":303,"address":4460385,"length":1,"stats":{"Line":0}},{"line":305,"address":4460450,"length":1,"stats":{"Line":0}},{"line":306,"address":4460464,"length":1,"stats":{"Line":0}},{"line":308,"address":null,"length":0,"stats":{"Line":0}},{"line":309,"address":null,"length":0,"stats":{"Line":0}},{"line":310,"address":null,"length":0,"stats":{"Line":0}},{"line":311,"address":null,"length":0,"stats":{"Line":0}},{"line":312,"address":null,"length":0,"stats":{"Line":0}},{"line":313,"address":null,"length":0,"stats":{"Line":0}},{"line":314,"address":null,"length":0,"stats":{"Line":0}},{"line":315,"address":null,"length":0,"stats":{"Line":0}},{"line":316,"address":null,"length":0,"stats":{"Line":0}},{"line":317,"address":null,"length":0,"stats":{"Line":0}},{"line":318,"address":null,"length":0,"stats":{"Line":0}},{"line":319,"address":null,"length":0,"stats":{"Line":0}},{"line":320,"address":null,"length":0,"stats":{"Line":0}},{"line":321,"address":4460532,"length":1,"stats":{"Line":0}},{"line":322,"address":4460524,"length":1,"stats":{"Line":0}},{"line":323,"address":null,"length":0,"stats":{"Line":0}},{"line":326,"address":4460777,"length":1,"stats":{"Line":0}},{"line":327,"address":4460856,"length":1,"stats":{"Line":0}},{"line":329,"address":4460920,"length":1,"stats":{"Line":1}},{"line":330,"address":4460993,"length":1,"stats":{"Line":1}},{"line":332,"address":4461054,"length":1,"stats":{"Line":0}},{"line":333,"address":4461190,"length":1,"stats":{"Line":0}},{"line":335,"address":4461346,"length":1,"stats":{"Line":0}},{"line":336,"address":4461434,"length":1,"stats":{"Line":0}},{"line":338,"address":4461542,"length":1,"stats":{"Line":0}},{"line":339,"address":4461630,"length":1,"stats":{"Line":0}},{"line":341,"address":null,"length":0,"stats":{"Line":0}},{"line":342,"address":4461746,"length":1,"stats":{"Line":0}},{"line":344,"address":4461758,"length":1,"stats":{"Line":0}},{"line":345,"address":4461790,"length":1,"stats":{"Line":0}},{"line":347,"address":null,"length":0,"stats":{"Line":0}},{"line":354,"address":4460056,"length":1,"stats":{"Line":1}},{"line":355,"address":4461875,"length":1,"stats":{"Line":0}},{"line":360,"address":4464050,"length":1,"stats":{"Line":1}},{"line":361,"address":4462209,"length":1,"stats":{"Line":1}},{"line":362,"address":4462272,"length":1,"stats":{"Line":1}},{"line":363,"address":4462335,"length":1,"stats":{"Line":1}},{"line":364,"address":4462398,"length":1,"stats":{"Line":1}},{"line":366,"address":4462477,"length":1,"stats":{"Line":1}},{"line":375,"address":4658912,"length":1,"stats":{"Line":2}},{"line":376,"address":4658926,"length":1,"stats":{"Line":1}},{"line":393,"address":4658992,"length":1,"stats":{"Line":2}},{"line":394,"address":4659006,"length":1,"stats":{"Line":1}},{"line":406,"address":4659020,"length":1,"stats":{"Line":1}},{"line":407,"address":4659091,"length":1,"stats":{"Line":1}}],"covered":74,"coverable":164},{"path":["/","media","hdd","home","projects","hls_m3u8","src","media_playlist.rs"],"content":"use std::fmt;\nuse std::iter;\nuse std::str::FromStr;\nuse std::time::Duration;\n\nuse derive_builder::Builder;\n\nuse crate::line::{Line, Lines, Tag};\nuse crate::media_segment::MediaSegment;\nuse crate::tags::{\n    ExtM3u, ExtXDiscontinuitySequence, ExtXEndList, ExtXIFramesOnly, ExtXIndependentSegments,\n    ExtXMediaSequence, ExtXPlaylistType, ExtXStart, ExtXTargetDuration, ExtXVersion,\n};\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::Error;\n\n/// Media playlist.\n#[derive(Debug, Clone, Builder)]\n#[builder(build_fn(validate = \"Self::validate\"))]\n#[builder(setter(into, strip_option))]\npub struct MediaPlaylist {\n    /// Sets the protocol compatibility version of the resulting playlist.\n    ///\n    /// If the resulting playlist has tags which requires a compatibility\n    /// version greater than `version`,\n    /// `build()` method will fail with an `ErrorKind::InvalidInput` error.\n    ///\n    /// The default is the maximum version among the tags in the playlist.\n    #[builder(setter(name = \"version\"))]\n    version_tag: ExtXVersion,\n    /// Sets the [ExtXTargetDuration] tag.\n    target_duration_tag: ExtXTargetDuration,\n    #[builder(default)]\n    /// Sets the [ExtXMediaSequence] tag.\n    media_sequence_tag: Option\u003cExtXMediaSequence\u003e,\n    #[builder(default)]\n    /// Sets the [ExtXDiscontinuitySequence] tag.\n    discontinuity_sequence_tag: Option\u003cExtXDiscontinuitySequence\u003e,\n    #[builder(default)]\n    /// Sets the [ExtXPlaylistType] tag.\n    playlist_type_tag: Option\u003cExtXPlaylistType\u003e,\n    #[builder(default)]\n    /// Sets the [ExtXIFramesOnly] tag.\n    i_frames_only_tag: Option\u003cExtXIFramesOnly\u003e,\n    #[builder(default)]\n    /// Sets the [ExtXIndependentSegments] tag.\n    independent_segments_tag: Option\u003cExtXIndependentSegments\u003e,\n    #[builder(default)]\n    /// Sets the [ExtXStart] tag.\n    start_tag: Option\u003cExtXStart\u003e,\n    #[builder(default)]\n    /// Sets the [ExtXEndList] tag.\n    end_list_tag: Option\u003cExtXEndList\u003e,\n    /// Sets all [MediaSegment]s.\n    segments: Vec\u003cMediaSegment\u003e,\n    /// Sets the allowable excess duration of each media segment in the associated playlist.\n    ///\n    /// # Error\n    /// If there is a media segment of which duration exceeds\n    /// `#EXT-X-TARGETDURATION + allowable_excess_duration`,\n    /// the invocation of `MediaPlaylistBuilder::build()` method will fail.\n    ///\n    /// The default value is `Duration::from_secs(0)`.\n    #[builder(default = \"Duration::from_secs(0)\")]\n    allowable_excess_duration: Duration,\n}\n\nimpl MediaPlaylistBuilder {\n    fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n        let required_version = self.required_version();\n        let specified_version = self\n            .version_tag\n            .unwrap_or_else(|| required_version.into())\n            .version();\n\n        if required_version \u003e specified_version {\n            return Err(Error::custom(format!(\n                \"required_version: {}, specified_version: {}\",\n                required_version, specified_version\n            ))\n            .to_string());\n        }\n\n        if let Some(target_duration) = \u0026self.target_duration_tag {\n            self.validate_media_segments(target_duration.duration())\n                .map_err(|e| e.to_string())?;\n        }\n\n        Ok(())\n    }\n\n    fn validate_media_segments(\u0026self, target_duration: Duration) -\u003e crate::Result\u003c()\u003e {\n        let mut last_range_uri = None;\n        if let Some(segments) = \u0026self.segments {\n            for s in segments {\n                // CHECK: `#EXT-X-TARGETDURATION`\n                let segment_duration = s.inf_tag().duration();\n                let rounded_segment_duration = if segment_duration.subsec_nanos() \u003c 500_000_000 {\n                    Duration::from_secs(segment_duration.as_secs())\n                } else {\n                    Duration::from_secs(segment_duration.as_secs() + 1)\n                };\n\n                let max_segment_duration = {\n                    if let Some(value) = \u0026self.allowable_excess_duration {\n                        target_duration + *value\n                    } else {\n                        target_duration\n                    }\n                };\n\n                if rounded_segment_duration \u003e max_segment_duration {\n                    return Err(Error::custom(format!(\n                        \"Too large segment duration: actual={:?}, max={:?}, target_duration={:?}, uri={:?}\",\n                        segment_duration,\n                        max_segment_duration,\n                        target_duration,\n                        s.uri()\n                    )));\n                }\n\n                // CHECK: `#EXT-X-BYTE-RANGE`\n                if let Some(tag) = s.byte_range_tag() {\n                    if tag.to_range().start().is_none() {\n                        let last_uri = last_range_uri.ok_or_else(Error::invalid_input)?;\n                        if last_uri != s.uri() {\n                            return Err(Error::invalid_input());\n                        }\n                    } else {\n                        last_range_uri = Some(s.uri());\n                    }\n                } else {\n                    last_range_uri = None;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        iter::empty()\n            .chain(\n                self.target_duration_tag\n                    .iter()\n                    .map(|t| t.required_version()),\n            )\n            .chain(self.media_sequence_tag.iter().map(|t| {\n                if let Some(p) = t {\n                    p.required_version()\n                } else {\n                    ProtocolVersion::V1\n                }\n            }))\n            .chain(self.discontinuity_sequence_tag.iter().map(|t| {\n                if let Some(p) = t {\n                    p.required_version()\n                } else {\n                    ProtocolVersion::V1\n                }\n            }))\n            .chain(self.playlist_type_tag.iter().map(|t| {\n                if let Some(p) = t {\n                    p.required_version()\n                } else {\n                    ProtocolVersion::V1\n                }\n            }))\n            .chain(self.i_frames_only_tag.iter().map(|t| {\n                if let Some(p) = t {\n                    p.required_version()\n                } else {\n                    ProtocolVersion::V1\n                }\n            }))\n            .chain(self.independent_segments_tag.iter().map(|t| {\n                if let Some(p) = t {\n                    p.required_version()\n                } else {\n                    ProtocolVersion::V1\n                }\n            }))\n            .chain(self.start_tag.iter().map(|t| {\n                if let Some(p) = t {\n                    p.required_version()\n                } else {\n                    ProtocolVersion::V1\n                }\n            }))\n            .chain(self.end_list_tag.iter().map(|t| {\n                if let Some(p) = t {\n                    p.required_version()\n                } else {\n                    ProtocolVersion::V1\n                }\n            }))\n            .chain(self.segments.iter().map(|t| {\n                t.iter()\n                    .map(|s| s.required_version())\n                    .max()\n                    .unwrap_or(ProtocolVersion::V1)\n            }))\n            .max()\n            .unwrap_or_else(ProtocolVersion::latest)\n    }\n\n    /// Adds a media segment to the resulting playlist.\n    pub fn push_segment\u003cVALUE: Into\u003cMediaSegment\u003e\u003e(\u0026mut self, value: VALUE) -\u003e \u0026mut Self {\n        if let Some(segments) = \u0026mut self.segments {\n            segments.push(value.into());\n        } else {\n            self.segments = Some(vec![value.into()]);\n        }\n        self\n    }\n\n    /// Parse the rest of the [MediaPlaylist] from an m3u8 file.\n    pub fn parse(\u0026mut self, input: \u0026str) -\u003e crate::Result\u003cMediaPlaylist\u003e {\n        parse_media_playlist(input, self)\n    }\n}\n\nimpl MediaPlaylist {\n    /// Creates a [MediaPlaylistBuilder].\n    pub fn builder() -\u003e MediaPlaylistBuilder {\n        MediaPlaylistBuilder::default()\n    }\n    /// Returns the `EXT-X-VERSION` tag contained in the playlist.\n    pub const fn version_tag(\u0026self) -\u003e ExtXVersion {\n        self.version_tag\n    }\n\n    /// Returns the `EXT-X-TARGETDURATION` tag contained in the playlist.\n    pub const fn target_duration_tag(\u0026self) -\u003e ExtXTargetDuration {\n        self.target_duration_tag\n    }\n\n    /// Returns the `EXT-X-MEDIA-SEQUENCE` tag contained in the playlist.\n    pub const fn media_sequence_tag(\u0026self) -\u003e Option\u003cExtXMediaSequence\u003e {\n        self.media_sequence_tag\n    }\n\n    /// Returns the `EXT-X-DISCONTINUITY-SEQUENCE` tag contained in the playlist.\n    pub const fn discontinuity_sequence_tag(\u0026self) -\u003e Option\u003cExtXDiscontinuitySequence\u003e {\n        self.discontinuity_sequence_tag\n    }\n\n    /// Returns the `EXT-X-PLAYLIST-TYPE` tag contained in the playlist.\n    pub const fn playlist_type_tag(\u0026self) -\u003e Option\u003cExtXPlaylistType\u003e {\n        self.playlist_type_tag\n    }\n\n    /// Returns the `EXT-X-I-FRAMES-ONLY` tag contained in the playlist.\n    pub const fn i_frames_only_tag(\u0026self) -\u003e Option\u003cExtXIFramesOnly\u003e {\n        self.i_frames_only_tag\n    }\n\n    /// Returns the `EXT-X-INDEPENDENT-SEGMENTS` tag contained in the playlist.\n    pub const fn independent_segments_tag(\u0026self) -\u003e Option\u003cExtXIndependentSegments\u003e {\n        self.independent_segments_tag\n    }\n\n    /// Returns the `EXT-X-START` tag contained in the playlist.\n    pub const fn start_tag(\u0026self) -\u003e Option\u003cExtXStart\u003e {\n        self.start_tag\n    }\n\n    /// Returns the `EXT-X-ENDLIST` tag contained in the playlist.\n    pub const fn end_list_tag(\u0026self) -\u003e Option\u003cExtXEndList\u003e {\n        self.end_list_tag\n    }\n\n    /// Returns the media segments contained in the playlist.\n    pub fn segments(\u0026self) -\u003e \u0026[MediaSegment] {\n        \u0026self.segments\n    }\n}\n\nimpl fmt::Display for MediaPlaylist {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        writeln!(f, \"{}\", ExtM3u)?;\n        if self.version_tag.version() != ProtocolVersion::V1 {\n            writeln!(f, \"{}\", self.version_tag)?;\n        }\n        writeln!(f, \"{}\", self.target_duration_tag)?;\n        if let Some(value) = \u0026self.media_sequence_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.discontinuity_sequence_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.playlist_type_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.i_frames_only_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.independent_segments_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.start_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        for segment in \u0026self.segments {\n            write!(f, \"{}\", segment)?;\n        }\n        if let Some(value) = \u0026self.end_list_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        Ok(())\n    }\n}\n\nfn parse_media_playlist(\n    input: \u0026str,\n    builder: \u0026mut MediaPlaylistBuilder,\n) -\u003e crate::Result\u003cMediaPlaylist\u003e {\n    let mut segment = MediaSegment::builder();\n    let mut segments = vec![];\n\n    let mut has_partial_segment = false;\n    let mut has_discontinuity_tag = false;\n    let mut has_version = false; // m3u8 files without ExtXVersion tags are ProtocolVersion::V1\n\n    for (i, line) in input.parse::\u003cLines\u003e()?.into_iter().enumerate() {\n        match line {\n            Line::Tag(tag) =\u003e {\n                if i == 0 {\n                    if tag != Tag::ExtM3u(ExtM3u) {\n                        return Err(Error::custom(\"m3u8 doesn't start with #EXTM3U\"));\n                    }\n                    continue;\n                }\n                match tag {\n                    Tag::ExtM3u(_) =\u003e return Err(Error::invalid_input()),\n                    Tag::ExtXVersion(t) =\u003e {\n                        builder.version(t.version());\n                        has_version = true;\n                    }\n                    Tag::ExtInf(t) =\u003e {\n                        has_partial_segment = true;\n                        segment.inf_tag(t);\n                    }\n                    Tag::ExtXByteRange(t) =\u003e {\n                        has_partial_segment = true;\n                        segment.byte_range_tag(t);\n                    }\n                    Tag::ExtXDiscontinuity(t) =\u003e {\n                        has_discontinuity_tag = true;\n                        has_partial_segment = true;\n                        segment.discontinuity_tag(t);\n                    }\n                    Tag::ExtXKey(t) =\u003e {\n                        has_partial_segment = true;\n                        segment.push_key_tag(t);\n                    }\n                    Tag::ExtXMap(t) =\u003e {\n                        has_partial_segment = true;\n                        segment.map_tag(t);\n                    }\n                    Tag::ExtXProgramDateTime(t) =\u003e {\n                        has_partial_segment = true;\n                        segment.program_date_time_tag(t);\n                    }\n                    Tag::ExtXDateRange(t) =\u003e {\n                        has_partial_segment = true;\n                        segment.date_range_tag(t);\n                    }\n                    Tag::ExtXTargetDuration(t) =\u003e {\n                        builder.target_duration_tag(t);\n                    }\n                    Tag::ExtXMediaSequence(t) =\u003e {\n                        builder.media_sequence_tag(t);\n                    }\n                    Tag::ExtXDiscontinuitySequence(t) =\u003e {\n                        if segments.is_empty() {\n                            return Err(Error::invalid_input());\n                        }\n                        if has_discontinuity_tag {\n                            return Err(Error::invalid_input());\n                        }\n                        builder.discontinuity_sequence_tag(t);\n                    }\n                    Tag::ExtXEndList(t) =\u003e {\n                        builder.end_list_tag(t);\n                    }\n                    Tag::ExtXPlaylistType(t) =\u003e {\n                        builder.playlist_type_tag(t);\n                    }\n                    Tag::ExtXIFramesOnly(t) =\u003e {\n                        builder.i_frames_only_tag(t);\n                    }\n                    Tag::ExtXMedia(_)\n                    | Tag::ExtXStreamInf(_)\n                    | Tag::ExtXIFrameStreamInf(_)\n                    | Tag::ExtXSessionData(_)\n                    | Tag::ExtXSessionKey(_) =\u003e {\n                        return Err(Error::custom(tag));\n                    }\n                    Tag::ExtXIndependentSegments(t) =\u003e {\n                        builder.independent_segments_tag(t);\n                    }\n                    Tag::ExtXStart(t) =\u003e {\n                        builder.start_tag(t);\n                    }\n                    Tag::Unknown(_) =\u003e {\n                        // [6.3.1. General Client Responsibilities]\n                        // \u003e ignore any unrecognized tags.\n                    }\n                }\n            }\n            Line::Uri(uri) =\u003e {\n                segment.uri(uri);\n                segments.push(segment.build().map_err(Error::builder_error)?);\n                segment = MediaSegment::builder();\n                has_partial_segment = false;\n            }\n        }\n    }\n    if has_partial_segment {\n        return Err(Error::invalid_input());\n    }\n    if !has_version {\n        builder.version(ProtocolVersion::V1);\n    }\n\n    builder.segments(segments);\n    builder.build().map_err(Error::builder_error)\n}\n\nimpl FromStr for MediaPlaylist {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        parse_media_playlist(input, \u0026mut Self::builder())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn too_large_segment_duration_test() {\n        let playlist = r#\"\n        #EXTM3U\n        #EXT-X-TARGETDURATION:8\n        #EXT-X-VERSION:3\n        #EXTINF:9.009,\n        http://media.example.com/first.ts\n        #EXTINF:9.509,\n        http://media.example.com/second.ts\n        #EXTINF:3.003,\n        http://media.example.com/third.ts\n        #EXT-X-ENDLIST\"#;\n\n        // Error (allowable segment duration = target duration = 8)\n        assert!(playlist.parse::\u003cMediaPlaylist\u003e().is_err());\n\n        // Error (allowable segment duration = 9)\n        assert!(MediaPlaylist::builder()\n            .allowable_excess_duration(Duration::from_secs(1))\n            .parse(playlist)\n            .is_err());\n\n        // Ok (allowable segment duration = 10)\n        MediaPlaylist::builder()\n            .allowable_excess_duration(Duration::from_secs(2))\n            .parse(playlist)\n            .unwrap();\n    }\n\n    #[test]\n    fn test_empty_playlist() {\n        let playlist = \"\";\n        assert!(playlist.parse::\u003cMediaPlaylist\u003e().is_err());\n    }\n}\n","traces":[{"line":69,"address":4316000,"length":1,"stats":{"Line":3}},{"line":70,"address":4316015,"length":1,"stats":{"Line":3}},{"line":71,"address":4316059,"length":1,"stats":{"Line":3}},{"line":72,"address":null,"length":0,"stats":{"Line":0}},{"line":73,"address":4281344,"length":1,"stats":{"Line":3}},{"line":74,"address":null,"length":0,"stats":{"Line":0}},{"line":76,"address":4316112,"length":1,"stats":{"Line":3}},{"line":77,"address":4316211,"length":1,"stats":{"Line":0}},{"line":78,"address":4316185,"length":1,"stats":{"Line":0}},{"line":79,"address":null,"length":0,"stats":{"Line":0}},{"line":81,"address":4316477,"length":1,"stats":{"Line":0}},{"line":84,"address":4316142,"length":1,"stats":{"Line":3}},{"line":85,"address":4316570,"length":1,"stats":{"Line":3}},{"line":86,"address":4281392,"length":1,"stats":{"Line":4}},{"line":89,"address":4316908,"length":1,"stats":{"Line":3}},{"line":92,"address":4317008,"length":1,"stats":{"Line":3}},{"line":93,"address":4317048,"length":1,"stats":{"Line":3}},{"line":94,"address":4317060,"length":1,"stats":{"Line":3}},{"line":95,"address":4317162,"length":1,"stats":{"Line":3}},{"line":97,"address":4317326,"length":1,"stats":{"Line":3}},{"line":98,"address":4317380,"length":1,"stats":{"Line":3}},{"line":99,"address":4317434,"length":1,"stats":{"Line":3}},{"line":101,"address":4317414,"length":1,"stats":{"Line":1}},{"line":104,"address":null,"length":0,"stats":{"Line":0}},{"line":105,"address":4317534,"length":1,"stats":{"Line":3}},{"line":106,"address":4317622,"length":1,"stats":{"Line":1}},{"line":108,"address":4317570,"length":1,"stats":{"Line":3}},{"line":112,"address":4317677,"length":1,"stats":{"Line":3}},{"line":113,"address":4317851,"length":1,"stats":{"Line":1}},{"line":114,"address":4317787,"length":1,"stats":{"Line":1}},{"line":115,"address":null,"length":0,"stats":{"Line":0}},{"line":116,"address":null,"length":0,"stats":{"Line":0}},{"line":117,"address":null,"length":0,"stats":{"Line":0}},{"line":118,"address":4317739,"length":1,"stats":{"Line":1}},{"line":123,"address":4317712,"length":1,"stats":{"Line":3}},{"line":124,"address":4318364,"length":1,"stats":{"Line":0}},{"line":125,"address":4318471,"length":1,"stats":{"Line":0}},{"line":126,"address":4318907,"length":1,"stats":{"Line":0}},{"line":127,"address":4318967,"length":1,"stats":{"Line":0}},{"line":130,"address":4318447,"length":1,"stats":{"Line":0}},{"line":133,"address":4318299,"length":1,"stats":{"Line":3}},{"line":137,"address":4319045,"length":1,"stats":{"Line":3}},{"line":140,"address":4319136,"length":1,"stats":{"Line":3}},{"line":141,"address":4319151,"length":1,"stats":{"Line":3}},{"line":203,"address":null,"length":0,"stats":{"Line":0}},{"line":207,"address":null,"length":0,"stats":{"Line":0}},{"line":208,"address":null,"length":0,"stats":{"Line":0}},{"line":209,"address":null,"length":0,"stats":{"Line":0}},{"line":211,"address":null,"length":0,"stats":{"Line":0}},{"line":213,"address":null,"length":0,"stats":{"Line":0}},{"line":217,"address":4319872,"length":1,"stats":{"Line":1}},{"line":218,"address":4319894,"length":1,"stats":{"Line":1}},{"line":224,"address":4319936,"length":1,"stats":{"Line":3}},{"line":228,"address":4319968,"length":1,"stats":{"Line":0}},{"line":229,"address":4319973,"length":1,"stats":{"Line":0}},{"line":233,"address":4319984,"length":1,"stats":{"Line":1}},{"line":234,"address":4319989,"length":1,"stats":{"Line":1}},{"line":238,"address":4320016,"length":1,"stats":{"Line":0}},{"line":239,"address":4320021,"length":1,"stats":{"Line":0}},{"line":243,"address":4320048,"length":1,"stats":{"Line":0}},{"line":244,"address":4320053,"length":1,"stats":{"Line":0}},{"line":248,"address":4320080,"length":1,"stats":{"Line":0}},{"line":249,"address":4320085,"length":1,"stats":{"Line":0}},{"line":253,"address":4320096,"length":1,"stats":{"Line":0}},{"line":254,"address":4320101,"length":1,"stats":{"Line":0}},{"line":258,"address":4320128,"length":1,"stats":{"Line":0}},{"line":259,"address":4320133,"length":1,"stats":{"Line":0}},{"line":263,"address":4320160,"length":1,"stats":{"Line":0}},{"line":264,"address":4320165,"length":1,"stats":{"Line":0}},{"line":268,"address":4320192,"length":1,"stats":{"Line":0}},{"line":269,"address":4320197,"length":1,"stats":{"Line":0}},{"line":273,"address":4320224,"length":1,"stats":{"Line":1}},{"line":274,"address":4320233,"length":1,"stats":{"Line":1}},{"line":279,"address":4320288,"length":1,"stats":{"Line":0}},{"line":280,"address":4320318,"length":1,"stats":{"Line":0}},{"line":281,"address":4320617,"length":1,"stats":{"Line":0}},{"line":282,"address":4320693,"length":1,"stats":{"Line":0}},{"line":284,"address":4320988,"length":1,"stats":{"Line":0}},{"line":285,"address":4321268,"length":1,"stats":{"Line":0}},{"line":286,"address":4321337,"length":1,"stats":{"Line":0}},{"line":288,"address":4321619,"length":1,"stats":{"Line":0}},{"line":289,"address":4321688,"length":1,"stats":{"Line":0}},{"line":291,"address":4321974,"length":1,"stats":{"Line":0}},{"line":292,"address":4322058,"length":1,"stats":{"Line":0}},{"line":294,"address":4322340,"length":1,"stats":{"Line":0}},{"line":295,"address":4322419,"length":1,"stats":{"Line":0}},{"line":297,"address":4322701,"length":1,"stats":{"Line":0}},{"line":298,"address":4322780,"length":1,"stats":{"Line":0}},{"line":300,"address":4323066,"length":1,"stats":{"Line":0}},{"line":301,"address":4323151,"length":1,"stats":{"Line":0}},{"line":303,"address":4323409,"length":1,"stats":{"Line":0}},{"line":304,"address":4323627,"length":1,"stats":{"Line":0}},{"line":306,"address":4323515,"length":1,"stats":{"Line":0}},{"line":307,"address":4323911,"length":1,"stats":{"Line":0}},{"line":309,"address":4324163,"length":1,"stats":{"Line":0}},{"line":313,"address":4324176,"length":1,"stats":{"Line":3}},{"line":317,"address":4324216,"length":1,"stats":{"Line":3}},{"line":318,"address":4324419,"length":1,"stats":{"Line":3}},{"line":320,"address":4324489,"length":1,"stats":{"Line":3}},{"line":321,"address":4324497,"length":1,"stats":{"Line":3}},{"line":322,"address":4324505,"length":1,"stats":{"Line":3}},{"line":324,"address":4324513,"length":1,"stats":{"Line":3}},{"line":325,"address":4325514,"length":1,"stats":{"Line":0}},{"line":326,"address":4325516,"length":1,"stats":{"Line":3}},{"line":327,"address":4325634,"length":1,"stats":{"Line":3}},{"line":328,"address":4325687,"length":1,"stats":{"Line":3}},{"line":329,"address":4325843,"length":1,"stats":{"Line":0}},{"line":331,"address":4330194,"length":1,"stats":{"Line":3}},{"line":333,"address":4326074,"length":1,"stats":{"Line":0}},{"line":334,"address":4325645,"length":1,"stats":{"Line":3}},{"line":335,"address":4326149,"length":1,"stats":{"Line":2}},{"line":336,"address":4326163,"length":1,"stats":{"Line":2}},{"line":337,"address":4326236,"length":1,"stats":{"Line":2}},{"line":339,"address":4326249,"length":1,"stats":{"Line":3}},{"line":340,"address":4326305,"length":1,"stats":{"Line":3}},{"line":341,"address":4326313,"length":1,"stats":{"Line":3}},{"line":343,"address":4326393,"length":1,"stats":{"Line":0}},{"line":344,"address":4326425,"length":1,"stats":{"Line":0}},{"line":345,"address":4326433,"length":1,"stats":{"Line":0}},{"line":348,"address":4326497,"length":1,"stats":{"Line":0}},{"line":349,"address":4326505,"length":1,"stats":{"Line":0}},{"line":350,"address":4326513,"length":1,"stats":{"Line":0}},{"line":352,"address":4326537,"length":1,"stats":{"Line":0}},{"line":353,"address":4326625,"length":1,"stats":{"Line":0}},{"line":354,"address":4326633,"length":1,"stats":{"Line":0}},{"line":356,"address":4326745,"length":1,"stats":{"Line":0}},{"line":357,"address":4326801,"length":1,"stats":{"Line":0}},{"line":358,"address":4326809,"length":1,"stats":{"Line":0}},{"line":360,"address":4326889,"length":1,"stats":{"Line":0}},{"line":361,"address":4326905,"length":1,"stats":{"Line":0}},{"line":362,"address":4326913,"length":1,"stats":{"Line":0}},{"line":364,"address":4326961,"length":1,"stats":{"Line":0}},{"line":365,"address":4327038,"length":1,"stats":{"Line":0}},{"line":366,"address":4327054,"length":1,"stats":{"Line":0}},{"line":368,"address":4327128,"length":1,"stats":{"Line":3}},{"line":369,"address":4327158,"length":1,"stats":{"Line":3}},{"line":371,"address":4327197,"length":1,"stats":{"Line":0}},{"line":372,"address":4327213,"length":1,"stats":{"Line":0}},{"line":374,"address":4327245,"length":1,"stats":{"Line":0}},{"line":375,"address":4327261,"length":1,"stats":{"Line":0}},{"line":376,"address":4327314,"length":1,"stats":{"Line":0}},{"line":378,"address":4327294,"length":1,"stats":{"Line":0}},{"line":379,"address":4327414,"length":1,"stats":{"Line":0}},{"line":381,"address":4327379,"length":1,"stats":{"Line":0}},{"line":384,"address":4327481,"length":1,"stats":{"Line":3}},{"line":386,"address":4327505,"length":1,"stats":{"Line":0}},{"line":387,"address":4327519,"length":1,"stats":{"Line":0}},{"line":390,"address":4327551,"length":1,"stats":{"Line":0}},{"line":397,"address":4327575,"length":1,"stats":{"Line":0}},{"line":400,"address":4327768,"length":1,"stats":{"Line":0}},{"line":402,"address":4327792,"length":1,"stats":{"Line":0}},{"line":403,"address":4327824,"length":1,"stats":{"Line":0}},{"line":411,"address":4325749,"length":1,"stats":{"Line":3}},{"line":412,"address":4327905,"length":1,"stats":{"Line":3}},{"line":413,"address":4327964,"length":1,"stats":{"Line":3}},{"line":414,"address":4328563,"length":1,"stats":{"Line":3}},{"line":415,"address":4330849,"length":1,"stats":{"Line":3}},{"line":419,"address":4330997,"length":1,"stats":{"Line":3}},{"line":420,"address":4328648,"length":1,"stats":{"Line":0}},{"line":422,"address":4328625,"length":1,"stats":{"Line":3}},{"line":423,"address":4328713,"length":1,"stats":{"Line":2}},{"line":426,"address":4328750,"length":1,"stats":{"Line":3}},{"line":427,"address":4328817,"length":1,"stats":{"Line":3}},{"line":433,"address":4331248,"length":1,"stats":{"Line":3}},{"line":434,"address":4331268,"length":1,"stats":{"Line":3}},{"line":443,"address":4794736,"length":1,"stats":{"Line":2}},{"line":444,"address":4794750,"length":1,"stats":{"Line":1}},{"line":457,"address":4794764,"length":1,"stats":{"Line":1}},{"line":460,"address":4794861,"length":1,"stats":{"Line":1}},{"line":461,"address":4794911,"length":1,"stats":{"Line":1}},{"line":462,"address":4794974,"length":1,"stats":{"Line":1}},{"line":466,"address":4795086,"length":1,"stats":{"Line":1}},{"line":473,"address":4795376,"length":1,"stats":{"Line":2}},{"line":474,"address":4795383,"length":1,"stats":{"Line":1}},{"line":475,"address":4795404,"length":1,"stats":{"Line":1}}],"covered":79,"coverable":175},{"path":["/","media","hdd","home","projects","hls_m3u8","src","media_segment.rs"],"content":"use std::fmt;\nuse std::iter;\n\nuse derive_builder::Builder;\n\nuse crate::tags::{\n    ExtInf, ExtXByteRange, ExtXDateRange, ExtXDiscontinuity, ExtXKey, ExtXMap, ExtXProgramDateTime,\n};\nuse crate::types::{ProtocolVersion, RequiredVersion};\n\n/// Media segment.\n#[derive(Debug, Clone, Builder)]\n#[builder(setter(into, strip_option))]\npub struct MediaSegment {\n    #[builder(default)]\n    /// Sets all [ExtXKey] tags.\n    key_tags: Vec\u003cExtXKey\u003e,\n    #[builder(default)]\n    /// Sets an [ExtXMap] tag.\n    map_tag: Option\u003cExtXMap\u003e,\n    #[builder(default)]\n    /// Sets an [ExtXByteRange] tag.\n    byte_range_tag: Option\u003cExtXByteRange\u003e,\n    #[builder(default)]\n    /// Sets an [ExtXDateRange] tag.\n    date_range_tag: Option\u003cExtXDateRange\u003e,\n    #[builder(default)]\n    /// Sets an [ExtXDiscontinuity] tag.\n    discontinuity_tag: Option\u003cExtXDiscontinuity\u003e,\n    #[builder(default)]\n    /// Sets an [ExtXProgramDateTime] tag.\n    program_date_time_tag: Option\u003cExtXProgramDateTime\u003e,\n    /// Sets an [ExtInf] tag.\n    inf_tag: ExtInf,\n    /// Sets an Uri.\n    uri: String,\n}\n\nimpl MediaSegmentBuilder {\n    /// Pushes an [ExtXKey] tag.\n    pub fn push_key_tag\u003cVALUE: Into\u003cExtXKey\u003e\u003e(\u0026mut self, value: VALUE) -\u003e \u0026mut Self {\n        if let Some(key_tags) = \u0026mut self.key_tags {\n            key_tags.push(value.into());\n        } else {\n            self.key_tags = Some(vec![value.into()]);\n        }\n        self\n    }\n}\n\nimpl fmt::Display for MediaSegment {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        for value in \u0026self.key_tags {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.map_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.byte_range_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.date_range_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.discontinuity_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        if let Some(value) = \u0026self.program_date_time_tag {\n            writeln!(f, \"{}\", value)?;\n        }\n        writeln!(f, \"{},\", self.inf_tag)?;\n        writeln!(f, \"{}\", self.uri)?;\n        Ok(())\n    }\n}\n\nimpl MediaSegment {\n    /// Creates a [MediaSegmentBuilder].\n    pub fn builder() -\u003e MediaSegmentBuilder {\n        MediaSegmentBuilder::default()\n    }\n    /// Returns the URI of the media segment.\n    pub const fn uri(\u0026self) -\u003e \u0026String {\n        \u0026self.uri\n    }\n\n    /// Returns the `EXT-X-INF` tag associated with the media segment.\n    pub const fn inf_tag(\u0026self) -\u003e \u0026ExtInf {\n        \u0026self.inf_tag\n    }\n\n    /// Returns the `EXT-X-BYTERANGE` tag associated with the media segment.\n    pub const fn byte_range_tag(\u0026self) -\u003e Option\u003cExtXByteRange\u003e {\n        self.byte_range_tag\n    }\n\n    /// Returns the `EXT-X-DATERANGE` tag associated with the media segment.\n    pub fn date_range_tag(\u0026self) -\u003e Option\u003c\u0026ExtXDateRange\u003e {\n        self.date_range_tag.as_ref()\n    }\n\n    /// Returns the `EXT-X-DISCONTINUITY` tag associated with the media segment.\n    pub const fn discontinuity_tag(\u0026self) -\u003e Option\u003cExtXDiscontinuity\u003e {\n        self.discontinuity_tag\n    }\n\n    /// Returns the `EXT-X-PROGRAM-DATE-TIME` tag associated with the media segment.\n    pub fn program_date_time_tag(\u0026self) -\u003e Option\u003c\u0026ExtXProgramDateTime\u003e {\n        self.program_date_time_tag.as_ref()\n    }\n\n    /// Returns the `EXT-X-MAP` tag associated with the media segment.\n    pub fn map_tag(\u0026self) -\u003e Option\u003c\u0026ExtXMap\u003e {\n        self.map_tag.as_ref()\n    }\n\n    /// Returns the `EXT-X-KEY` tags associated with the media segment.\n    pub fn key_tags(\u0026self) -\u003e \u0026[ExtXKey] {\n        \u0026self.key_tags\n    }\n}\n\nimpl RequiredVersion for MediaSegment {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        iter::empty()\n            .chain(self.key_tags.iter().map(|t| t.required_version()))\n            .chain(self.map_tag.iter().map(|t| t.required_version()))\n            .chain(self.byte_range_tag.iter().map(|t| t.required_version()))\n            .chain(self.date_range_tag.iter().map(|t| t.required_version()))\n            .chain(self.discontinuity_tag.iter().map(|t| t.required_version()))\n            .chain(\n                self.program_date_time_tag\n                    .iter()\n                    .map(|t| t.required_version()),\n            )\n            .chain(iter::once(self.inf_tag.required_version()))\n            .max()\n            .unwrap_or(ProtocolVersion::V7)\n    }\n}\n","traces":[{"line":41,"address":4341392,"length":1,"stats":{"Line":0}},{"line":42,"address":4341408,"length":1,"stats":{"Line":0}},{"line":43,"address":4341592,"length":1,"stats":{"Line":0}},{"line":45,"address":4341478,"length":1,"stats":{"Line":0}},{"line":47,"address":4341778,"length":1,"stats":{"Line":0}},{"line":52,"address":4297248,"length":1,"stats":{"Line":0}},{"line":53,"address":4297271,"length":1,"stats":{"Line":0}},{"line":54,"address":4297514,"length":1,"stats":{"Line":0}},{"line":56,"address":4297387,"length":1,"stats":{"Line":0}},{"line":57,"address":4297841,"length":1,"stats":{"Line":0}},{"line":59,"address":4298127,"length":1,"stats":{"Line":0}},{"line":60,"address":4298215,"length":1,"stats":{"Line":0}},{"line":62,"address":4298501,"length":1,"stats":{"Line":0}},{"line":63,"address":4298589,"length":1,"stats":{"Line":0}},{"line":65,"address":4298871,"length":1,"stats":{"Line":0}},{"line":66,"address":4298950,"length":1,"stats":{"Line":0}},{"line":68,"address":4299232,"length":1,"stats":{"Line":0}},{"line":69,"address":4299305,"length":1,"stats":{"Line":0}},{"line":71,"address":4299564,"length":1,"stats":{"Line":0}},{"line":72,"address":4299820,"length":1,"stats":{"Line":0}},{"line":73,"address":4300083,"length":1,"stats":{"Line":0}},{"line":79,"address":4300096,"length":1,"stats":{"Line":3}},{"line":83,"address":4300128,"length":1,"stats":{"Line":2}},{"line":84,"address":4300133,"length":1,"stats":{"Line":2}},{"line":88,"address":4300160,"length":1,"stats":{"Line":3}},{"line":89,"address":4300165,"length":1,"stats":{"Line":3}},{"line":93,"address":4300192,"length":1,"stats":{"Line":3}},{"line":94,"address":4300200,"length":1,"stats":{"Line":3}},{"line":98,"address":4300240,"length":1,"stats":{"Line":0}},{"line":99,"address":4300249,"length":1,"stats":{"Line":0}},{"line":103,"address":4300288,"length":1,"stats":{"Line":0}},{"line":104,"address":4300293,"length":1,"stats":{"Line":0}},{"line":108,"address":4300320,"length":1,"stats":{"Line":0}},{"line":109,"address":4300329,"length":1,"stats":{"Line":0}},{"line":113,"address":4300368,"length":1,"stats":{"Line":0}},{"line":114,"address":4300377,"length":1,"stats":{"Line":0}},{"line":118,"address":4300416,"length":1,"stats":{"Line":0}},{"line":119,"address":4300425,"length":1,"stats":{"Line":0}},{"line":124,"address":4300464,"length":1,"stats":{"Line":3}},{"line":125,"address":4300479,"length":1,"stats":{"Line":3}},{"line":138,"address":4301046,"length":1,"stats":{"Line":3}}],"covered":10,"coverable":41},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","basic","m3u.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.3.1.1. EXTM3U]\n/// The [ExtM3u] tag indicates that the file is an Extended [M3U]\n/// Playlist file.\n///\n/// Its format is:\n/// ```text\n/// #EXTM3U\n/// ```\n///\n/// [M3U]: https://en.wikipedia.org/wiki/M3U\n/// [4.3.1.1. EXTM3U]: https://tools.ietf.org/html/rfc8216#section-4.3.1.1\n#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]\npub struct ExtM3u;\n\nimpl ExtM3u {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXTM3U\";\n}\n\nimpl RequiredVersion for ExtM3u {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtM3u {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Self::PREFIX.fmt(f)\n    }\n}\n\nimpl FromStr for ExtM3u {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        tag(input, Self::PREFIX)?;\n        Ok(ExtM3u)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(ExtM3u.to_string(), \"#EXTM3U\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\"#EXTM3U\".parse::\u003cExtM3u\u003e().ok(), Some(ExtM3u));\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(ExtM3u.required_version(), ProtocolVersion::V1);\n    }\n}\n","traces":[{"line":27,"address":4517632,"length":1,"stats":{"Line":1}},{"line":28,"address":4517640,"length":1,"stats":{"Line":1}},{"line":33,"address":4517664,"length":1,"stats":{"Line":1}},{"line":34,"address":4517685,"length":1,"stats":{"Line":1}},{"line":41,"address":4517728,"length":1,"stats":{"Line":3}},{"line":42,"address":4517755,"length":1,"stats":{"Line":3}},{"line":43,"address":4518186,"length":1,"stats":{"Line":3}},{"line":52,"address":5000240,"length":1,"stats":{"Line":2}},{"line":53,"address":5000247,"length":1,"stats":{"Line":1}},{"line":57,"address":5000784,"length":1,"stats":{"Line":2}},{"line":58,"address":5000798,"length":1,"stats":{"Line":1}},{"line":62,"address":5001216,"length":1,"stats":{"Line":2}},{"line":63,"address":5001223,"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","basic","version.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.3.1.2. EXT-X-VERSION]\n/// The [ExtXVersion] tag indicates the compatibility version of the\n/// Playlist file, its associated media, and its server.\n///\n/// The [ExtXVersion] tag applies to the entire Playlist file. Its\n/// format is:\n///\n/// ```text\n/// #EXT-X-VERSION:\u003cn\u003e\n/// ```\n/// where `n` is an integer indicating the protocol compatibility version\n/// number.\n///\n/// [4.3.1.2. EXT-X-VERSION]: https://tools.ietf.org/html/rfc8216#section-4.3.1.2\n#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]\npub struct ExtXVersion(ProtocolVersion);\n\nimpl ExtXVersion {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-VERSION:\";\n\n    /// Makes a new [ExtXVersion] tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXVersion;\n    /// use hls_m3u8::types::ProtocolVersion;\n    ///\n    /// let version_tag = ExtXVersion::new(ProtocolVersion::V2);\n    /// ```\n    pub const fn new(version: ProtocolVersion) -\u003e Self {\n        Self(version)\n    }\n\n    /// Returns the protocol compatibility version of the playlist, containing this tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXVersion;\n    /// use hls_m3u8::types::ProtocolVersion;\n    ///\n    /// assert_eq!(\n    ///     ExtXVersion::new(ProtocolVersion::V6).version(),\n    ///     ProtocolVersion::V6\n    /// );\n    /// ```\n    pub const fn version(self) -\u003e ProtocolVersion {\n        self.0\n    }\n}\n\nimpl RequiredVersion for ExtXVersion {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXVersion {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", Self::PREFIX, self.0)\n    }\n}\n\nimpl Default for ExtXVersion {\n    fn default() -\u003e Self {\n        Self(ProtocolVersion::V1)\n    }\n}\n\nimpl From\u003cProtocolVersion\u003e for ExtXVersion {\n    fn from(value: ProtocolVersion) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl FromStr for ExtXVersion {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let version = tag(input, Self::PREFIX)?.parse()?;\n        Ok(ExtXVersion::new(version))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXVersion::new(ProtocolVersion::V6).to_string(),\n            \"#EXT-X-VERSION:6\"\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            \"#EXT-X-VERSION:6\".parse::\u003cExtXVersion\u003e().unwrap(),\n            ExtXVersion::new(ProtocolVersion::V6)\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXVersion::new(ProtocolVersion::V6).required_version(),\n            ProtocolVersion::V1\n        );\n    }\n}\n","traces":[{"line":37,"address":4211824,"length":1,"stats":{"Line":4}},{"line":38,"address":4211832,"length":1,"stats":{"Line":4}},{"line":53,"address":4211856,"length":1,"stats":{"Line":4}},{"line":54,"address":4211864,"length":1,"stats":{"Line":4}},{"line":59,"address":4211872,"length":1,"stats":{"Line":1}},{"line":60,"address":4211880,"length":1,"stats":{"Line":1}},{"line":65,"address":4211904,"length":1,"stats":{"Line":1}},{"line":66,"address":4211935,"length":1,"stats":{"Line":1}},{"line":71,"address":4212192,"length":1,"stats":{"Line":1}},{"line":72,"address":4212196,"length":1,"stats":{"Line":1}},{"line":77,"address":4212224,"length":1,"stats":{"Line":3}},{"line":78,"address":4212232,"length":1,"stats":{"Line":3}},{"line":85,"address":4212256,"length":1,"stats":{"Line":2}},{"line":86,"address":4212283,"length":1,"stats":{"Line":2}},{"line":87,"address":4213247,"length":1,"stats":{"Line":2}},{"line":96,"address":4675792,"length":1,"stats":{"Line":2}},{"line":97,"address":5247247,"length":1,"stats":{"Line":1}},{"line":98,"address":5247191,"length":1,"stats":{"Line":1}},{"line":104,"address":4675824,"length":1,"stats":{"Line":2}},{"line":105,"address":5247738,"length":1,"stats":{"Line":1}},{"line":106,"address":5247678,"length":1,"stats":{"Line":1}},{"line":107,"address":5247710,"length":1,"stats":{"Line":1}},{"line":112,"address":4675856,"length":1,"stats":{"Line":2}},{"line":113,"address":5248152,"length":1,"stats":{"Line":1}},{"line":114,"address":5248119,"length":1,"stats":{"Line":1}}],"covered":25,"coverable":25},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","master_playlist","i_frame_stream_inf.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{ProtocolVersion, RequiredVersion, StreamInf};\nuse crate::utils::{quote, tag, unquote};\nuse crate::Error;\n\n/// # [4.3.4.3. EXT-X-I-FRAME-STREAM-INF]\n/// The [ExtXIFrameStreamInf] tag identifies a [Media Playlist] file\n/// containing the I-frames of a multimedia presentation. It stands\n/// alone, in that it does not apply to a particular `URI` in the [Master Playlist].\n///\n/// Its format is:\n///\n/// ```text\n/// #EXT-X-I-FRAME-STREAM-INF:\u003cattribute-list\u003e\n/// ```\n///\n/// [Master Playlist]: crate::MasterPlaylist\n/// [Media Playlist]: crate::MediaPlaylist\n/// [4.3.4.3. EXT-X-I-FRAME-STREAM-INF]: https://tools.ietf.org/html/rfc8216#section-4.3.4.3\n#[derive(PartialOrd, Debug, Clone, PartialEq, Eq, Hash)]\npub struct ExtXIFrameStreamInf {\n    uri: String,\n    stream_inf: StreamInf,\n}\n\nimpl ExtXIFrameStreamInf {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-I-FRAME-STREAM-INF:\";\n\n    /// Makes a new [ExtXIFrameStreamInf] tag.\n    pub fn new\u003cT: ToString\u003e(uri: T, bandwidth: u64) -\u003e Self {\n        ExtXIFrameStreamInf {\n            uri: uri.to_string(),\n            stream_inf: StreamInf::new(bandwidth),\n        }\n    }\n\n    /// Returns the `URI`, that identifies the associated media playlist.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXIFrameStreamInf;\n    /// #\n    /// let stream = ExtXIFrameStreamInf::new(\"https://www.example.com\", 20);\n    /// assert_eq!(stream.uri(), \u0026\"https://www.example.com\".to_string());\n    /// ```\n    pub const fn uri(\u0026self) -\u003e \u0026String {\n        \u0026self.uri\n    }\n\n    /// Sets the `URI`, that identifies the associated media playlist.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXIFrameStreamInf;\n    /// #\n    /// let mut stream = ExtXIFrameStreamInf::new(\"https://www.example.com\", 20);\n    ///\n    /// stream.set_uri(\"../new/uri\");\n    /// assert_eq!(stream.uri(), \u0026\"../new/uri\".to_string());\n    /// ```\n    pub fn set_uri\u003cT: ToString\u003e(\u0026mut self, value: T) -\u003e \u0026mut Self {\n        self.uri = value.to_string();\n        self\n    }\n}\n\nimpl RequiredVersion for ExtXIFrameStreamInf {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXIFrameStreamInf {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n        write!(f, \"URI={},{}\", quote(\u0026self.uri), self.stream_inf)?;\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXIFrameStreamInf {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let mut uri = None;\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            if let \"URI\" = key.as_str() {\n                uri = Some(unquote(value));\n            }\n        }\n\n        let uri = uri.ok_or_else(|| Error::missing_value(\"URI\"))?;\n\n        Ok(Self {\n            uri,\n            stream_inf: input.parse()?,\n        })\n    }\n}\n\nimpl Deref for ExtXIFrameStreamInf {\n    type Target = StreamInf;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.stream_inf\n    }\n}\n\nimpl DerefMut for ExtXIFrameStreamInf {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.stream_inf\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXIFrameStreamInf::new(\"foo\", 1000).to_string(),\n            \"#EXT-X-I-FRAME-STREAM-INF:URI=\\\"foo\\\",BANDWIDTH=1000\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            \"#EXT-X-I-FRAME-STREAM-INF:URI=\\\"foo\\\",BANDWIDTH=1000\"\n                .parse::\u003cExtXIFrameStreamInf\u003e()\n                .unwrap(),\n            ExtXIFrameStreamInf::new(\"foo\", 1000)\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXIFrameStreamInf::new(\"foo\", 1000).required_version(),\n            ProtocolVersion::V1\n        );\n    }\n}\n","traces":[{"line":34,"address":null,"length":0,"stats":{"Line":3}},{"line":36,"address":null,"length":0,"stats":{"Line":3}},{"line":37,"address":null,"length":0,"stats":{"Line":3}},{"line":50,"address":4302912,"length":1,"stats":{"Line":2}},{"line":51,"address":4302917,"length":1,"stats":{"Line":2}},{"line":65,"address":null,"length":0,"stats":{"Line":1}},{"line":66,"address":null,"length":0,"stats":{"Line":1}},{"line":67,"address":null,"length":0,"stats":{"Line":1}},{"line":72,"address":4302928,"length":1,"stats":{"Line":1}},{"line":73,"address":4302936,"length":1,"stats":{"Line":1}},{"line":78,"address":4302960,"length":1,"stats":{"Line":1}},{"line":79,"address":4302991,"length":1,"stats":{"Line":1}},{"line":80,"address":4303269,"length":1,"stats":{"Line":1}},{"line":81,"address":4303731,"length":1,"stats":{"Line":1}},{"line":88,"address":4303776,"length":1,"stats":{"Line":1}},{"line":89,"address":4303803,"length":1,"stats":{"Line":1}},{"line":91,"address":4304367,"length":1,"stats":{"Line":1}},{"line":93,"address":4304387,"length":1,"stats":{"Line":1}},{"line":94,"address":4305322,"length":1,"stats":{"Line":1}},{"line":95,"address":4305401,"length":1,"stats":{"Line":1}},{"line":99,"address":4305634,"length":1,"stats":{"Line":1}},{"line":101,"address":4306633,"length":1,"stats":{"Line":1}},{"line":102,"address":4307655,"length":1,"stats":{"Line":1}},{"line":103,"address":4306115,"length":1,"stats":{"Line":1}},{"line":111,"address":4308096,"length":1,"stats":{"Line":0}},{"line":112,"address":4308101,"length":1,"stats":{"Line":0}},{"line":117,"address":4308128,"length":1,"stats":{"Line":0}},{"line":118,"address":4308133,"length":1,"stats":{"Line":0}},{"line":127,"address":4672688,"length":1,"stats":{"Line":2}},{"line":128,"address":4672786,"length":1,"stats":{"Line":0}},{"line":129,"address":4672702,"length":1,"stats":{"Line":1}},{"line":130,"address":4672759,"length":1,"stats":{"Line":1}},{"line":135,"address":4673328,"length":1,"stats":{"Line":2}},{"line":136,"address":4673430,"length":1,"stats":{"Line":0}},{"line":140,"address":4673398,"length":1,"stats":{"Line":1}},{"line":145,"address":4673936,"length":1,"stats":{"Line":2}},{"line":146,"address":4674019,"length":1,"stats":{"Line":1}},{"line":147,"address":4673950,"length":1,"stats":{"Line":1}}],"covered":32,"coverable":38},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","master_playlist","media.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse derive_builder::Builder;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{InStreamId, MediaType, ProtocolVersion, RequiredVersion};\nuse crate::utils::{parse_yes_or_no, quote, tag, unquote};\nuse crate::Error;\n\n/// # [4.4.4.1. EXT-X-MEDIA]\n/// The [ExtXMedia] tag is used to relate [Media Playlist]s that contain\n/// alternative Renditions of the same content. For\n/// example, three [ExtXMedia] tags can be used to identify audio-only\n/// [Media Playlist]s, that contain English, French, and Spanish Renditions\n/// of the same presentation. Or, two [ExtXMedia] tags can be used to\n/// identify video-only [Media Playlist]s that show two different camera\n/// angles.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-MEDIA:\u003cattribute-list\u003e\n/// ```\n///\n/// [Media Playlist]: crate::MediaPlaylist\n/// [4.4.4.1. EXT-X-MEDIA]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.4.1\n#[derive(Builder, Debug, Clone, PartialEq, Eq, Hash)]\n#[builder(setter(into))]\n#[builder(build_fn(validate = \"Self::validate\"))]\npub struct ExtXMedia {\n    /// Sets the media type of the rendition.\n    media_type: MediaType,\n    #[builder(setter(strip_option, into), default)]\n    /// Sets the URI that identifies the media playlist.\n    uri: Option\u003cString\u003e,\n    /// Sets the identifier that specifies the group to which the rendition belongs.\n    group_id: String,\n    /// Sets the name of the primary language used in the rendition.\n    #[builder(setter(strip_option, into), default)]\n    language: Option\u003cString\u003e,\n    /// Sets the name of a language associated with the rendition.\n    #[builder(setter(strip_option, into), default)]\n    assoc_language: Option\u003cString\u003e,\n    /// Sets a human-readable description of the rendition.\n    name: String,\n    /// Sets the value of the `default` flag.\n    #[builder(default)]\n    is_default: bool,\n    /// Sets the value of the `autoselect` flag.\n    #[builder(default)]\n    is_autoselect: bool,\n    /// Sets the value of the `forced` flag.\n    #[builder(default)]\n    is_forced: bool,\n    /// Sets the identifier that specifies a rendition within the segments in the media playlist.\n    #[builder(setter(strip_option, into), default)]\n    instream_id: Option\u003cInStreamId\u003e,\n    /// Sets the string that represents uniform type identifiers (UTI).\n    #[builder(setter(strip_option, into), default)]\n    characteristics: Option\u003cString\u003e,\n    /// Sets the string that represents the parameters of the rendition.\n    #[builder(setter(strip_option, into), default)]\n    channels: Option\u003cString\u003e,\n}\n\nimpl ExtXMediaBuilder {\n    fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n        let media_type = self\n            .media_type\n            .ok_or_else(|| Error::missing_attribute(\"MEDIA-TYPE\").to_string())?;\n\n        if MediaType::ClosedCaptions == media_type {\n            if self.uri.is_some() {\n                return Err(Error::custom(\n                    \"Unexpected attribute: \\\"URL\\\" for MediaType::ClosedCaptions!\",\n                )\n                .to_string());\n            }\n            self.instream_id\n                .ok_or_else(|| Error::missing_attribute(\"INSTREAM-ID\").to_string())?;\n        } else if self.instream_id.is_some() {\n            return Err(Error::custom(\"Unexpected attribute: \\\"INSTREAM-ID\\\"!\").to_string());\n        }\n\n        if self.is_default.unwrap_or(false) \u0026\u0026 !self.is_autoselect.unwrap_or(false) {\n            return Err(\n                Error::custom(\"If `DEFAULT` is true, `AUTOSELECT` has to be true too!\").to_string(),\n            );\n        }\n\n        if MediaType::Subtitles != media_type \u0026\u0026 self.is_forced.is_some() {\n            return Err(Error::invalid_input().to_string());\n        }\n\n        Ok(())\n    }\n}\n\nimpl ExtXMedia {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-MEDIA:\";\n\n    /// Makes a new [ExtXMedia] tag.\n    pub fn new\u003cT: ToString\u003e(media_type: MediaType, group_id: T, name: T) -\u003e Self {\n        Self {\n            media_type,\n            uri: None,\n            group_id: group_id.to_string(),\n            language: None,\n            assoc_language: None,\n            name: name.to_string(),\n            is_default: false,\n            is_autoselect: false,\n            is_forced: false,\n            instream_id: None,\n            characteristics: None,\n            channels: None,\n        }\n    }\n\n    /// Returns a builder for [ExtXMedia].\n    pub fn builder() -\u003e ExtXMediaBuilder {\n        ExtXMediaBuilder::default()\n    }\n\n    /// Returns the type of the media, associated with this tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// assert_eq!(\n    ///     ExtXMedia::new(MediaType::Audio, \"audio\", \"name\").media_type(),\n    ///     MediaType::Audio\n    /// );\n    /// ```\n    pub const fn media_type(\u0026self) -\u003e MediaType {\n        self.media_type\n    }\n\n    /// Sets the type of the media, associated with this tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    ///\n    /// media.set_media_type(MediaType::Video);\n    ///\n    /// assert_eq!(\n    ///     media.media_type(),\n    ///     MediaType::Video\n    /// );\n    /// ```\n    pub fn set_media_type(\u0026mut self, value: MediaType) -\u003e \u0026mut Self {\n        self.media_type = value;\n        self\n    }\n\n    /// Returns the identifier that specifies the group to which the rendition belongs.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// assert_eq!(\n    ///     ExtXMedia::new(MediaType::Audio, \"audio\", \"name\").group_id(),\n    ///     \u0026\"audio\".to_string()\n    /// );\n    /// ```\n    pub const fn group_id(\u0026self) -\u003e \u0026String {\n        \u0026self.group_id\n    }\n\n    /// Sets the identifier that specifies the group, to which the rendition belongs.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    ///\n    /// media.set_group_id(\"video\");\n    ///\n    /// assert_eq!(\n    ///     media.group_id(),\n    ///     \u0026\"video\".to_string()\n    /// );\n    /// ```\n    pub fn set_group_id\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, value: T) -\u003e \u0026mut Self {\n        self.group_id = value.into();\n        self\n    }\n\n    /// Returns a human-readable description of the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// assert_eq!(\n    ///     ExtXMedia::new(MediaType::Audio, \"audio\", \"name\").name(),\n    ///     \u0026\"name\".to_string()\n    /// );\n    /// ```\n    pub const fn name(\u0026self) -\u003e \u0026String {\n        \u0026self.name\n    }\n\n    /// Sets a human-readable description of the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    ///\n    /// media.set_name(\"new_name\");\n    ///\n    /// assert_eq!(\n    ///     media.name(),\n    ///     \u0026\"new_name\".to_string()\n    /// );\n    /// ```\n    pub fn set_name\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, value: T) -\u003e \u0026mut Self {\n        self.name = value.into();\n        self\n    }\n\n    /// Returns the `URI`, that identifies the [MediaPlaylist].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.uri(), \u0026None);\n    ///\n    /// media.set_uri(Some(\"https://www.example.com/\"));\n    ///\n    /// assert_eq!(\n    ///     media.uri(),\n    ///     \u0026Some(\"https://www.example.com/\".into())\n    /// );\n    /// ```\n    pub const fn uri(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.uri\n    }\n\n    /// Sets the `URI`, that identifies the [MediaPlaylist].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.uri(), \u0026None);\n    ///\n    /// media.set_uri(Some(\"https://www.example.com/\"));\n    ///\n    /// assert_eq!(\n    ///     media.uri(),\n    ///     \u0026Some(\"https://www.example.com/\".into())\n    /// );\n    /// ```\n    pub fn set_uri\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.uri = value.map(|v| v.into());\n        self\n    }\n\n    /// Returns the name of the primary language used in the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.language(), \u0026None);\n    ///\n    /// media.set_language(Some(\"english\"));\n    ///\n    /// assert_eq!(\n    ///     media.language(),\n    ///     \u0026Some(\"english\".into())\n    /// );\n    /// ```\n    pub const fn language(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.language\n    }\n\n    /// Sets the name of the primary language used in the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.language(), \u0026None);\n    ///\n    /// media.set_language(Some(\"english\"));\n    ///\n    /// assert_eq!(\n    ///     media.language(),\n    ///     \u0026Some(\"english\".into())\n    /// );\n    /// ```\n    pub fn set_language\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.language = value.map(|v| v.into());\n        self\n    }\n\n    /// Returns the name of a language associated with the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.assoc_language(), \u0026None);\n    ///\n    /// media.set_assoc_language(Some(\"spanish\"));\n    ///\n    /// assert_eq!(\n    ///     media.assoc_language(),\n    ///     \u0026Some(\"spanish\".into())\n    /// );\n    /// ```\n    pub const fn assoc_language(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.assoc_language\n    }\n\n    /// Sets the name of a language associated with the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.assoc_language(), \u0026None);\n    ///\n    /// media.set_assoc_language(Some(\"spanish\"));\n    ///\n    /// assert_eq!(\n    ///     media.assoc_language(),\n    ///     \u0026Some(\"spanish\".into())\n    /// );\n    /// ```\n    pub fn set_assoc_language\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.assoc_language = value.map(|v| v.into());\n        self\n    }\n\n    /// Returns whether this is the default rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.is_default(), false);\n    ///\n    /// media.set_default(true);\n    ///\n    /// assert_eq!(\n    ///     media.is_default(),\n    ///     true\n    /// );\n    /// ```\n    pub const fn is_default(\u0026self) -\u003e bool {\n        self.is_default\n    }\n\n    /// Sets the `default` flag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.is_default(), false);\n    ///\n    /// media.set_default(true);\n    ///\n    /// assert_eq!(media.is_default(), true);\n    /// ```\n    pub fn set_default(\u0026mut self, value: bool) -\u003e \u0026mut Self {\n        self.is_default = value;\n        self\n    }\n\n    /// Returns whether the client may choose to\n    /// play this rendition in the absence of explicit user preference.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.is_autoselect(), false);\n    ///\n    /// media.set_autoselect(true);\n    ///\n    /// assert_eq!(media.is_autoselect(), true);\n    /// ```\n    pub const fn is_autoselect(\u0026self) -\u003e bool {\n        self.is_autoselect\n    }\n\n    /// Sets the `autoselect` flag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.is_autoselect(), false);\n    ///\n    /// media.set_autoselect(true);\n    ///\n    /// assert_eq!(media.is_autoselect(), true);\n    /// ```\n    pub fn set_autoselect(\u0026mut self, value: bool) -\u003e \u0026mut Self {\n        self.is_autoselect = value;\n        self\n    }\n\n    /// Returns whether the rendition contains content that is considered essential to play.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.is_forced(), false);\n    ///\n    /// media.set_forced(true);\n    ///\n    /// assert_eq!(media.is_forced(), true);\n    /// ```\n    pub const fn is_forced(\u0026self) -\u003e bool {\n        self.is_forced\n    }\n\n    /// Sets the `forced` flag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.is_forced(), false);\n    ///\n    /// media.set_forced(true);\n    ///\n    /// assert_eq!(media.is_forced(), true);\n    /// ```\n    pub fn set_forced(\u0026mut self, value: bool) -\u003e \u0026mut Self {\n        self.is_forced = value;\n        self\n    }\n\n    /// Returns the identifier that specifies a rendition within the segments in the\n    /// [MediaPlaylist].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::{InStreamId, MediaType};\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.instream_id(), None);\n    ///\n    /// media.set_instream_id(Some(InStreamId::Cc1));\n    ///\n    /// assert_eq!(media.instream_id(), Some(InStreamId::Cc1));\n    /// ```\n    pub const fn instream_id(\u0026self) -\u003e Option\u003cInStreamId\u003e {\n        self.instream_id\n    }\n\n    /// Sets the [InStreamId].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::{InStreamId, MediaType};\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.instream_id(), None);\n    ///\n    /// media.set_instream_id(Some(InStreamId::Cc1));\n    ///\n    /// assert_eq!(media.instream_id(), Some(InStreamId::Cc1));\n    /// ```\n    pub fn set_instream_id(\u0026mut self, value: Option\u003cInStreamId\u003e) -\u003e \u0026mut Self {\n        self.instream_id = value;\n        self\n    }\n\n    /// Returns a string that represents uniform type identifiers (UTI).\n    ///\n    /// Each UTI indicates an individual characteristic of the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.characteristics(), \u0026None);\n    ///\n    /// media.set_characteristics(Some(\"characteristic\"));\n    ///\n    /// assert_eq!(media.characteristics(), \u0026Some(\"characteristic\".into()));\n    /// ```\n    pub const fn characteristics(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.characteristics\n    }\n\n    /// Sets the characteristics.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.characteristics(), \u0026None);\n    ///\n    /// media.set_characteristics(Some(\"characteristic\"));\n    ///\n    /// assert_eq!(media.characteristics(), \u0026Some(\"characteristic\".into()));\n    /// ```\n    pub fn set_characteristics\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.characteristics = value.map(|v| v.into());\n        self\n    }\n\n    /// Returns a [String] that represents the parameters of the rendition.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.channels(), \u0026None);\n    ///\n    /// media.set_channels(Some(\"channel\"));\n    ///\n    /// assert_eq!(media.channels(), \u0026Some(\"channel\".into()));\n    /// ```\n    pub const fn channels(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.channels\n    }\n\n    /// Sets the channels.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMedia;\n    /// use hls_m3u8::types::MediaType;\n    ///\n    /// let mut media = ExtXMedia::new(MediaType::Audio, \"audio\", \"name\");\n    /// # assert_eq!(media.characteristics(), \u0026None);\n    ///\n    /// media.set_characteristics(Some(\"characteristic\"));\n    ///\n    /// assert_eq!(media.characteristics(), \u0026Some(\"characteristic\".into()));\n    /// ```\n    pub fn set_channels\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.channels = value.map(|v| v.into());\n        self\n    }\n}\n\nimpl RequiredVersion for ExtXMedia {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        match self.instream_id {\n            None\n            | Some(InStreamId::Cc1)\n            | Some(InStreamId::Cc2)\n            | Some(InStreamId::Cc3)\n            | Some(InStreamId::Cc4) =\u003e ProtocolVersion::V1,\n            _ =\u003e ProtocolVersion::V7,\n        }\n    }\n}\n\nimpl fmt::Display for ExtXMedia {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n        write!(f, \"TYPE={}\", self.media_type)?;\n        if let Some(value) = \u0026self.uri {\n            write!(f, \",URI={}\", quote(value))?;\n        }\n        write!(f, \",GROUP-ID={}\", quote(\u0026self.group_id))?;\n        if let Some(value) = \u0026self.language {\n            write!(f, \",LANGUAGE={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.assoc_language {\n            write!(f, \",ASSOC-LANGUAGE={}\", quote(value))?;\n        }\n        write!(f, \",NAME={}\", quote(\u0026self.name))?;\n        if self.is_default {\n            write!(f, \",DEFAULT=YES\")?;\n        }\n        if self.is_autoselect {\n            write!(f, \",AUTOSELECT=YES\")?;\n        }\n        if self.is_forced {\n            write!(f, \",FORCED=YES\")?;\n        }\n        if let Some(value) = \u0026self.instream_id {\n            write!(f, \",INSTREAM-ID={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.characteristics {\n            write!(f, \",CHARACTERISTICS={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.channels {\n            write!(f, \",CHANNELS={}\", quote(value))?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXMedia {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let mut builder = Self::builder();\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"TYPE\" =\u003e {\n                    builder.media_type(value.parse::\u003cMediaType\u003e()?);\n                }\n                \"URI\" =\u003e {\n                    builder.uri(unquote(value));\n                }\n                \"GROUP-ID\" =\u003e {\n                    builder.group_id(unquote(value));\n                }\n                \"LANGUAGE\" =\u003e {\n                    builder.language(unquote(value));\n                }\n                \"ASSOC-LANGUAGE\" =\u003e {\n                    builder.assoc_language(unquote(value));\n                }\n                \"NAME\" =\u003e {\n                    builder.name(unquote(value));\n                }\n                \"DEFAULT\" =\u003e {\n                    builder.is_default(parse_yes_or_no(value)?);\n                }\n                \"AUTOSELECT\" =\u003e {\n                    builder.is_autoselect(parse_yes_or_no(value)?);\n                }\n                \"FORCED\" =\u003e {\n                    builder.is_forced(parse_yes_or_no(value)?);\n                }\n                \"INSTREAM-ID\" =\u003e {\n                    builder.instream_id(unquote(value).parse::\u003cInStreamId\u003e()?);\n                }\n                \"CHARACTERISTICS\" =\u003e {\n                    builder.characteristics(unquote(value));\n                }\n                \"CHANNELS\" =\u003e {\n                    builder.channels(unquote(value));\n                }\n                _ =\u003e {\n                    // [6.3.1. General Client Responsibilities]\n                    // \u003e ignore any attribute/value pair with an unrecognized AttributeName.\n                }\n            }\n        }\n        builder.build().map_err(Error::builder_error)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        // TODO: https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/adding_alternate_media_to_a_playlist\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio\")\n                .language(\"eng\")\n                .name(\"English\")\n                .is_autoselect(true)\n                .is_default(true)\n                .uri(\"eng/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"eng/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio\\\",\\\n             LANGUAGE=\\\"eng\\\",\\\n             NAME=\\\"English\\\",\\\n             DEFAULT=YES,\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio\")\n                .language(\"fre\")\n                .name(\"Franais\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"fre/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"fre/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio\\\",\\\n             LANGUAGE=\\\"fre\\\",\\\n             NAME=\\\"Franais\\\",\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio\")\n                .language(\"sp\")\n                .name(\"Espanol\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"sp/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"sp/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio\\\",\\\n             LANGUAGE=\\\"sp\\\",\\\n             NAME=\\\"Espanol\\\",\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n        // ----\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-lo\")\n                .language(\"eng\")\n                .name(\"English\")\n                .is_autoselect(true)\n                .is_default(true)\n                .uri(\"englo/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"englo/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-lo\\\",\\\n             LANGUAGE=\\\"eng\\\",\\\n             NAME=\\\"English\\\",\\\n             DEFAULT=YES,\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-lo\")\n                .language(\"fre\")\n                .name(\"Franais\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"frelo/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"frelo/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-lo\\\",\\\n             LANGUAGE=\\\"fre\\\",\\\n             NAME=\\\"Franais\\\",\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-lo\")\n                .language(\"es\")\n                .name(\"Espanol\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"splo/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"splo/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-lo\\\",\\\n             LANGUAGE=\\\"es\\\",\\\n             NAME=\\\"Espanol\\\",\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-hi\")\n                .language(\"eng\")\n                .name(\"English\")\n                .is_autoselect(true)\n                .is_default(true)\n                .uri(\"eng/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"eng/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-hi\\\",\\\n             LANGUAGE=\\\"eng\\\",\\\n             NAME=\\\"English\\\",\\\n             DEFAULT=YES,\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-hi\")\n                .language(\"fre\")\n                .name(\"Franais\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"fre/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"fre/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-hi\\\",\\\n             LANGUAGE=\\\"fre\\\",\\\n             NAME=\\\"Franais\\\",\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-hi\")\n                .language(\"es\")\n                .name(\"Espanol\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"sp/prog_index.m3u8\")\n                .build()\n                .unwrap()\n                .to_string(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"sp/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-hi\\\",\\\n             LANGUAGE=\\\"es\\\",\\\n             NAME=\\\"Espanol\\\",\\\n             AUTOSELECT=YES\"\n                .to_string()\n        );\n        // ----\n        assert_eq!(\n            ExtXMedia::new(MediaType::Audio, \"foo\", \"bar\").to_string(),\n            \"#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\\\"foo\\\",NAME=\\\"bar\\\"\".to_string()\n        )\n    }\n\n    #[test]\n    fn test_parser() {\n        // TODO: https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/adding_alternate_media_to_a_playlist\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio\")\n                .language(\"eng\")\n                .name(\"English\")\n                .is_autoselect(true)\n                .is_default(true)\n                .uri(\"eng/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"eng/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio\\\",\\\n             LANGUAGE=\\\"eng\\\",\\\n             NAME=\\\"English\\\",\\\n             DEFAULT=YES,\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio\")\n                .language(\"fre\")\n                .name(\"Franais\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"fre/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"fre/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio\\\",\\\n             LANGUAGE=\\\"fre\\\",\\\n             NAME=\\\"Franais\\\",\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio\")\n                .language(\"sp\")\n                .name(\"Espanol\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"sp/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"sp/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio\\\",\\\n             LANGUAGE=\\\"sp\\\",\\\n             NAME=\\\"Espanol\\\",\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n        // ----\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-lo\")\n                .language(\"eng\")\n                .name(\"English\")\n                .is_autoselect(true)\n                .is_default(true)\n                .uri(\"englo/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"englo/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-lo\\\",\\\n             LANGUAGE=\\\"eng\\\",\\\n             NAME=\\\"English\\\",\\\n             DEFAULT=YES,\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-lo\")\n                .language(\"fre\")\n                .name(\"Franais\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"frelo/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"frelo/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-lo\\\",\\\n             LANGUAGE=\\\"fre\\\",\\\n             NAME=\\\"Franais\\\",\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-lo\")\n                .language(\"es\")\n                .name(\"Espanol\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"splo/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"splo/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-lo\\\",\\\n             LANGUAGE=\\\"es\\\",\\\n             NAME=\\\"Espanol\\\",\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-hi\")\n                .language(\"eng\")\n                .name(\"English\")\n                .is_autoselect(true)\n                .is_default(true)\n                .uri(\"eng/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"eng/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-hi\\\",\\\n             LANGUAGE=\\\"eng\\\",\\\n             NAME=\\\"English\\\",\\\n             DEFAULT=YES,\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-hi\")\n                .language(\"fre\")\n                .name(\"Franais\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"fre/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"fre/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-hi\\\",\\\n             LANGUAGE=\\\"fre\\\",\\\n             NAME=\\\"Franais\\\",\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio-hi\")\n                .language(\"es\")\n                .name(\"Espanol\")\n                .is_autoselect(true)\n                .is_default(false)\n                .uri(\"sp/prog_index.m3u8\")\n                .build()\n                .unwrap(),\n            \"#EXT-X-MEDIA:\\\n             TYPE=AUDIO,\\\n             URI=\\\"sp/prog_index.m3u8\\\",\\\n             GROUP-ID=\\\"audio-hi\\\",\\\n             LANGUAGE=\\\"es\\\",\\\n             NAME=\\\"Espanol\\\",\\\n             AUTOSELECT=YES\"\n                .parse()\n                .unwrap()\n        );\n        // ----\n        assert_eq!(\n            ExtXMedia::new(MediaType::Audio, \"foo\", \"bar\"),\n            \"#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\\\"foo\\\",NAME=\\\"bar\\\"\"\n                .parse()\n                .unwrap()\n        )\n    }\n\n    #[test]\n    fn test_required_version() {\n        macro_rules! gen_required_version {\n            ( $( $id:expr =\u003e $output:expr, )* ) =\u003e {\n                $(\n                    assert_eq!(\n                        ExtXMedia::builder()\n                            .media_type(MediaType::ClosedCaptions)\n                            .group_id(\"audio\")\n                            .name(\"English\")\n                            .instream_id($id)\n                            .build()\n                            .unwrap()\n                            .required_version(),\n                        $output\n                    );\n                )*\n            }\n        }\n\n        gen_required_version![\n            InStreamId::Cc1 =\u003e ProtocolVersion::V1,\n            InStreamId::Cc2 =\u003e ProtocolVersion::V1,\n            InStreamId::Cc3 =\u003e ProtocolVersion::V1,\n            InStreamId::Cc4 =\u003e ProtocolVersion::V1,\n            InStreamId::Service1 =\u003e ProtocolVersion::V7,\n        ];\n\n        assert_eq!(\n            ExtXMedia::builder()\n                .media_type(MediaType::Audio)\n                .group_id(\"audio\")\n                .name(\"English\")\n                .build()\n                .unwrap()\n                .required_version(),\n            ProtocolVersion::V1\n        );\n    }\n}\n","traces":[{"line":68,"address":4213872,"length":1,"stats":{"Line":1}},{"line":69,"address":4213887,"length":1,"stats":{"Line":1}},{"line":70,"address":null,"length":0,"stats":{"Line":0}},{"line":71,"address":4213956,"length":1,"stats":{"Line":1}},{"line":73,"address":4214177,"length":1,"stats":{"Line":1}},{"line":74,"address":4214237,"length":1,"stats":{"Line":1}},{"line":75,"address":4214303,"length":1,"stats":{"Line":0}},{"line":76,"address":null,"length":0,"stats":{"Line":0}},{"line":78,"address":4214391,"length":1,"stats":{"Line":0}},{"line":80,"address":4214265,"length":1,"stats":{"Line":1}},{"line":81,"address":4214455,"length":1,"stats":{"Line":1}},{"line":82,"address":4214208,"length":1,"stats":{"Line":1}},{"line":83,"address":4214708,"length":1,"stats":{"Line":0}},{"line":86,"address":4214838,"length":1,"stats":{"Line":1}},{"line":87,"address":4215024,"length":1,"stats":{"Line":0}},{"line":88,"address":4214976,"length":1,"stats":{"Line":0}},{"line":92,"address":4214942,"length":1,"stats":{"Line":1}},{"line":93,"address":4215199,"length":1,"stats":{"Line":0}},{"line":96,"address":4215187,"length":1,"stats":{"Line":1}},{"line":104,"address":null,"length":0,"stats":{"Line":25}},{"line":108,"address":null,"length":0,"stats":{"Line":25}},{"line":111,"address":null,"length":0,"stats":{"Line":25}},{"line":122,"address":4215520,"length":1,"stats":{"Line":1}},{"line":138,"address":4215552,"length":1,"stats":{"Line":2}},{"line":139,"address":4215557,"length":1,"stats":{"Line":2}},{"line":158,"address":4215584,"length":1,"stats":{"Line":1}},{"line":159,"address":4215597,"length":1,"stats":{"Line":1}},{"line":160,"address":null,"length":0,"stats":{"Line":1}},{"line":175,"address":4215632,"length":1,"stats":{"Line":2}},{"line":176,"address":null,"length":0,"stats":{"Line":2}},{"line":195,"address":null,"length":0,"stats":{"Line":1}},{"line":196,"address":null,"length":0,"stats":{"Line":1}},{"line":197,"address":null,"length":0,"stats":{"Line":1}},{"line":212,"address":4215664,"length":1,"stats":{"Line":2}},{"line":213,"address":null,"length":0,"stats":{"Line":2}},{"line":232,"address":null,"length":0,"stats":{"Line":1}},{"line":233,"address":null,"length":0,"stats":{"Line":1}},{"line":234,"address":null,"length":0,"stats":{"Line":1}},{"line":254,"address":4215696,"length":1,"stats":{"Line":2}},{"line":255,"address":null,"length":0,"stats":{"Line":2}},{"line":275,"address":null,"length":0,"stats":{"Line":2}},{"line":276,"address":null,"length":0,"stats":{"Line":4}},{"line":277,"address":null,"length":0,"stats":{"Line":2}},{"line":297,"address":null,"length":0,"stats":{"Line":2}},{"line":298,"address":null,"length":0,"stats":{"Line":2}},{"line":318,"address":null,"length":0,"stats":{"Line":2}},{"line":319,"address":null,"length":0,"stats":{"Line":4}},{"line":320,"address":null,"length":0,"stats":{"Line":2}},{"line":340,"address":null,"length":0,"stats":{"Line":2}},{"line":341,"address":null,"length":0,"stats":{"Line":2}},{"line":361,"address":null,"length":0,"stats":{"Line":2}},{"line":362,"address":null,"length":0,"stats":{"Line":4}},{"line":363,"address":null,"length":0,"stats":{"Line":2}},{"line":383,"address":null,"length":0,"stats":{"Line":2}},{"line":384,"address":null,"length":0,"stats":{"Line":2}},{"line":401,"address":null,"length":0,"stats":{"Line":2}},{"line":402,"address":null,"length":0,"stats":{"Line":2}},{"line":403,"address":null,"length":0,"stats":{"Line":2}},{"line":421,"address":null,"length":0,"stats":{"Line":2}},{"line":422,"address":null,"length":0,"stats":{"Line":2}},{"line":439,"address":null,"length":0,"stats":{"Line":2}},{"line":440,"address":null,"length":0,"stats":{"Line":2}},{"line":441,"address":null,"length":0,"stats":{"Line":2}},{"line":458,"address":null,"length":0,"stats":{"Line":2}},{"line":459,"address":null,"length":0,"stats":{"Line":2}},{"line":476,"address":null,"length":0,"stats":{"Line":2}},{"line":477,"address":null,"length":0,"stats":{"Line":2}},{"line":478,"address":null,"length":0,"stats":{"Line":2}},{"line":496,"address":null,"length":0,"stats":{"Line":2}},{"line":497,"address":null,"length":0,"stats":{"Line":2}},{"line":514,"address":null,"length":0,"stats":{"Line":2}},{"line":515,"address":null,"length":0,"stats":{"Line":2}},{"line":516,"address":null,"length":0,"stats":{"Line":2}},{"line":535,"address":null,"length":0,"stats":{"Line":3}},{"line":536,"address":null,"length":0,"stats":{"Line":3}},{"line":553,"address":null,"length":0,"stats":{"Line":3}},{"line":554,"address":null,"length":0,"stats":{"Line":6}},{"line":555,"address":null,"length":0,"stats":{"Line":3}},{"line":572,"address":null,"length":0,"stats":{"Line":1}},{"line":573,"address":null,"length":0,"stats":{"Line":1}},{"line":590,"address":null,"length":0,"stats":{"Line":1}},{"line":591,"address":null,"length":0,"stats":{"Line":2}},{"line":592,"address":null,"length":0,"stats":{"Line":1}},{"line":597,"address":null,"length":0,"stats":{"Line":1}},{"line":598,"address":null,"length":0,"stats":{"Line":1}},{"line":599,"address":null,"length":0,"stats":{"Line":1}},{"line":600,"address":null,"length":0,"stats":{"Line":1}},{"line":601,"address":null,"length":0,"stats":{"Line":0}},{"line":602,"address":null,"length":0,"stats":{"Line":0}},{"line":603,"address":null,"length":0,"stats":{"Line":1}},{"line":604,"address":null,"length":0,"stats":{"Line":1}},{"line":610,"address":null,"length":0,"stats":{"Line":1}},{"line":611,"address":null,"length":0,"stats":{"Line":1}},{"line":612,"address":null,"length":0,"stats":{"Line":1}},{"line":613,"address":null,"length":0,"stats":{"Line":1}},{"line":614,"address":null,"length":0,"stats":{"Line":1}},{"line":616,"address":null,"length":0,"stats":{"Line":1}},{"line":617,"address":null,"length":0,"stats":{"Line":1}},{"line":618,"address":null,"length":0,"stats":{"Line":1}},{"line":620,"address":null,"length":0,"stats":{"Line":1}},{"line":621,"address":null,"length":0,"stats":{"Line":0}},{"line":623,"address":null,"length":0,"stats":{"Line":1}},{"line":624,"address":null,"length":0,"stats":{"Line":1}},{"line":625,"address":null,"length":0,"stats":{"Line":1}},{"line":627,"address":null,"length":0,"stats":{"Line":1}},{"line":628,"address":null,"length":0,"stats":{"Line":1}},{"line":630,"address":null,"length":0,"stats":{"Line":1}},{"line":631,"address":null,"length":0,"stats":{"Line":0}},{"line":633,"address":null,"length":0,"stats":{"Line":1}},{"line":634,"address":null,"length":0,"stats":{"Line":0}},{"line":636,"address":null,"length":0,"stats":{"Line":1}},{"line":637,"address":null,"length":0,"stats":{"Line":0}},{"line":639,"address":null,"length":0,"stats":{"Line":1}},{"line":640,"address":null,"length":0,"stats":{"Line":0}},{"line":642,"address":null,"length":0,"stats":{"Line":1}},{"line":649,"address":null,"length":0,"stats":{"Line":1}},{"line":650,"address":null,"length":0,"stats":{"Line":1}},{"line":652,"address":null,"length":0,"stats":{"Line":1}},{"line":654,"address":null,"length":0,"stats":{"Line":1}},{"line":655,"address":null,"length":0,"stats":{"Line":1}},{"line":656,"address":null,"length":0,"stats":{"Line":1}},{"line":657,"address":null,"length":0,"stats":{"Line":1}},{"line":659,"address":null,"length":0,"stats":{"Line":1}},{"line":660,"address":null,"length":0,"stats":{"Line":1}},{"line":662,"address":null,"length":0,"stats":{"Line":1}},{"line":663,"address":null,"length":0,"stats":{"Line":1}},{"line":665,"address":null,"length":0,"stats":{"Line":1}},{"line":666,"address":null,"length":0,"stats":{"Line":1}},{"line":668,"address":null,"length":0,"stats":{"Line":1}},{"line":669,"address":null,"length":0,"stats":{"Line":0}},{"line":671,"address":null,"length":0,"stats":{"Line":1}},{"line":672,"address":null,"length":0,"stats":{"Line":1}},{"line":674,"address":null,"length":0,"stats":{"Line":1}},{"line":675,"address":null,"length":0,"stats":{"Line":1}},{"line":677,"address":null,"length":0,"stats":{"Line":1}},{"line":678,"address":null,"length":0,"stats":{"Line":1}},{"line":680,"address":null,"length":0,"stats":{"Line":0}},{"line":681,"address":null,"length":0,"stats":{"Line":0}},{"line":683,"address":null,"length":0,"stats":{"Line":0}},{"line":684,"address":null,"length":0,"stats":{"Line":0}},{"line":686,"address":null,"length":0,"stats":{"Line":0}},{"line":687,"address":null,"length":0,"stats":{"Line":0}},{"line":689,"address":null,"length":0,"stats":{"Line":0}},{"line":690,"address":null,"length":0,"stats":{"Line":0}},{"line":692,"address":null,"length":0,"stats":{"Line":0}},{"line":698,"address":null,"length":0,"stats":{"Line":1}},{"line":707,"address":4907408,"length":1,"stats":{"Line":2}},{"line":709,"address":5274053,"length":1,"stats":{"Line":0}},{"line":710,"address":5273949,"length":1,"stats":{"Line":1}},{"line":711,"address":5273979,"length":1,"stats":{"Line":1}},{"line":732,"address":5274971,"length":1,"stats":{"Line":0}},{"line":733,"address":5274884,"length":1,"stats":{"Line":1}},{"line":734,"address":5274897,"length":1,"stats":{"Line":1}},{"line":754,"address":5275889,"length":1,"stats":{"Line":0}},{"line":755,"address":5275802,"length":1,"stats":{"Line":1}},{"line":756,"address":5275815,"length":1,"stats":{"Line":1}},{"line":776,"address":5276807,"length":1,"stats":{"Line":0}},{"line":777,"address":5276720,"length":1,"stats":{"Line":1}},{"line":778,"address":5276733,"length":1,"stats":{"Line":1}},{"line":799,"address":5277728,"length":1,"stats":{"Line":0}},{"line":800,"address":5277641,"length":1,"stats":{"Line":1}},{"line":801,"address":5277654,"length":1,"stats":{"Line":1}},{"line":821,"address":5278646,"length":1,"stats":{"Line":0}},{"line":822,"address":5278559,"length":1,"stats":{"Line":1}},{"line":823,"address":5278572,"length":1,"stats":{"Line":1}},{"line":843,"address":5279564,"length":1,"stats":{"Line":0}},{"line":844,"address":5279477,"length":1,"stats":{"Line":1}},{"line":845,"address":5279490,"length":1,"stats":{"Line":1}},{"line":866,"address":5280485,"length":1,"stats":{"Line":0}},{"line":867,"address":5280398,"length":1,"stats":{"Line":1}},{"line":868,"address":5280411,"length":1,"stats":{"Line":1}},{"line":888,"address":5281403,"length":1,"stats":{"Line":0}},{"line":889,"address":5281316,"length":1,"stats":{"Line":1}},{"line":890,"address":5281329,"length":1,"stats":{"Line":1}},{"line":910,"address":5282335,"length":1,"stats":{"Line":1}},{"line":911,"address":5282206,"length":1,"stats":{"Line":1}},{"line":912,"address":5282282,"length":1,"stats":{"Line":1}},{"line":917,"address":4907440,"length":1,"stats":{"Line":2}},{"line":919,"address":5283717,"length":1,"stats":{"Line":0}},{"line":920,"address":5283613,"length":1,"stats":{"Line":1}},{"line":921,"address":5283643,"length":1,"stats":{"Line":1}},{"line":942,"address":5284603,"length":1,"stats":{"Line":0}},{"line":943,"address":5284516,"length":1,"stats":{"Line":1}},{"line":944,"address":5284529,"length":1,"stats":{"Line":1}},{"line":964,"address":5285489,"length":1,"stats":{"Line":0}},{"line":965,"address":5285402,"length":1,"stats":{"Line":1}},{"line":966,"address":5285415,"length":1,"stats":{"Line":1}},{"line":986,"address":5286375,"length":1,"stats":{"Line":0}},{"line":987,"address":5286288,"length":1,"stats":{"Line":1}},{"line":988,"address":5286301,"length":1,"stats":{"Line":1}},{"line":1009,"address":5287264,"length":1,"stats":{"Line":0}},{"line":1010,"address":5287177,"length":1,"stats":{"Line":1}},{"line":1011,"address":5287190,"length":1,"stats":{"Line":1}},{"line":1031,"address":5288150,"length":1,"stats":{"Line":0}},{"line":1032,"address":5288063,"length":1,"stats":{"Line":1}},{"line":1033,"address":5288076,"length":1,"stats":{"Line":1}},{"line":1053,"address":5289036,"length":1,"stats":{"Line":0}},{"line":1054,"address":5288949,"length":1,"stats":{"Line":1}},{"line":1055,"address":5288962,"length":1,"stats":{"Line":1}},{"line":1076,"address":5289925,"length":1,"stats":{"Line":0}},{"line":1077,"address":5289838,"length":1,"stats":{"Line":1}},{"line":1078,"address":5289851,"length":1,"stats":{"Line":1}},{"line":1098,"address":5290811,"length":1,"stats":{"Line":0}},{"line":1099,"address":5290724,"length":1,"stats":{"Line":1}},{"line":1100,"address":5290737,"length":1,"stats":{"Line":1}},{"line":1120,"address":5291711,"length":1,"stats":{"Line":1}},{"line":1121,"address":5291582,"length":1,"stats":{"Line":1}},{"line":1129,"address":4907472,"length":1,"stats":{"Line":2}},{"line":1148,"address":5292765,"length":1,"stats":{"Line":1}},{"line":1149,"address":5292919,"length":1,"stats":{"Line":1}},{"line":1150,"address":5293673,"length":1,"stats":{"Line":1}},{"line":1151,"address":5294427,"length":1,"stats":{"Line":1}},{"line":1152,"address":5295181,"length":1,"stats":{"Line":1}},{"line":1153,"address":5295935,"length":1,"stats":{"Line":1}},{"line":1156,"address":5296591,"length":1,"stats":{"Line":0}},{"line":1157,"address":5296513,"length":1,"stats":{"Line":1}},{"line":1158,"address":5296526,"length":1,"stats":{"Line":1}}],"covered":173,"coverable":217},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","master_playlist","session_data.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse derive_builder::Builder;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::{quote, tag, unquote};\nuse crate::Error;\n\n/// The data of an [ExtXSessionData] tag.\n#[derive(Hash, Eq, Ord, Debug, PartialEq, Clone, PartialOrd)]\npub enum SessionData {\n    /// A String, that contains the data identified by [data_id](ExtXSessionData::data_id).\n    /// If a [language](ExtXSessionData::language) is specified, the value should\n    /// contain a human-readable string written in the specified language.\n    Value(String),\n    /// An [uri], which points to a [json].\n    ///\n    /// [json]: https://tools.ietf.org/html/rfc8259\n    /// [uri]: https://tools.ietf.org/html/rfc3986\n    Uri(String),\n}\n\n/// # [4.3.4.4. EXT-X-SESSION-DATA]\n///\n/// The [ExtXSessionData] tag allows arbitrary session data to be\n/// carried in a [Master Playlist].\n///\n/// [Master Playlist]: crate::MasterPlaylist\n/// [4.3.4.4. EXT-X-SESSION-DATA]: https://tools.ietf.org/html/rfc8216#section-4.3.4.4\n#[derive(Builder, Hash, Eq, Ord, Debug, PartialEq, Clone, PartialOrd)]\n#[builder(setter(into))]\npub struct ExtXSessionData {\n    /// The identifier of the data. For more information look [here](ExtXSessionData::set_data_id).\n    /// # Note\n    /// This field is required.\n    data_id: String,\n    /// The data associated with the [data_id](ExtXSessionDataBuilder::data_id).\n    /// For more information look [here](SessionData).\n    /// # Note\n    /// This field is required.\n    data: SessionData,\n    /// The language of the [data](ExtXSessionDataBuilder::data).\n    #[builder(setter(into, strip_option), default)]\n    language: Option\u003cString\u003e,\n}\n\nimpl ExtXSessionData {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-SESSION-DATA:\";\n\n    /// Makes a new [ExtXSessionData] tag.\n    ///\n    /// # Example\n    /// ```\n    /// use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    ///\n    /// ExtXSessionData::new(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Uri(\"https://www.example.com/\".to_string())\n    /// );\n    /// ```\n    pub fn new\u003cT: ToString\u003e(data_id: T, data: SessionData) -\u003e Self {\n        Self {\n            data_id: data_id.to_string(),\n            data,\n            language: None,\n        }\n    }\n\n    /// Returns a new Builder for [ExtXSessionData].\n    ///\n    /// # Example\n    /// ```\n    /// use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    ///\n    /// let session_data = ExtXSessionData::builder()\n    ///     .data_id(\"com.example.movie.title\")\n    ///     .data(SessionData::Value(\"some data\".to_string()))\n    ///     .language(\"english\")\n    ///     .build()\n    ///     .expect(\"Failed to build an ExtXSessionData tag.\");\n    ///\n    /// assert_eq!(\n    ///     session_data,\n    ///     ExtXSessionData::with_language(\n    ///         \"com.example.movie.title\",\n    ///         SessionData::Value(\"some data\".to_string()),\n    ///         \"english\"\n    ///     )\n    /// );\n    /// ```\n    pub fn builder() -\u003e ExtXSessionDataBuilder {\n        ExtXSessionDataBuilder::default()\n    }\n\n    /// Makes a new [ExtXSessionData] tag, with the given language.\n    ///\n    /// # Example\n    /// ```\n    /// use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    ///\n    /// let session_data = ExtXSessionData::with_language(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Value(\"some data\".to_string()),\n    ///     \"english\"\n    /// );\n    /// ```\n    pub fn with_language\u003cT: ToString\u003e(data_id: T, data: SessionData, language: T) -\u003e Self {\n        Self {\n            data_id: data_id.to_string(),\n            data,\n            language: Some(language.to_string()),\n        }\n    }\n\n    /// Returns the `data_id`, that identifies a `data_value`.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    /// #\n    /// let data = ExtXSessionData::new(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Value(\"some data\".to_string())\n    /// );\n    ///\n    /// assert_eq!(\n    ///     data.data_id(),\n    ///     \u0026\"com.example.movie.title\".to_string()\n    /// )\n    /// ```\n    pub const fn data_id(\u0026self) -\u003e \u0026String {\n        \u0026self.data_id\n    }\n\n    /// Returns the `data`.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    /// #\n    /// let data = ExtXSessionData::new(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Value(\"some data\".to_string())\n    /// );\n    ///\n    /// assert_eq!(\n    ///     data.data(),\n    ///     \u0026SessionData::Value(\"some data\".to_string())\n    /// )\n    /// ```\n    pub const fn data(\u0026self) -\u003e \u0026SessionData {\n        \u0026self.data\n    }\n\n    /// Returns the `language` tag, that identifies the language of [SessionData].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    /// #\n    /// let data = ExtXSessionData::with_language(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Value(\"some data\".to_string()),\n    ///     \"english\"\n    /// );\n    ///\n    /// assert_eq!(\n    ///     data.language(),\n    ///     \u0026Some(\"english\".to_string())\n    /// )\n    /// ```\n    pub const fn language(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.language\n    }\n\n    /// Sets the `language` attribute, that identifies the language of [SessionData].\n    /// See [rfc5646](https://tools.ietf.org/html/rfc5646).\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    /// #\n    /// let mut data = ExtXSessionData::new(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Value(\"some data\".to_string()),\n    /// );\n    ///\n    /// assert_eq!(data.language(), \u0026None);\n    ///\n    /// data.set_language(Some(\"english\"));\n    /// assert_eq!(data.language(), \u0026Some(\"english\".to_string()));\n    /// ```\n    pub fn set_language\u003cT: ToString\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.language = value.map(|v| v.to_string());\n        self\n    }\n\n    /// Sets the `data_id` attribute, that should conform to a [reverse DNS] naming convention,\n    /// such as `com.example.movie.title`.\n    ///\n    /// # Note:\n    /// There is no central registration authority, so a value\n    /// should be choosen, that is unlikely to collide with others.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    /// #\n    /// let mut data = ExtXSessionData::new(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Value(\"some data\".to_string()),\n    /// );\n    ///\n    /// assert_eq!(data.data_id(), \u0026\"com.example.movie.title\".to_string());\n    ///\n    /// data.set_data_id(\"com.other.movie.title\");\n    /// assert_eq!(data.data_id(), \u0026\"com.other.movie.title\".to_string());\n    /// ```\n    /// [reverse DNS]: https://en.wikipedia.org/wiki/Reverse_domain_name_notation\n    pub fn set_data_id\u003cT: ToString\u003e(\u0026mut self, value: T) -\u003e \u0026mut Self {\n        self.data_id = value.to_string();\n        self\n    }\n\n    /// Sets the [data](ExtXSessionData::data) of this tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::{ExtXSessionData, SessionData};\n    /// #\n    /// let mut data = ExtXSessionData::new(\n    ///     \"com.example.movie.title\",\n    ///     SessionData::Value(\"some data\".to_string()),\n    /// );\n    ///\n    /// assert_eq!(data.data(), \u0026SessionData::Value(\"some data\".to_string()));\n    ///\n    /// data.set_data(SessionData::Value(\"new data\".to_string()));\n    /// assert_eq!(data.data(), \u0026SessionData::Value(\"new data\".to_string()));\n    /// ```\n    pub fn set_data(\u0026mut self, value: SessionData) -\u003e \u0026mut Self {\n        self.data = value;\n        self\n    }\n}\n\nimpl RequiredVersion for ExtXSessionData {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXSessionData {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n        write!(f, \"DATA-ID={}\", quote(\u0026self.data_id))?;\n\n        match \u0026self.data {\n            SessionData::Value(value) =\u003e write!(f, \",VALUE={}\", quote(value))?,\n            SessionData::Uri(value) =\u003e write!(f, \",URI={}\", quote(value))?,\n        }\n\n        if let Some(value) = \u0026self.language {\n            write!(f, \",LANGUAGE={}\", quote(value))?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXSessionData {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let mut data_id = None;\n        let mut session_value = None;\n        let mut uri = None;\n        let mut language = None;\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"DATA-ID\" =\u003e data_id = Some(unquote(value)),\n                \"VALUE\" =\u003e session_value = Some(unquote(value)),\n                \"URI\" =\u003e uri = Some(unquote(value)),\n                \"LANGUAGE\" =\u003e language = Some(unquote(value)),\n                _ =\u003e {\n                    // [6.3.1. General Client Responsibilities]\n                    // \u003e ignore any attribute/value pair with an unrecognized AttributeName.\n                }\n            }\n        }\n\n        let data_id = data_id.ok_or_else(|| Error::missing_value(\"EXT-X-DATA-ID\"))?;\n        let data = {\n            if let Some(value) = session_value {\n                if uri.is_some() {\n                    return Err(Error::custom(\"Unexpected URI\"));\n                } else {\n                    SessionData::Value(value)\n                }\n            } else if let Some(uri) = uri {\n                SessionData::Uri(uri)\n            } else {\n                return Err(Error::invalid_input());\n            }\n        };\n\n        Ok(Self {\n            data_id,\n            data,\n            language,\n        })\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"com.example.lyrics\\\",URI=\\\"lyrics.json\\\"\".to_string(),\n            ExtXSessionData::new(\n                \"com.example.lyrics\",\n                SessionData::Uri(\"lyrics.json\".to_string())\n            )\n            .to_string()\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"com.example.title\\\",\\\n             VALUE=\\\"This is an example\\\",LANGUAGE=\\\"en\\\"\"\n                .to_string(),\n            ExtXSessionData::with_language(\n                \"com.example.title\",\n                SessionData::Value(\"This is an example\".to_string()),\n                \"en\"\n            )\n            .to_string()\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"com.example.title\\\",\\\n             VALUE=\\\"Este es un ejemplo\\\",LANGUAGE=\\\"es\\\"\"\n                .to_string(),\n            ExtXSessionData::with_language(\n                \"com.example.title\",\n                SessionData::Value(\"Este es un ejemplo\".to_string()),\n                \"es\"\n            )\n            .to_string()\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"foo\\\",VALUE=\\\"bar\\\"\".to_string(),\n            ExtXSessionData::new(\"foo\", SessionData::Value(\"bar\".into())).to_string()\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"foo\\\",URI=\\\"bar\\\"\".to_string(),\n            ExtXSessionData::new(\"foo\", SessionData::Uri(\"bar\".into())).to_string()\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"foo\\\",VALUE=\\\"bar\\\",LANGUAGE=\\\"baz\\\"\".to_string(),\n            ExtXSessionData::with_language(\"foo\", SessionData::Value(\"bar\".into()), \"baz\")\n                .to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"com.example.lyrics\\\",URI=\\\"lyrics.json\\\"\"\n                .parse::\u003cExtXSessionData\u003e()\n                .unwrap(),\n            ExtXSessionData::new(\n                \"com.example.lyrics\",\n                SessionData::Uri(\"lyrics.json\".to_string())\n            )\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"com.example.title\\\",\\\n             LANGUAGE=\\\"en\\\", VALUE=\\\"This is an example\\\"\"\n                .parse::\u003cExtXSessionData\u003e()\n                .unwrap(),\n            ExtXSessionData::with_language(\n                \"com.example.title\",\n                SessionData::Value(\"This is an example\".to_string()),\n                \"en\"\n            )\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"com.example.title\\\",\\\n             LANGUAGE=\\\"es\\\", VALUE=\\\"Este es un ejemplo\\\"\"\n                .parse::\u003cExtXSessionData\u003e()\n                .unwrap(),\n            ExtXSessionData::with_language(\n                \"com.example.title\",\n                SessionData::Value(\"Este es un ejemplo\".to_string()),\n                \"es\"\n            )\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"foo\\\",VALUE=\\\"bar\\\"\"\n                .parse::\u003cExtXSessionData\u003e()\n                .unwrap(),\n            ExtXSessionData::new(\"foo\", SessionData::Value(\"bar\".into()))\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"foo\\\",URI=\\\"bar\\\"\"\n                .parse::\u003cExtXSessionData\u003e()\n                .unwrap(),\n            ExtXSessionData::new(\"foo\", SessionData::Uri(\"bar\".into()))\n        );\n\n        assert_eq!(\n            \"#EXT-X-SESSION-DATA:DATA-ID=\\\"foo\\\",VALUE=\\\"bar\\\",LANGUAGE=\\\"baz\\\"\"\n                .parse::\u003cExtXSessionData\u003e()\n                .unwrap(),\n            ExtXSessionData::with_language(\"foo\", SessionData::Value(\"bar\".into()), \"baz\")\n        );\n\n        assert!(\"#EXT-X-SESSION-DATA:DATA-ID=\\\"foo\\\",LANGUAGE=\\\"baz\\\"\"\n            .parse::\u003cExtXSessionData\u003e()\n            .is_err())\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXSessionData::new(\n                \"com.example.lyrics\",\n                SessionData::Uri(\"lyrics.json\".to_string())\n            )\n            .required_version(),\n            ProtocolVersion::V1\n        );\n    }\n}\n","traces":[{"line":63,"address":null,"length":0,"stats":{"Line":7}},{"line":65,"address":null,"length":0,"stats":{"Line":7}},{"line":93,"address":4213744,"length":1,"stats":{"Line":1}},{"line":109,"address":null,"length":0,"stats":{"Line":4}},{"line":111,"address":null,"length":0,"stats":{"Line":4}},{"line":113,"address":null,"length":0,"stats":{"Line":4}},{"line":133,"address":4213776,"length":1,"stats":{"Line":2}},{"line":134,"address":4213781,"length":1,"stats":{"Line":2}},{"line":153,"address":4213792,"length":1,"stats":{"Line":2}},{"line":154,"address":4213797,"length":1,"stats":{"Line":2}},{"line":174,"address":4213824,"length":1,"stats":{"Line":2}},{"line":175,"address":4213829,"length":1,"stats":{"Line":2}},{"line":195,"address":null,"length":0,"stats":{"Line":1}},{"line":196,"address":null,"length":0,"stats":{"Line":2}},{"line":197,"address":null,"length":0,"stats":{"Line":1}},{"line":222,"address":null,"length":0,"stats":{"Line":1}},{"line":223,"address":null,"length":0,"stats":{"Line":1}},{"line":224,"address":null,"length":0,"stats":{"Line":1}},{"line":243,"address":4213856,"length":1,"stats":{"Line":1}},{"line":244,"address":4213865,"length":1,"stats":{"Line":1}},{"line":245,"address":4213981,"length":1,"stats":{"Line":1}},{"line":250,"address":4214016,"length":1,"stats":{"Line":1}},{"line":251,"address":4214024,"length":1,"stats":{"Line":1}},{"line":256,"address":4214048,"length":1,"stats":{"Line":1}},{"line":257,"address":4214085,"length":1,"stats":{"Line":1}},{"line":258,"address":4214396,"length":1,"stats":{"Line":1}},{"line":260,"address":4214797,"length":1,"stats":{"Line":1}},{"line":261,"address":4214817,"length":1,"stats":{"Line":1}},{"line":262,"address":4215227,"length":1,"stats":{"Line":1}},{"line":265,"address":4215611,"length":1,"stats":{"Line":1}},{"line":266,"address":4215681,"length":1,"stats":{"Line":1}},{"line":269,"address":4216039,"length":1,"stats":{"Line":1}},{"line":276,"address":4216144,"length":1,"stats":{"Line":1}},{"line":277,"address":4216171,"length":1,"stats":{"Line":1}},{"line":279,"address":4216724,"length":1,"stats":{"Line":1}},{"line":280,"address":4216744,"length":1,"stats":{"Line":1}},{"line":281,"address":4216764,"length":1,"stats":{"Line":1}},{"line":282,"address":4216784,"length":1,"stats":{"Line":1}},{"line":284,"address":4216796,"length":1,"stats":{"Line":1}},{"line":285,"address":4217912,"length":1,"stats":{"Line":1}},{"line":286,"address":4217933,"length":1,"stats":{"Line":1}},{"line":287,"address":4218060,"length":1,"stats":{"Line":1}},{"line":288,"address":4218126,"length":1,"stats":{"Line":1}},{"line":289,"address":4218192,"length":1,"stats":{"Line":1}},{"line":290,"address":null,"length":0,"stats":{"Line":0}},{"line":297,"address":4217968,"length":1,"stats":{"Line":1}},{"line":298,"address":null,"length":0,"stats":{"Line":0}},{"line":299,"address":4219309,"length":1,"stats":{"Line":1}},{"line":300,"address":4219349,"length":1,"stats":{"Line":1}},{"line":301,"address":4219518,"length":1,"stats":{"Line":0}},{"line":303,"address":4219405,"length":1,"stats":{"Line":1}},{"line":305,"address":4219276,"length":1,"stats":{"Line":1}},{"line":306,"address":4219760,"length":1,"stats":{"Line":1}},{"line":308,"address":4219694,"length":1,"stats":{"Line":1}},{"line":312,"address":4220086,"length":1,"stats":{"Line":1}},{"line":313,"address":4219926,"length":1,"stats":{"Line":1}},{"line":314,"address":4219974,"length":1,"stats":{"Line":1}},{"line":315,"address":4220038,"length":1,"stats":{"Line":1}},{"line":325,"address":4407872,"length":1,"stats":{"Line":2}},{"line":326,"address":5224718,"length":1,"stats":{"Line":0}},{"line":327,"address":5224574,"length":1,"stats":{"Line":1}},{"line":328,"address":5224683,"length":1,"stats":{"Line":1}},{"line":330,"address":5224612,"length":1,"stats":{"Line":1}},{"line":335,"address":5225432,"length":1,"stats":{"Line":0}},{"line":339,"address":5225384,"length":1,"stats":{"Line":1}},{"line":341,"address":5225313,"length":1,"stats":{"Line":1}},{"line":347,"address":5226146,"length":1,"stats":{"Line":0}},{"line":351,"address":5226098,"length":1,"stats":{"Line":1}},{"line":353,"address":5226027,"length":1,"stats":{"Line":1}},{"line":359,"address":5226847,"length":1,"stats":{"Line":0}},{"line":360,"address":5226720,"length":1,"stats":{"Line":1}},{"line":361,"address":5226741,"length":1,"stats":{"Line":1}},{"line":364,"address":5227542,"length":1,"stats":{"Line":0}},{"line":365,"address":5227415,"length":1,"stats":{"Line":1}},{"line":366,"address":5227436,"length":1,"stats":{"Line":1}},{"line":369,"address":5228214,"length":1,"stats":{"Line":0}},{"line":370,"address":5228074,"length":1,"stats":{"Line":1}},{"line":371,"address":5228095,"length":1,"stats":{"Line":1}},{"line":377,"address":4407904,"length":1,"stats":{"Line":2}},{"line":378,"address":5229220,"length":1,"stats":{"Line":0}},{"line":382,"address":5229279,"length":1,"stats":{"Line":1}},{"line":384,"address":5229193,"length":1,"stats":{"Line":1}},{"line":388,"address":5229884,"length":1,"stats":{"Line":0}},{"line":393,"address":5229946,"length":1,"stats":{"Line":1}},{"line":395,"address":5229857,"length":1,"stats":{"Line":1}},{"line":400,"address":5230564,"length":1,"stats":{"Line":0}},{"line":405,"address":5230626,"length":1,"stats":{"Line":1}},{"line":407,"address":5230537,"length":1,"stats":{"Line":1}},{"line":412,"address":5231244,"length":1,"stats":{"Line":0}},{"line":416,"address":5231217,"length":1,"stats":{"Line":1}},{"line":419,"address":5231911,"length":1,"stats":{"Line":0}},{"line":423,"address":5231884,"length":1,"stats":{"Line":1}},{"line":426,"address":5232536,"length":1,"stats":{"Line":0}},{"line":430,"address":5232509,"length":1,"stats":{"Line":1}},{"line":433,"address":5233105,"length":1,"stats":{"Line":1}},{"line":439,"address":4407936,"length":1,"stats":{"Line":2}},{"line":440,"address":5233665,"length":1,"stats":{"Line":0}},{"line":441,"address":5233623,"length":1,"stats":{"Line":1}},{"line":443,"address":5233518,"length":1,"stats":{"Line":1}}],"covered":83,"coverable":99},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","master_playlist","session_key.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::types::{DecryptionKey, EncryptionMethod, ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.3.4.5. EXT-X-SESSION-KEY]\n/// The [ExtXSessionKey] tag allows encryption keys from [Media Playlist]s\n/// to be specified in a [Master Playlist]. This allows the client to\n/// preload these keys without having to read the [Media Playlist]s\n/// first.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-SESSION-KEY:\u003cattribute-list\u003e\n/// ```\n///\n/// [Media Playlist]: crate::MediaPlaylist\n/// [Master Playlist]: crate::MasterPlaylist\n/// [4.3.4.5. EXT-X-SESSION-KEY]: https://tools.ietf.org/html/rfc8216#section-4.3.4.5\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ExtXSessionKey(DecryptionKey);\n\nimpl ExtXSessionKey {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-SESSION-KEY:\";\n\n    /// Makes a new [ExtXSessionKey] tag.\n    ///\n    /// # Panic\n    /// An [ExtXSessionKey] should only be used, if the segments of the stream are encrypted.\n    /// Therefore this function will panic, if the `method` is [EncryptionMethod::None].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXSessionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let session_key = ExtXSessionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    /// ```\n    pub fn new\u003cT: ToString\u003e(method: EncryptionMethod, uri: T) -\u003e Self {\n        if method == EncryptionMethod::None {\n            panic!(\"The EncryptionMethod is not allowed to be None\");\n        }\n\n        Self(DecryptionKey::new(method, uri))\n    }\n}\n\nimpl RequiredVersion for ExtXSessionKey {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        self.0.required_version()\n    }\n}\n\nimpl fmt::Display for ExtXSessionKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if self.0.method == EncryptionMethod::None {\n            return Err(fmt::Error);\n        }\n        write!(f, \"{}{}\", Self::PREFIX, self.0)\n    }\n}\n\nimpl FromStr for ExtXSessionKey {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n        Ok(Self(input.parse()?))\n    }\n}\n\nimpl Deref for ExtXSessionKey {\n    type Target = DecryptionKey;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for ExtXSessionKey {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::types::{EncryptionMethod, KeyFormat};\n\n    #[test]\n    fn test_display() {\n        let mut key = ExtXSessionKey::new(\n            EncryptionMethod::Aes128,\n            \"https://www.example.com/hls-key/key.bin\",\n        );\n        key.set_iv(Some([\n            16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n        ]));\n\n        assert_eq!(\n            key.to_string(),\n            \"#EXT-X-SESSION-KEY:METHOD=AES-128,\\\n             URI=\\\"https://www.example.com/hls-key/key.bin\\\",\\\n             IV=0x10ef8f758ca555115584bb5b3c687f52\"\n                .to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            r#\"#EXT-X-SESSION-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=52\"\"#\n                .parse::\u003cExtXSessionKey\u003e()\n                .unwrap(),\n            ExtXSessionKey::new(\n                EncryptionMethod::Aes128,\n                \"https://priv.example.com/key.php?r=52\"\n            )\n        );\n\n        let mut key = ExtXSessionKey::new(\n            EncryptionMethod::Aes128,\n            \"https://www.example.com/hls-key/key.bin\",\n        );\n        key.set_iv(Some([\n            16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n        ]));\n\n        assert_eq!(\n            \"#EXT-X-SESSION-KEY:METHOD=AES-128,\\\n             URI=\\\"https://www.example.com/hls-key/key.bin\\\",\\\n             IV=0X10ef8f758ca555115584bb5b3c687f52\"\n                .parse::\u003cExtXSessionKey\u003e()\n                .unwrap(),\n            key\n        );\n\n        key.set_key_format(Some(KeyFormat::Identity));\n\n        assert_eq!(\n            \"#EXT-X-SESSION-KEY:\\\n             METHOD=AES-128,\\\n             URI=\\\"https://www.example.com/hls-key/key.bin\\\",\\\n             IV=0x10ef8f758ca555115584bb5b3c687f52,\\\n             KEYFORMAT=\\\"identity\\\"\"\n                .parse::\u003cExtXSessionKey\u003e()\n                .unwrap(),\n            key\n        )\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXSessionKey::new(EncryptionMethod::Aes128, \"https://www.example.com/\")\n                .required_version(),\n            ProtocolVersion::V1\n        );\n    }\n\n    #[test]\n    #[should_panic]\n    // ExtXSessionKey::new should panic, if the provided\n    // EncryptionMethod is None!\n    fn test_new_panic() {\n        ExtXSessionKey::new(EncryptionMethod::None, \"\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_display_err() {\n        ExtXSessionKey(DecryptionKey::new(EncryptionMethod::None, \"\")).to_string();\n    }\n\n    #[test]\n    fn test_deref() {\n        let key = ExtXSessionKey::new(EncryptionMethod::Aes128, \"https://www.example.com/\");\n\n        assert_eq!(key.method(), EncryptionMethod::Aes128);\n        assert_eq!(key.uri(), \u0026Some(\"https://www.example.com/\".into()));\n    }\n\n    #[test]\n    fn test_deref_mut() {\n        let mut key = ExtXSessionKey::new(EncryptionMethod::Aes128, \"https://www.example.com/\");\n\n        key.set_method(EncryptionMethod::None);\n        assert_eq!(key.method(), EncryptionMethod::None);\n        key.set_uri(Some(\"https://www.github.com/\"));\n        assert_eq!(key.uri(), \u0026Some(\"https://www.github.com/\".into()));\n    }\n}\n","traces":[{"line":45,"address":null,"length":0,"stats":{"Line":2}},{"line":46,"address":null,"length":0,"stats":{"Line":2}},{"line":47,"address":null,"length":0,"stats":{"Line":1}},{"line":50,"address":null,"length":0,"stats":{"Line":2}},{"line":55,"address":4533232,"length":1,"stats":{"Line":1}},{"line":56,"address":4533241,"length":1,"stats":{"Line":1}},{"line":61,"address":4533280,"length":1,"stats":{"Line":1}},{"line":62,"address":4533297,"length":1,"stats":{"Line":1}},{"line":63,"address":4533443,"length":1,"stats":{"Line":1}},{"line":65,"address":4533351,"length":1,"stats":{"Line":1}},{"line":72,"address":4533632,"length":1,"stats":{"Line":1}},{"line":73,"address":4533659,"length":1,"stats":{"Line":1}},{"line":74,"address":4534129,"length":1,"stats":{"Line":1}},{"line":81,"address":4534864,"length":1,"stats":{"Line":1}},{"line":82,"address":4534869,"length":1,"stats":{"Line":1}},{"line":87,"address":4534880,"length":1,"stats":{"Line":1}},{"line":88,"address":4534885,"length":1,"stats":{"Line":1}},{"line":98,"address":4683200,"length":1,"stats":{"Line":2}},{"line":99,"address":5001606,"length":1,"stats":{"Line":1}},{"line":100,"address":5001598,"length":1,"stats":{"Line":1}},{"line":103,"address":5001654,"length":1,"stats":{"Line":1}},{"line":107,"address":5001908,"length":1,"stats":{"Line":1}},{"line":108,"address":5001866,"length":1,"stats":{"Line":1}},{"line":117,"address":4683232,"length":1,"stats":{"Line":2}},{"line":118,"address":5002564,"length":1,"stats":{"Line":0}},{"line":122,"address":5002529,"length":1,"stats":{"Line":1}},{"line":123,"address":5002521,"length":1,"stats":{"Line":1}},{"line":128,"address":5003090,"length":1,"stats":{"Line":1}},{"line":129,"address":5003082,"length":1,"stats":{"Line":1}},{"line":132,"address":5003127,"length":1,"stats":{"Line":1}},{"line":136,"address":5003393,"length":1,"stats":{"Line":1}},{"line":145,"address":5003832,"length":1,"stats":{"Line":1}},{"line":147,"address":5003948,"length":1,"stats":{"Line":1}},{"line":159,"address":4683269,"length":1,"stats":{"Line":1}},{"line":160,"address":4683264,"length":1,"stats":{"Line":2}},{"line":161,"address":5004654,"length":1,"stats":{"Line":1}},{"line":162,"address":5004574,"length":1,"stats":{"Line":1}},{"line":168,"address":4683301,"length":1,"stats":{"Line":1}},{"line":172,"address":4683296,"length":1,"stats":{"Line":2}},{"line":173,"address":5005112,"length":1,"stats":{"Line":1}},{"line":176,"address":4683333,"length":1,"stats":{"Line":1}},{"line":178,"address":4683328,"length":1,"stats":{"Line":2}},{"line":179,"address":5005179,"length":1,"stats":{"Line":1}},{"line":182,"address":4683365,"length":1,"stats":{"Line":1}},{"line":183,"address":4683360,"length":1,"stats":{"Line":2}},{"line":184,"address":5005390,"length":1,"stats":{"Line":1}},{"line":186,"address":5005452,"length":1,"stats":{"Line":1}},{"line":187,"address":5005620,"length":1,"stats":{"Line":1}},{"line":190,"address":4683397,"length":1,"stats":{"Line":1}},{"line":191,"address":4683392,"length":1,"stats":{"Line":2}},{"line":192,"address":5006558,"length":1,"stats":{"Line":1}},{"line":194,"address":5006620,"length":1,"stats":{"Line":1}},{"line":195,"address":5006689,"length":1,"stats":{"Line":1}},{"line":196,"address":5006854,"length":1,"stats":{"Line":1}},{"line":197,"address":5007234,"length":1,"stats":{"Line":1}}],"covered":54,"coverable":55},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","master_playlist","stream_inf.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{\n    ClosedCaptions, DecimalFloatingPoint, ProtocolVersion, RequiredVersion, StreamInf,\n};\nuse crate::utils::{quote, tag, unquote};\nuse crate::Error;\n\n/// [4.3.4.2. EXT-X-STREAM-INF]\n///\n/// [4.3.4.2. EXT-X-STREAM-INF]: https://tools.ietf.org/html/rfc8216#section-4.3.4.2\n#[derive(PartialOrd, Debug, Clone, PartialEq, Eq)]\npub struct ExtXStreamInf {\n    uri: String,\n    frame_rate: Option\u003cDecimalFloatingPoint\u003e,\n    audio: Option\u003cString\u003e,\n    subtitles: Option\u003cString\u003e,\n    closed_captions: Option\u003cClosedCaptions\u003e,\n    stream_inf: StreamInf,\n}\n\nimpl ExtXStreamInf {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-STREAM-INF:\";\n\n    /// Creates a new [ExtXStreamInf] tag.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::tags::ExtXStreamInf;\n    /// #\n    /// let stream = ExtXStreamInf::new(\"https://www.example.com/\", 20);\n    /// ```\n    pub fn new\u003cT: ToString\u003e(uri: T, bandwidth: u64) -\u003e Self {\n        ExtXStreamInf {\n            uri: uri.to_string(),\n            frame_rate: None,\n            audio: None,\n            subtitles: None,\n            closed_captions: None,\n            stream_inf: StreamInf::new(bandwidth),\n        }\n    }\n\n    /// Sets the `URI` that identifies the associated media playlist.\n    pub fn set_uri\u003cT: ToString\u003e(\u0026mut self, value: T) -\u003e \u0026mut Self {\n        self.uri = value.to_string();\n        self\n    }\n\n    /// Returns the `URI` that identifies the associated media playlist.\n    pub const fn uri(\u0026self) -\u003e \u0026String {\n        \u0026self.uri\n    }\n\n    /// Sets the maximum frame rate for all the video in the variant stream.\n    pub fn set_frame_rate(\u0026mut self, value: Option\u003cf64\u003e) -\u003e \u0026mut Self {\n        self.frame_rate = value.map(|v| (v as u32).into());\n        self\n    }\n\n    /// Returns the maximum frame rate for all the video in the variant stream.\n    pub fn frame_rate(\u0026self) -\u003e Option\u003cf64\u003e {\n        self.frame_rate.map(|v| v.as_f64())\n    }\n\n    /// Returns the group identifier for the audio in the variant stream.\n    pub fn audio(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.audio.as_ref()\n    }\n\n    /// Returns the group identifier for the subtitles in the variant stream.\n    pub fn subtitles(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.subtitles.as_ref()\n    }\n\n    /// Returns the value of `CLOSED-CAPTIONS` attribute.\n    pub fn closed_captions(\u0026self) -\u003e Option\u003c\u0026ClosedCaptions\u003e {\n        self.closed_captions.as_ref()\n    }\n}\n\nimpl RequiredVersion for ExtXStreamInf {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXStreamInf {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", Self::PREFIX, self.stream_inf)?;\n        if let Some(value) = \u0026self.frame_rate {\n            write!(f, \",FRAME-RATE={:.3}\", value.as_f64())?;\n        }\n        if let Some(value) = \u0026self.audio {\n            write!(f, \",AUDIO={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.subtitles {\n            write!(f, \",SUBTITLES={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.closed_captions {\n            write!(f, \",CLOSED-CAPTIONS={}\", value)?;\n        }\n        write!(f, \"\\n{}\", self.uri)?;\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXStreamInf {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut lines = input.lines();\n        let first_line = lines\n            .next()\n            .ok_or_else(|| Error::missing_value(\"first_line\"))?;\n        let uri = lines.next().ok_or_else(|| Error::missing_value(\"URI\"))?;\n\n        let input = tag(first_line, Self::PREFIX)?;\n\n        let mut frame_rate = None;\n        let mut audio = None;\n        let mut subtitles = None;\n        let mut closed_captions = None;\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"FRAME-RATE\" =\u003e frame_rate = Some((value.parse())?),\n                \"AUDIO\" =\u003e audio = Some(unquote(value)),\n                \"SUBTITLES\" =\u003e subtitles = Some(unquote(value)),\n                \"CLOSED-CAPTIONS\" =\u003e closed_captions = Some((value.parse())?),\n                _ =\u003e {}\n            }\n        }\n\n        Ok(Self {\n            uri: uri.to_string(),\n            frame_rate,\n            audio,\n            subtitles,\n            closed_captions,\n            stream_inf: input.parse()?,\n        })\n    }\n}\n\nimpl Deref for ExtXStreamInf {\n    type Target = StreamInf;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.stream_inf\n    }\n}\n\nimpl DerefMut for ExtXStreamInf {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.stream_inf\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parser() {\n        let stream_inf = \"#EXT-X-STREAM-INF:BANDWIDTH=1000\\nhttp://www.example.com\"\n            .parse::\u003cExtXStreamInf\u003e()\n            .unwrap();\n\n        assert_eq!(\n            stream_inf,\n            ExtXStreamInf::new(\"http://www.example.com\", 1000)\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ProtocolVersion::V1,\n            ExtXStreamInf::new(\"http://www.example.com\", 1000).required_version()\n        );\n    }\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXStreamInf::new(\"http://www.example.com/\", 1000).to_string(),\n            \"#EXT-X-STREAM-INF:BANDWIDTH=1000\\nhttp://www.example.com/\".to_string()\n        );\n    }\n}\n","traces":[{"line":36,"address":null,"length":0,"stats":{"Line":2}},{"line":38,"address":null,"length":0,"stats":{"Line":2}},{"line":43,"address":null,"length":0,"stats":{"Line":2}},{"line":48,"address":null,"length":0,"stats":{"Line":0}},{"line":49,"address":null,"length":0,"stats":{"Line":0}},{"line":50,"address":null,"length":0,"stats":{"Line":0}},{"line":54,"address":4322896,"length":1,"stats":{"Line":0}},{"line":55,"address":4322901,"length":1,"stats":{"Line":0}},{"line":59,"address":4322912,"length":1,"stats":{"Line":0}},{"line":60,"address":4236560,"length":1,"stats":{"Line":0}},{"line":61,"address":4322985,"length":1,"stats":{"Line":0}},{"line":65,"address":4323008,"length":1,"stats":{"Line":0}},{"line":66,"address":4236608,"length":1,"stats":{"Line":0}},{"line":70,"address":4323072,"length":1,"stats":{"Line":1}},{"line":71,"address":4323081,"length":1,"stats":{"Line":1}},{"line":75,"address":4323120,"length":1,"stats":{"Line":1}},{"line":76,"address":4323129,"length":1,"stats":{"Line":1}},{"line":80,"address":4323168,"length":1,"stats":{"Line":1}},{"line":81,"address":4323177,"length":1,"stats":{"Line":1}},{"line":86,"address":4323216,"length":1,"stats":{"Line":1}},{"line":87,"address":4323224,"length":1,"stats":{"Line":1}},{"line":92,"address":4323248,"length":1,"stats":{"Line":1}},{"line":93,"address":4323285,"length":1,"stats":{"Line":1}},{"line":94,"address":4323691,"length":1,"stats":{"Line":1}},{"line":95,"address":4323753,"length":1,"stats":{"Line":0}},{"line":97,"address":4324106,"length":1,"stats":{"Line":1}},{"line":98,"address":4324176,"length":1,"stats":{"Line":0}},{"line":100,"address":4324580,"length":1,"stats":{"Line":1}},{"line":101,"address":4324650,"length":1,"stats":{"Line":0}},{"line":103,"address":4325014,"length":1,"stats":{"Line":1}},{"line":104,"address":4325083,"length":1,"stats":{"Line":0}},{"line":106,"address":4325335,"length":1,"stats":{"Line":1}},{"line":107,"address":4325592,"length":1,"stats":{"Line":1}},{"line":114,"address":4325648,"length":1,"stats":{"Line":1}},{"line":115,"address":4325680,"length":1,"stats":{"Line":1}},{"line":116,"address":4325833,"length":1,"stats":{"Line":1}},{"line":117,"address":null,"length":0,"stats":{"Line":0}},{"line":118,"address":4236656,"length":1,"stats":{"Line":1}},{"line":119,"address":4236704,"length":1,"stats":{"Line":1}},{"line":121,"address":4326908,"length":1,"stats":{"Line":1}},{"line":123,"address":4327408,"length":1,"stats":{"Line":1}},{"line":124,"address":4327420,"length":1,"stats":{"Line":1}},{"line":125,"address":4327432,"length":1,"stats":{"Line":1}},{"line":126,"address":4327444,"length":1,"stats":{"Line":1}},{"line":128,"address":4327456,"length":1,"stats":{"Line":1}},{"line":129,"address":4328494,"length":1,"stats":{"Line":1}},{"line":130,"address":4328515,"length":1,"stats":{"Line":1}},{"line":131,"address":4328604,"length":1,"stats":{"Line":0}},{"line":132,"address":4328670,"length":1,"stats":{"Line":0}},{"line":133,"address":4328744,"length":1,"stats":{"Line":0}},{"line":134,"address":null,"length":0,"stats":{"Line":0}},{"line":138,"address":4331332,"length":1,"stats":{"Line":1}},{"line":139,"address":4332957,"length":1,"stats":{"Line":1}},{"line":140,"address":4330291,"length":1,"stats":{"Line":1}},{"line":141,"address":4330308,"length":1,"stats":{"Line":1}},{"line":142,"address":4330340,"length":1,"stats":{"Line":1}},{"line":143,"address":4330372,"length":1,"stats":{"Line":1}},{"line":144,"address":4330404,"length":1,"stats":{"Line":1}},{"line":152,"address":4333696,"length":1,"stats":{"Line":1}},{"line":153,"address":4333701,"length":1,"stats":{"Line":1}},{"line":158,"address":4333728,"length":1,"stats":{"Line":0}},{"line":159,"address":4333733,"length":1,"stats":{"Line":0}},{"line":168,"address":4446816,"length":1,"stats":{"Line":2}},{"line":169,"address":4446830,"length":1,"stats":{"Line":1}},{"line":173,"address":4446923,"length":1,"stats":{"Line":1}},{"line":175,"address":4446886,"length":1,"stats":{"Line":1}},{"line":180,"address":4447440,"length":1,"stats":{"Line":2}},{"line":181,"address":4447518,"length":1,"stats":{"Line":1}},{"line":183,"address":4447454,"length":1,"stats":{"Line":1}},{"line":188,"address":4447968,"length":1,"stats":{"Line":2}},{"line":189,"address":4448066,"length":1,"stats":{"Line":0}},{"line":190,"address":4447982,"length":1,"stats":{"Line":1}},{"line":191,"address":4448039,"length":1,"stats":{"Line":1}}],"covered":51,"coverable":73},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_playlist","discontinuity_sequence.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\n\n/// # [4.4.3.3. EXT-X-DISCONTINUITY-SEQUENCE]\n///\n/// The [ExtXDiscontinuitySequence] tag allows synchronization between\n/// different Renditions of the same Variant Stream or different Variant\n/// Streams that have [ExtXDiscontinuity] tags in their [Media Playlist]s.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-DISCONTINUITY-SEQUENCE:\u003cnumber\u003e\n/// ```\n/// where `number` is a [u64].\n///\n/// [ExtXDiscontinuity]: crate::tags::ExtXDiscontinuity\n/// [Media Playlist]: crate::MediaPlaylist\n/// [4.4.3.3. EXT-X-DISCONTINUITY-SEQUENCE]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.3\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\npub struct ExtXDiscontinuitySequence(u64);\n\nimpl ExtXDiscontinuitySequence {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-DISCONTINUITY-SEQUENCE:\";\n\n    /// Makes a new [ExtXDiscontinuitySequence] tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXDiscontinuitySequence;\n    /// let discontinuity_sequence = ExtXDiscontinuitySequence::new(5);\n    /// ```\n    pub const fn new(seq_num: u64) -\u003e Self {\n        Self(seq_num)\n    }\n\n    /// Returns the discontinuity sequence number of\n    /// the first media segment that appears in the associated playlist.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXDiscontinuitySequence;\n    /// let discontinuity_sequence = ExtXDiscontinuitySequence::new(5);\n    ///\n    /// assert_eq!(discontinuity_sequence.seq_num(), 5);\n    /// ```\n    pub const fn seq_num(self) -\u003e u64 {\n        self.0\n    }\n\n    /// Sets the sequence number.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXDiscontinuitySequence;\n    /// let mut discontinuity_sequence = ExtXDiscontinuitySequence::new(5);\n    ///\n    /// discontinuity_sequence.set_seq_num(10);\n    /// assert_eq!(discontinuity_sequence.seq_num(), 10);\n    /// ```\n    pub fn set_seq_num(\u0026mut self, value: u64) -\u003e \u0026mut Self {\n        self.0 = value;\n        self\n    }\n}\n\nimpl RequiredVersion for ExtXDiscontinuitySequence {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXDiscontinuitySequence {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", Self::PREFIX, self.0)\n    }\n}\n\nimpl FromStr for ExtXDiscontinuitySequence {\n    type Err = crate::Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let seq_num = tag(input, Self::PREFIX)?.parse()?;\n        Ok(Self::new(seq_num))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXDiscontinuitySequence::new(123).to_string(),\n            \"#EXT-X-DISCONTINUITY-SEQUENCE:123\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXDiscontinuitySequence::new(123).required_version(),\n            ProtocolVersion::V1\n        )\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ExtXDiscontinuitySequence::new(123),\n            \"#EXT-X-DISCONTINUITY-SEQUENCE:123\".parse().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_seq_num() {\n        let mut sequence = ExtXDiscontinuitySequence::new(123);\n        assert_eq!(sequence.seq_num(), 123);\n        sequence.set_seq_num(1);\n        assert_eq!(sequence.seq_num(), 1);\n    }\n}\n","traces":[{"line":36,"address":4211824,"length":1,"stats":{"Line":4}},{"line":37,"address":4211832,"length":1,"stats":{"Line":4}},{"line":50,"address":4211856,"length":1,"stats":{"Line":3}},{"line":51,"address":4211861,"length":1,"stats":{"Line":3}},{"line":64,"address":4211872,"length":1,"stats":{"Line":2}},{"line":65,"address":4211885,"length":1,"stats":{"Line":2}},{"line":66,"address":4211897,"length":1,"stats":{"Line":2}},{"line":71,"address":4211920,"length":1,"stats":{"Line":1}},{"line":72,"address":4211928,"length":1,"stats":{"Line":1}},{"line":77,"address":4211952,"length":1,"stats":{"Line":1}},{"line":78,"address":4211983,"length":1,"stats":{"Line":1}},{"line":85,"address":4212240,"length":1,"stats":{"Line":1}},{"line":86,"address":4212267,"length":1,"stats":{"Line":1}},{"line":87,"address":4212921,"length":1,"stats":{"Line":1}},{"line":96,"address":4359616,"length":1,"stats":{"Line":2}},{"line":97,"address":4791267,"length":1,"stats":{"Line":1}},{"line":98,"address":4791191,"length":1,"stats":{"Line":1}},{"line":99,"address":4791238,"length":1,"stats":{"Line":1}},{"line":104,"address":4359648,"length":1,"stats":{"Line":2}},{"line":105,"address":4791796,"length":1,"stats":{"Line":1}},{"line":106,"address":4791767,"length":1,"stats":{"Line":1}},{"line":112,"address":4359680,"length":1,"stats":{"Line":2}},{"line":113,"address":4792206,"length":1,"stats":{"Line":1}},{"line":114,"address":4792151,"length":1,"stats":{"Line":1}},{"line":115,"address":4792173,"length":1,"stats":{"Line":1}},{"line":120,"address":4359712,"length":1,"stats":{"Line":2}},{"line":121,"address":4792583,"length":1,"stats":{"Line":1}},{"line":122,"address":4792598,"length":1,"stats":{"Line":1}},{"line":123,"address":4792682,"length":1,"stats":{"Line":1}},{"line":124,"address":4792969,"length":1,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_playlist","end_list.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.3.4. EXT-X-ENDLIST]\n/// The [ExtXEndList] tag indicates, that no more [Media Segment]s will be\n/// added to the [Media Playlist] file.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-ENDLIST\n/// ```\n///\n/// [Media Segment]: crate::MediaSegment\n/// [Media Playlist]: crate::MediaPlaylist\n/// [4.4.3.4. EXT-X-ENDLIST]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.4\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ExtXEndList;\n\nimpl ExtXEndList {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-ENDLIST\";\n}\n\nimpl RequiredVersion for ExtXEndList {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXEndList {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Self::PREFIX.fmt(f)\n    }\n}\n\nimpl FromStr for ExtXEndList {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        tag(input, Self::PREFIX)?;\n        Ok(ExtXEndList)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(ExtXEndList.to_string(), \"#EXT-X-ENDLIST\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(ExtXEndList, \"#EXT-X-ENDLIST\".parse().unwrap());\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(ExtXEndList.required_version(), ProtocolVersion::V1);\n    }\n}\n","traces":[{"line":29,"address":4289600,"length":1,"stats":{"Line":3}},{"line":30,"address":4289608,"length":1,"stats":{"Line":3}},{"line":35,"address":4289632,"length":1,"stats":{"Line":1}},{"line":36,"address":4289653,"length":1,"stats":{"Line":1}},{"line":43,"address":4289696,"length":1,"stats":{"Line":3}},{"line":44,"address":4289723,"length":1,"stats":{"Line":3}},{"line":45,"address":4290154,"length":1,"stats":{"Line":3}},{"line":54,"address":4657584,"length":1,"stats":{"Line":2}},{"line":55,"address":4657591,"length":1,"stats":{"Line":1}},{"line":59,"address":4658128,"length":1,"stats":{"Line":2}},{"line":60,"address":4658142,"length":1,"stats":{"Line":1}},{"line":64,"address":4658544,"length":1,"stats":{"Line":2}},{"line":65,"address":4658551,"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_playlist","i_frames_only.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.3.6. EXT-X-I-FRAMES-ONLY]\n/// The [ExtXIFramesOnly] tag indicates that each [Media Segment] in the\n/// Playlist describes a single I-frame. I-frames are encoded video\n/// frames, whose decoding does not depend on any other frame. I-frame\n/// Playlists can be used for trick play, such as fast forward, rapid\n/// reverse, and scrubbing.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-I-FRAMES-ONLY\n/// ```\n///\n/// [Media Segment]: crate::MediaSegment\n/// [4.4.3.6. EXT-X-I-FRAMES-ONLY]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.6\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ExtXIFramesOnly;\n\nimpl ExtXIFramesOnly {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-I-FRAMES-ONLY\";\n}\n\nimpl RequiredVersion for ExtXIFramesOnly {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V4\n    }\n}\n\nimpl fmt::Display for ExtXIFramesOnly {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Self::PREFIX.fmt(f)\n    }\n}\n\nimpl FromStr for ExtXIFramesOnly {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        tag(input, Self::PREFIX)?;\n        Ok(ExtXIFramesOnly)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXIFramesOnly.to_string(),\n            \"#EXT-X-I-FRAMES-ONLY\".to_string(),\n        )\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(ExtXIFramesOnly, \"#EXT-X-I-FRAMES-ONLY\".parse().unwrap(),)\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(ExtXIFramesOnly.required_version(), ProtocolVersion::V4)\n    }\n}\n","traces":[{"line":31,"address":4460928,"length":1,"stats":{"Line":1}},{"line":32,"address":4460936,"length":1,"stats":{"Line":1}},{"line":37,"address":4460960,"length":1,"stats":{"Line":1}},{"line":38,"address":4460981,"length":1,"stats":{"Line":1}},{"line":45,"address":4461024,"length":1,"stats":{"Line":1}},{"line":46,"address":4461051,"length":1,"stats":{"Line":1}},{"line":47,"address":4461482,"length":1,"stats":{"Line":1}},{"line":56,"address":5241424,"length":1,"stats":{"Line":2}},{"line":57,"address":5241492,"length":1,"stats":{"Line":1}},{"line":58,"address":5241431,"length":1,"stats":{"Line":1}},{"line":59,"address":5241463,"length":1,"stats":{"Line":1}},{"line":64,"address":5241968,"length":1,"stats":{"Line":2}},{"line":65,"address":5241982,"length":1,"stats":{"Line":1}},{"line":69,"address":5242384,"length":1,"stats":{"Line":2}},{"line":70,"address":5242391,"length":1,"stats":{"Line":1}}],"covered":15,"coverable":15},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_playlist","media_sequence.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.3.2. EXT-X-MEDIA-SEQUENCE]\n/// The [ExtXMediaSequence] tag indicates the Media Sequence Number of\n/// the first [Media Segment] that appears in a Playlist file.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-MEDIA-SEQUENCE:\u003cnumber\u003e\n/// ```\n/// where `number` is a [u64].\n///\n/// [Media Segment]: crate::MediaSegment\n/// [4.4.3.2. EXT-X-MEDIA-SEQUENCE]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.2\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\npub struct ExtXMediaSequence(u64);\n\nimpl ExtXMediaSequence {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-MEDIA-SEQUENCE:\";\n\n    /// Makes a new [ExtXMediaSequence] tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMediaSequence;\n    /// let media_sequence = ExtXMediaSequence::new(5);\n    /// ```\n    pub const fn new(seq_num: u64) -\u003e Self {\n        Self(seq_num)\n    }\n\n    /// Returns the sequence number of the first media segment,\n    /// that appears in the associated playlist.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMediaSequence;\n    /// let media_sequence = ExtXMediaSequence::new(5);\n    ///\n    /// assert_eq!(media_sequence.seq_num(), 5);\n    /// ```\n    pub const fn seq_num(self) -\u003e u64 {\n        self.0\n    }\n\n    /// Sets the sequence number.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXMediaSequence;\n    /// let mut media_sequence = ExtXMediaSequence::new(5);\n    ///\n    /// media_sequence.set_seq_num(10);\n    /// assert_eq!(media_sequence.seq_num(), 10);\n    /// ```\n    pub fn set_seq_num(\u0026mut self, value: u64) -\u003e \u0026mut Self {\n        self.0 = value;\n        self\n    }\n}\n\nimpl RequiredVersion for ExtXMediaSequence {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXMediaSequence {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", Self::PREFIX, self.0)\n    }\n}\n\nimpl FromStr for ExtXMediaSequence {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let seq_num = tag(input, Self::PREFIX)?.parse()?;\n        Ok(ExtXMediaSequence::new(seq_num))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXMediaSequence::new(123).to_string(),\n            \"#EXT-X-MEDIA-SEQUENCE:123\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXMediaSequence::new(123).required_version(),\n            ProtocolVersion::V1\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ExtXMediaSequence::new(123),\n            \"#EXT-X-MEDIA-SEQUENCE:123\".parse().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_seq_num() {\n        let mut sequence = ExtXMediaSequence::new(123);\n        assert_eq!(sequence.seq_num(), 123);\n        sequence.set_seq_num(1);\n        assert_eq!(sequence.seq_num(), 1);\n    }\n}\n","traces":[{"line":34,"address":4211824,"length":1,"stats":{"Line":4}},{"line":35,"address":4211832,"length":1,"stats":{"Line":4}},{"line":48,"address":4211856,"length":1,"stats":{"Line":3}},{"line":49,"address":4211861,"length":1,"stats":{"Line":3}},{"line":62,"address":4211872,"length":1,"stats":{"Line":2}},{"line":63,"address":4211885,"length":1,"stats":{"Line":2}},{"line":64,"address":4211897,"length":1,"stats":{"Line":2}},{"line":69,"address":4211920,"length":1,"stats":{"Line":1}},{"line":70,"address":4211928,"length":1,"stats":{"Line":1}},{"line":75,"address":4211952,"length":1,"stats":{"Line":1}},{"line":76,"address":4211983,"length":1,"stats":{"Line":1}},{"line":83,"address":4212240,"length":1,"stats":{"Line":1}},{"line":84,"address":4212267,"length":1,"stats":{"Line":1}},{"line":85,"address":4212921,"length":1,"stats":{"Line":1}},{"line":94,"address":4446688,"length":1,"stats":{"Line":2}},{"line":95,"address":4896755,"length":1,"stats":{"Line":1}},{"line":96,"address":4896679,"length":1,"stats":{"Line":1}},{"line":97,"address":4896726,"length":1,"stats":{"Line":1}},{"line":102,"address":4446720,"length":1,"stats":{"Line":2}},{"line":103,"address":4897284,"length":1,"stats":{"Line":1}},{"line":104,"address":4897255,"length":1,"stats":{"Line":1}},{"line":110,"address":4446752,"length":1,"stats":{"Line":2}},{"line":111,"address":4897694,"length":1,"stats":{"Line":1}},{"line":112,"address":4897639,"length":1,"stats":{"Line":1}},{"line":113,"address":4897661,"length":1,"stats":{"Line":1}},{"line":118,"address":4446784,"length":1,"stats":{"Line":2}},{"line":119,"address":4898071,"length":1,"stats":{"Line":1}},{"line":120,"address":4898086,"length":1,"stats":{"Line":1}},{"line":121,"address":4898170,"length":1,"stats":{"Line":1}},{"line":122,"address":4898457,"length":1,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_playlist","playlist_type.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.3.5. EXT-X-PLAYLIST-TYPE]\n///\n/// The [ExtXPlaylistType] tag provides mutability information about the\n/// [Media Playlist]. It applies to the entire [Media Playlist].\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-PLAYLIST-TYPE:\u003ctype-enum\u003e\n/// ```\n///\n/// [Media Playlist]: crate::MediaPlaylist\n/// [4.4.3.5. EXT-X-PLAYLIST-TYPE]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.5\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum ExtXPlaylistType {\n    /// If the [ExtXPlaylistType] is Event, Media Segments can only be added to\n    /// the end of the Media Playlist.\n    Event,\n    /// If the [ExtXPlaylistType] is Video On Demand (Vod),\n    /// the Media Playlist cannot change.\n    Vod,\n}\n\nimpl ExtXPlaylistType {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-PLAYLIST-TYPE:\";\n}\n\nimpl RequiredVersion for ExtXPlaylistType {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXPlaylistType {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match \u0026self {\n            Self::Event =\u003e write!(f, \"{}EVENT\", Self::PREFIX),\n            Self::Vod =\u003e write!(f, \"{}VOD\", Self::PREFIX),\n        }\n    }\n}\n\nimpl FromStr for ExtXPlaylistType {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n        match input {\n            \"EVENT\" =\u003e Ok(Self::Event),\n            \"VOD\" =\u003e Ok(Self::Vod),\n            _ =\u003e Err(Error::custom(format!(\"Unknown playlist type: {:?}\", input))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            \"#EXT-X-PLAYLIST-TYPE:VOD\"\n                .parse::\u003cExtXPlaylistType\u003e()\n                .unwrap(),\n            ExtXPlaylistType::Vod,\n        );\n\n        assert_eq!(\n            \"#EXT-X-PLAYLIST-TYPE:EVENT\"\n                .parse::\u003cExtXPlaylistType\u003e()\n                .unwrap(),\n            ExtXPlaylistType::Event,\n        );\n\n        assert!(\"#EXT-X-PLAYLIST-TYPE:H\"\n            .parse::\u003cExtXPlaylistType\u003e()\n            .is_err());\n    }\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            \"#EXT-X-PLAYLIST-TYPE:VOD\".to_string(),\n            ExtXPlaylistType::Vod.to_string(),\n        );\n\n        assert_eq!(\n            \"#EXT-X-PLAYLIST-TYPE:EVENT\".to_string(),\n            ExtXPlaylistType::Event.to_string(),\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXPlaylistType::Vod.required_version(),\n            ProtocolVersion::V1\n        );\n        assert_eq!(\n            ExtXPlaylistType::Event.required_version(),\n            ProtocolVersion::V1\n        );\n    }\n}\n","traces":[{"line":36,"address":4287808,"length":1,"stats":{"Line":1}},{"line":37,"address":4287816,"length":1,"stats":{"Line":1}},{"line":42,"address":4287840,"length":1,"stats":{"Line":1}},{"line":43,"address":4287953,"length":1,"stats":{"Line":0}},{"line":44,"address":4287857,"length":1,"stats":{"Line":1}},{"line":45,"address":4287887,"length":1,"stats":{"Line":1}},{"line":53,"address":4288256,"length":1,"stats":{"Line":1}},{"line":54,"address":4288283,"length":1,"stats":{"Line":1}},{"line":55,"address":4288823,"length":1,"stats":{"Line":1}},{"line":56,"address":4288763,"length":1,"stats":{"Line":1}},{"line":57,"address":4288828,"length":1,"stats":{"Line":1}},{"line":58,"address":4288868,"length":1,"stats":{"Line":1}},{"line":68,"address":4366768,"length":1,"stats":{"Line":2}},{"line":69,"address":4366833,"length":1,"stats":{"Line":1}},{"line":76,"address":4367250,"length":1,"stats":{"Line":1}},{"line":83,"address":4367355,"length":1,"stats":{"Line":1}},{"line":89,"address":4367792,"length":1,"stats":{"Line":2}},{"line":90,"address":4367874,"length":1,"stats":{"Line":1}},{"line":91,"address":4367806,"length":1,"stats":{"Line":1}},{"line":92,"address":4367844,"length":1,"stats":{"Line":1}},{"line":95,"address":4368387,"length":1,"stats":{"Line":1}},{"line":96,"address":4368336,"length":1,"stats":{"Line":1}},{"line":97,"address":4368357,"length":1,"stats":{"Line":1}},{"line":102,"address":4368944,"length":1,"stats":{"Line":2}},{"line":103,"address":4368967,"length":1,"stats":{"Line":1}},{"line":104,"address":4368951,"length":1,"stats":{"Line":1}},{"line":107,"address":4369335,"length":1,"stats":{"Line":1}},{"line":108,"address":4369038,"length":1,"stats":{"Line":1}}],"covered":27,"coverable":28},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_playlist","target_duration.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\nuse std::time::Duration;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.3.1. EXT-X-TARGETDURATION]\n/// The [ExtXTargetDuration] tag specifies the maximum [Media Segment]\n/// duration.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-TARGETDURATION:\u003cs\u003e\n/// ```\n/// where `s` is the target [Duration] in seconds.\n///\n/// [Media Segment]: crate::MediaSegment\n/// [4.4.3.1. EXT-X-TARGETDURATION]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.1\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]\npub struct ExtXTargetDuration(Duration);\n\nimpl ExtXTargetDuration {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-TARGETDURATION:\";\n\n    /// Makes a new [ExtXTargetduration] tag.\n    ///\n    /// # Note\n    /// The nanoseconds part of the [Duration] will be discarded.\n    pub const fn new(duration: Duration) -\u003e Self {\n        // TOOD: round instead of discarding?\n        Self(Duration::from_secs(duration.as_secs()))\n    }\n\n    /// Returns the maximum media segment duration in the associated playlist.\n    pub const fn duration(\u0026self) -\u003e Duration {\n        self.0\n    }\n}\n\nimpl RequiredVersion for ExtXTargetDuration {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXTargetDuration {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", Self::PREFIX, self.0.as_secs())\n    }\n}\n\nimpl FromStr for ExtXTargetDuration {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?.parse()?;\n        Ok(Self::new(Duration::from_secs(input)))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXTargetDuration::new(Duration::from_secs(5)).to_string(),\n            \"#EXT-X-TARGETDURATION:5\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXTargetDuration::new(Duration::from_secs(5)).required_version(),\n            ProtocolVersion::V1\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ExtXTargetDuration::new(Duration::from_secs(5)),\n            \"#EXT-X-TARGETDURATION:5\".parse().unwrap()\n        );\n    }\n}\n","traces":[{"line":32,"address":4315088,"length":1,"stats":{"Line":3}},{"line":34,"address":4315101,"length":1,"stats":{"Line":3}},{"line":38,"address":4315168,"length":1,"stats":{"Line":3}},{"line":39,"address":4315173,"length":1,"stats":{"Line":3}},{"line":44,"address":4315200,"length":1,"stats":{"Line":3}},{"line":45,"address":4315208,"length":1,"stats":{"Line":3}},{"line":50,"address":4315232,"length":1,"stats":{"Line":1}},{"line":51,"address":4315249,"length":1,"stats":{"Line":1}},{"line":58,"address":4315536,"length":1,"stats":{"Line":3}},{"line":59,"address":4315563,"length":1,"stats":{"Line":3}},{"line":60,"address":4316200,"length":1,"stats":{"Line":3}},{"line":69,"address":4556560,"length":1,"stats":{"Line":2}},{"line":70,"address":4556673,"length":1,"stats":{"Line":1}},{"line":71,"address":4556567,"length":1,"stats":{"Line":1}},{"line":72,"address":4556641,"length":1,"stats":{"Line":1}},{"line":77,"address":4557168,"length":1,"stats":{"Line":2}},{"line":78,"address":4557231,"length":1,"stats":{"Line":1}},{"line":79,"address":4557175,"length":1,"stats":{"Line":1}},{"line":85,"address":4557584,"length":1,"stats":{"Line":2}},{"line":86,"address":4557677,"length":1,"stats":{"Line":1}},{"line":87,"address":4557591,"length":1,"stats":{"Line":1}},{"line":88,"address":4557640,"length":1,"stats":{"Line":1}}],"covered":22,"coverable":22},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_segment","byte_range.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::types::{ByteRange, ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.2.2. EXT-X-BYTERANGE]\n///\n/// The [ExtXByteRange] tag indicates that a [Media Segment] is a sub-range\n/// of the resource identified by its `URI`.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-BYTERANGE:\u003cn\u003e[@\u003co\u003e]\n/// ```\n///\n/// where `n` is a [usize] indicating the length of the sub-range in bytes.\n/// If present, `o` is a [usize] indicating the start of the sub-range,\n/// as a byte offset from the beginning of the resource.\n///\n/// [Media Segment]: crate::MediaSegment\n/// [4.4.2.2. EXT-X-BYTERANGE]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.2.2\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ExtXByteRange(ByteRange);\n\nimpl ExtXByteRange {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-BYTERANGE:\";\n\n    /// Makes a new [ExtXByteRange] tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXByteRange;\n    /// let byte_range = ExtXByteRange::new(20, Some(5));\n    /// ```\n    pub const fn new(length: usize, start: Option\u003cusize\u003e) -\u003e Self {\n        Self(ByteRange::new(length, start))\n    }\n\n    /// Converts the [ExtXByteRange] to a [ByteRange].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXByteRange;\n    /// use hls_m3u8::types::ByteRange;\n    ///\n    /// let byte_range = ExtXByteRange::new(20, Some(5));\n    /// let range: ByteRange = byte_range.to_range();\n    /// ```\n    pub const fn to_range(\u0026self) -\u003e ByteRange {\n        self.0\n    }\n}\n\nimpl RequiredVersion for ExtXByteRange {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V4\n    }\n}\n\nimpl Deref for ExtXByteRange {\n    type Target = ByteRange;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for ExtXByteRange {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\nimpl fmt::Display for ExtXByteRange {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n        write!(f, \"{}\", self.0)?;\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXByteRange {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let tokens = input.splitn(2, '@').collect::\u003cVec\u003c_\u003e\u003e();\n\n        if tokens.is_empty() {\n            return Err(Error::invalid_input());\n        }\n\n        let length = tokens[0].parse()?;\n\n        let start = {\n            if tokens.len() == 2 {\n                Some(tokens[1].parse()?)\n            } else {\n                None\n            }\n        };\n\n        Ok(ExtXByteRange::new(length, start))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let byte_range = ExtXByteRange::new(0, Some(5));\n        assert_eq!(byte_range.to_string(), \"#EXT-X-BYTERANGE:0@5\".to_string());\n\n        let byte_range = ExtXByteRange::new(99999, Some(2));\n        assert_eq!(\n            byte_range.to_string(),\n            \"#EXT-X-BYTERANGE:99999@2\".to_string()\n        );\n\n        let byte_range = ExtXByteRange::new(99999, None);\n        assert_eq!(byte_range.to_string(), \"#EXT-X-BYTERANGE:99999\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        let byte_range = ExtXByteRange::new(99999, Some(2));\n        assert_eq!(\n            byte_range,\n            \"#EXT-X-BYTERANGE:99999@2\".parse::\u003cExtXByteRange\u003e().unwrap()\n        );\n\n        let byte_range = ExtXByteRange::new(99999, None);\n        assert_eq!(\n            byte_range,\n            \"#EXT-X-BYTERANGE:99999\".parse::\u003cExtXByteRange\u003e().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_deref() {\n        let byte_range = ExtXByteRange::new(0, Some(22));\n\n        assert_eq!(byte_range.length(), 0);\n        assert_eq!(byte_range.start(), Some(22));\n    }\n\n    #[test]\n    fn test_deref_mut() {\n        let mut byte_range = ExtXByteRange::new(0, Some(22));\n\n        byte_range.set_length(100);\n        byte_range.set_start(Some(50));\n\n        assert_eq!(byte_range.length(), 100);\n        assert_eq!(byte_range.start(), Some(50));\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXByteRange::new(20, Some(5)).required_version(),\n            ProtocolVersion::V4\n        );\n    }\n}\n","traces":[{"line":39,"address":4211856,"length":1,"stats":{"Line":3}},{"line":40,"address":4211878,"length":1,"stats":{"Line":3}},{"line":53,"address":4211968,"length":1,"stats":{"Line":1}},{"line":54,"address":4211976,"length":1,"stats":{"Line":1}},{"line":59,"address":4212016,"length":1,"stats":{"Line":1}},{"line":60,"address":4212024,"length":1,"stats":{"Line":1}},{"line":67,"address":4212048,"length":1,"stats":{"Line":1}},{"line":68,"address":4212053,"length":1,"stats":{"Line":1}},{"line":73,"address":4212064,"length":1,"stats":{"Line":1}},{"line":74,"address":4212069,"length":1,"stats":{"Line":1}},{"line":79,"address":4212080,"length":1,"stats":{"Line":1}},{"line":80,"address":4212111,"length":1,"stats":{"Line":1}},{"line":81,"address":4212361,"length":1,"stats":{"Line":1}},{"line":82,"address":4212602,"length":1,"stats":{"Line":1}},{"line":89,"address":4212624,"length":1,"stats":{"Line":1}},{"line":90,"address":4212651,"length":1,"stats":{"Line":1}},{"line":92,"address":4213123,"length":1,"stats":{"Line":1}},{"line":94,"address":4213180,"length":1,"stats":{"Line":1}},{"line":95,"address":4213268,"length":1,"stats":{"Line":0}},{"line":98,"address":4213232,"length":1,"stats":{"Line":1}},{"line":100,"address":null,"length":0,"stats":{"Line":0}},{"line":101,"address":4213524,"length":1,"stats":{"Line":1}},{"line":102,"address":4213576,"length":1,"stats":{"Line":1}},{"line":104,"address":4213559,"length":1,"stats":{"Line":1}},{"line":108,"address":4213796,"length":1,"stats":{"Line":1}},{"line":117,"address":4476544,"length":1,"stats":{"Line":2}},{"line":118,"address":5198987,"length":1,"stats":{"Line":1}},{"line":119,"address":5199057,"length":1,"stats":{"Line":1}},{"line":121,"address":5199610,"length":1,"stats":{"Line":1}},{"line":122,"address":5199724,"length":1,"stats":{"Line":1}},{"line":123,"address":5199668,"length":1,"stats":{"Line":1}},{"line":124,"address":5199689,"length":1,"stats":{"Line":1}},{"line":127,"address":5200185,"length":1,"stats":{"Line":1}},{"line":128,"address":5200231,"length":1,"stats":{"Line":1}},{"line":132,"address":4476576,"length":1,"stats":{"Line":2}},{"line":133,"address":5200887,"length":1,"stats":{"Line":1}},{"line":134,"address":5200979,"length":1,"stats":{"Line":1}},{"line":136,"address":5200937,"length":1,"stats":{"Line":1}},{"line":139,"address":5201075,"length":1,"stats":{"Line":1}},{"line":140,"address":5201454,"length":1,"stats":{"Line":1}},{"line":142,"address":5201412,"length":1,"stats":{"Line":1}},{"line":147,"address":4476608,"length":1,"stats":{"Line":2}},{"line":148,"address":5201851,"length":1,"stats":{"Line":1}},{"line":150,"address":5201889,"length":1,"stats":{"Line":1}},{"line":151,"address":5202018,"length":1,"stats":{"Line":1}},{"line":155,"address":4476640,"length":1,"stats":{"Line":2}},{"line":156,"address":5202747,"length":1,"stats":{"Line":1}},{"line":158,"address":5202797,"length":1,"stats":{"Line":1}},{"line":159,"address":5202827,"length":1,"stats":{"Line":1}},{"line":161,"address":5202892,"length":1,"stats":{"Line":1}},{"line":162,"address":5203021,"length":1,"stats":{"Line":1}},{"line":166,"address":4476672,"length":1,"stats":{"Line":2}},{"line":167,"address":5203808,"length":1,"stats":{"Line":1}},{"line":168,"address":5203751,"length":1,"stats":{"Line":1}}],"covered":52,"coverable":54},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_segment","date_range.rs"],"content":"use std::collections::BTreeMap;\nuse std::fmt;\nuse std::str::FromStr;\nuse std::time::Duration;\n\nuse chrono::{DateTime, FixedOffset};\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::{quote, tag, unquote};\nuse crate::Error;\n\n/// [4.3.2.7. EXT-X-DATERANGE]\n///\n/// [4.3.2.7. EXT-X-DATERANGE]: https://tools.ietf.org/html/rfc8216#section-4.3.2.7\n///\n/// TODO: Implement properly\n#[allow(missing_docs)]\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ExtXDateRange {\n    /// A string that uniquely identifies a [ExtXDateRange] in the Playlist.\n    /// This attribute is required.\n    id: String,\n    /// A client-defined string that specifies some set of attributes and their associated value\n    /// semantics. All Date Ranges with the same CLASS attribute value MUST adhere to these\n    /// semantics. This attribute is OPTIONAL.\n    class: Option\u003cString\u003e,\n    /// The date at which the Date Range begins. This attribute is REQUIRED.\n    start_date: DateTime\u003cFixedOffset\u003e,\n    /// The date at which the Date Range ends. It MUST be equal to or later than the value of the\n    /// START-DATE attribute.  This attribute is OPTIONAL.\n    end_date: Option\u003cDateTime\u003cFixedOffset\u003e\u003e,\n    /// The duration of the Date Range. It MUST NOT be negative. A single\n    /// instant in time (e.g., crossing a finish line) SHOULD be\n    /// represented with a duration of 0.  This attribute is OPTIONAL.\n    duration: Option\u003cDuration\u003e,\n    /// The expected duration of the Date Range. It MUST NOT be negative. This\n    /// attribute SHOULD be used to indicate the expected duration of a\n    /// Date Range whose actual duration is not yet known.\n    /// It is OPTIONAL.\n    planned_duration: Option\u003cDuration\u003e,\n    ///\n    scte35_cmd: Option\u003cString\u003e,\n    ///\n    scte35_out: Option\u003cString\u003e,\n    ///\n    scte35_in: Option\u003cString\u003e,\n    /// This attribute indicates that the end of the range containing it is equal to the\n    /// START-DATE of its Following Range. The Following Range is the\n    /// Date Range of the same CLASS, that has the earliest START-DATE\n    /// after the START-DATE of the range in question. This attribute is\n    /// OPTIONAL.\n    end_on_next: bool,\n    /// The \"X-\" prefix defines a namespace reserved for client-defined\n    /// attributes. The client-attribute MUST be a legal AttributeName.\n    /// Clients SHOULD use a reverse-DNS syntax when defining their own\n    /// attribute names to avoid collisions. The attribute value MUST be\n    /// a quoted-string, a hexadecimal-sequence, or a decimal-floating-\n    /// point. An example of a client-defined attribute is X-COM-EXAMPLE-\n    /// AD-ID=\"XYZ123\". These attributes are OPTIONAL.\n    client_attributes: BTreeMap\u003cString, String\u003e,\n}\n\nimpl ExtXDateRange {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-DATERANGE:\";\n\n    /// Makes a new [ExtXDateRange] tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtXDateRange;\n    /// use chrono::{DateTime, FixedOffset};\n    /// use chrono::offset::TimeZone;\n    ///\n    /// const HOURS_IN_SECS: i32 = 3600; // 1 hour = 3600 seconds\n    ///\n    /// ExtXDateRange::new(\"id\", FixedOffset::east(8 * HOURS_IN_SECS)\n    ///                    .ymd(2010, 2, 19)\n    ///                    .and_hms_milli(14, 54, 23, 31));\n    /// ```\n    pub fn new\u003cT: ToString\u003e(id: T, start_date: DateTime\u003cFixedOffset\u003e) -\u003e Self {\n        Self {\n            id: id.to_string(),\n            class: None,\n            start_date,\n            end_date: None,\n            duration: None,\n            planned_duration: None,\n            scte35_cmd: None,\n            scte35_out: None,\n            scte35_in: None,\n            end_on_next: false,\n            client_attributes: BTreeMap::new(),\n        }\n    }\n}\n\nimpl RequiredVersion for ExtXDateRange {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXDateRange {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n        write!(f, \"ID={}\", quote(\u0026self.id))?;\n        if let Some(value) = \u0026self.class {\n            write!(f, \",CLASS={}\", quote(value))?;\n        }\n        write!(f, \",START-DATE={}\", quote(\u0026self.start_date))?;\n        if let Some(value) = \u0026self.end_date {\n            write!(f, \",END-DATE={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.duration {\n            write!(f, \",DURATION={}\", value.as_secs_f64())?;\n        }\n        if let Some(value) = \u0026self.planned_duration {\n            write!(f, \",PLANNED-DURATION={}\", value.as_secs_f64())?;\n        }\n        if let Some(value) = \u0026self.scte35_cmd {\n            write!(f, \",SCTE35-CMD={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.scte35_out {\n            write!(f, \",SCTE35-OUT={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.scte35_in {\n            write!(f, \",SCTE35-IN={}\", quote(value))?;\n        }\n        if self.end_on_next {\n            write!(f, \",END-ON-NEXT=YES\",)?;\n        }\n        for (k, v) in \u0026self.client_attributes {\n            write!(f, \",{}={}\", k, v)?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXDateRange {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let mut id = None;\n        let mut class = None;\n        let mut start_date = None;\n        let mut end_date = None;\n        let mut duration = None;\n        let mut planned_duration = None;\n        let mut scte35_cmd = None;\n        let mut scte35_out = None;\n        let mut scte35_in = None;\n        let mut end_on_next = false;\n\n        let mut client_attributes = BTreeMap::new();\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"ID\" =\u003e id = Some(unquote(value)),\n                \"CLASS\" =\u003e class = Some(unquote(value)),\n                \"START-DATE\" =\u003e start_date = Some(unquote(value)),\n                \"END-DATE\" =\u003e end_date = Some(unquote(value).parse()?),\n                \"DURATION\" =\u003e {\n                    duration = Some(Duration::from_secs_f64(value.parse()?));\n                }\n                \"PLANNED-DURATION\" =\u003e {\n                    planned_duration = Some(Duration::from_secs_f64(value.parse()?));\n                }\n                \"SCTE35-CMD\" =\u003e scte35_cmd = Some(unquote(value)),\n                \"SCTE35-OUT\" =\u003e scte35_out = Some(unquote(value)),\n                \"SCTE35-IN\" =\u003e scte35_in = Some(unquote(value)),\n                \"END-ON-NEXT\" =\u003e {\n                    if value != \"YES\" {\n                        return Err(Error::invalid_input());\n                    }\n                    end_on_next = true;\n                }\n                _ =\u003e {\n                    if key.starts_with(\"X-\") {\n                        client_attributes.insert(key.split_at(2).1.to_owned(), value.to_owned());\n                    } else {\n                        // [6.3.1. General Client Responsibilities]\n                        // \u003e ignore any attribute/value pair with an unrecognized AttributeName.\n                    }\n                }\n            }\n        }\n\n        let id = id.ok_or_else(|| Error::missing_value(\"ID\"))?;\n        let start_date = start_date\n            .ok_or_else(|| Error::missing_value(\"START-DATE\"))?\n            .parse()?;\n\n        if end_on_next \u0026\u0026 class.is_none() {\n            return Err(Error::invalid_input());\n        }\n        Ok(Self {\n            id,\n            class,\n            start_date,\n            end_date,\n            duration,\n            planned_duration,\n            scte35_cmd,\n            scte35_out,\n            scte35_in,\n            end_on_next,\n            client_attributes,\n        })\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use chrono::offset::TimeZone;\n\n    const HOURS_IN_SECS: i32 = 3600; // 1 hour = 3600 seconds\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXDateRange::new(\n                \"id\",\n                FixedOffset::east(8 * HOURS_IN_SECS)\n                    .ymd(2010, 2, 19)\n                    .and_hms_milli(14, 54, 23, 31)\n            )\n            .required_version(),\n            ProtocolVersion::V1\n        );\n    }\n}\n","traces":[{"line":81,"address":null,"length":0,"stats":{"Line":2}},{"line":83,"address":null,"length":0,"stats":{"Line":2}},{"line":93,"address":null,"length":0,"stats":{"Line":2}},{"line":98,"address":4404046,"length":1,"stats":{"Line":0}},{"line":99,"address":4402544,"length":1,"stats":{"Line":1}},{"line":100,"address":null,"length":0,"stats":{"Line":1}},{"line":104,"address":4404879,"length":1,"stats":{"Line":0}},{"line":105,"address":4402576,"length":1,"stats":{"Line":0}},{"line":106,"address":4402613,"length":1,"stats":{"Line":0}},{"line":107,"address":4402924,"length":1,"stats":{"Line":0}},{"line":108,"address":4403329,"length":1,"stats":{"Line":0}},{"line":109,"address":4403399,"length":1,"stats":{"Line":0}},{"line":111,"address":4403799,"length":1,"stats":{"Line":0}},{"line":112,"address":4404206,"length":1,"stats":{"Line":0}},{"line":113,"address":null,"length":0,"stats":{"Line":0}},{"line":115,"address":4404672,"length":1,"stats":{"Line":0}},{"line":116,"address":null,"length":0,"stats":{"Line":0}},{"line":118,"address":4405045,"length":1,"stats":{"Line":0}},{"line":119,"address":null,"length":0,"stats":{"Line":0}},{"line":121,"address":4405422,"length":1,"stats":{"Line":0}},{"line":122,"address":null,"length":0,"stats":{"Line":0}},{"line":124,"address":4405896,"length":1,"stats":{"Line":0}},{"line":125,"address":null,"length":0,"stats":{"Line":0}},{"line":127,"address":4402727,"length":1,"stats":{"Line":0}},{"line":128,"address":null,"length":0,"stats":{"Line":0}},{"line":130,"address":null,"length":0,"stats":{"Line":0}},{"line":131,"address":null,"length":0,"stats":{"Line":0}},{"line":133,"address":4406945,"length":1,"stats":{"Line":0}},{"line":134,"address":4407184,"length":1,"stats":{"Line":0}},{"line":136,"address":4407066,"length":1,"stats":{"Line":0}},{"line":140,"address":4408220,"length":1,"stats":{"Line":0}},{"line":141,"address":4408232,"length":1,"stats":{"Line":0}},{"line":143,"address":4407664,"length":1,"stats":{"Line":0}},{"line":144,"address":4407703,"length":1,"stats":{"Line":0}},{"line":146,"address":null,"length":0,"stats":{"Line":0}},{"line":147,"address":4408288,"length":1,"stats":{"Line":0}},{"line":148,"address":null,"length":0,"stats":{"Line":0}},{"line":149,"address":4408307,"length":1,"stats":{"Line":0}},{"line":150,"address":4408380,"length":1,"stats":{"Line":0}},{"line":151,"address":4408392,"length":1,"stats":{"Line":0}},{"line":152,"address":4408404,"length":1,"stats":{"Line":0}},{"line":153,"address":4408416,"length":1,"stats":{"Line":0}},{"line":154,"address":4408428,"length":1,"stats":{"Line":0}},{"line":155,"address":4408440,"length":1,"stats":{"Line":0}},{"line":157,"address":4408448,"length":1,"stats":{"Line":0}},{"line":159,"address":4408467,"length":1,"stats":{"Line":0}},{"line":160,"address":4409683,"length":1,"stats":{"Line":0}},{"line":161,"address":4409707,"length":1,"stats":{"Line":0}},{"line":162,"address":null,"length":0,"stats":{"Line":0}},{"line":163,"address":4409903,"length":1,"stats":{"Line":0}},{"line":164,"address":4409969,"length":1,"stats":{"Line":0}},{"line":165,"address":4410075,"length":1,"stats":{"Line":0}},{"line":166,"address":4410043,"length":1,"stats":{"Line":0}},{"line":168,"address":4410590,"length":1,"stats":{"Line":0}},{"line":169,"address":null,"length":0,"stats":{"Line":0}},{"line":171,"address":null,"length":0,"stats":{"Line":0}},{"line":172,"address":null,"length":0,"stats":{"Line":0}},{"line":173,"address":4410181,"length":1,"stats":{"Line":0}},{"line":174,"address":4410802,"length":1,"stats":{"Line":0}},{"line":175,"address":null,"length":0,"stats":{"Line":0}},{"line":176,"address":null,"length":0,"stats":{"Line":0}},{"line":178,"address":null,"length":0,"stats":{"Line":0}},{"line":180,"address":null,"length":0,"stats":{"Line":0}},{"line":181,"address":4409469,"length":1,"stats":{"Line":0}},{"line":182,"address":null,"length":0,"stats":{"Line":0}},{"line":184,"address":4413440,"length":1,"stats":{"Line":0}},{"line":185,"address":4380608,"length":1,"stats":{"Line":0}},{"line":191,"address":4380720,"length":1,"stats":{"Line":0}},{"line":192,"address":4413032,"length":1,"stats":{"Line":0}},{"line":193,"address":4380768,"length":1,"stats":{"Line":0}},{"line":194,"address":4413096,"length":1,"stats":{"Line":0}},{"line":196,"address":4413785,"length":1,"stats":{"Line":0}},{"line":197,"address":4414484,"length":1,"stats":{"Line":0}},{"line":199,"address":4414323,"length":1,"stats":{"Line":0}},{"line":200,"address":4413854,"length":1,"stats":{"Line":0}},{"line":201,"address":4413902,"length":1,"stats":{"Line":0}},{"line":202,"address":4413950,"length":1,"stats":{"Line":0}},{"line":203,"address":null,"length":0,"stats":{"Line":0}},{"line":204,"address":4408022,"length":1,"stats":{"Line":0}},{"line":205,"address":null,"length":0,"stats":{"Line":0}},{"line":206,"address":null,"length":0,"stats":{"Line":0}},{"line":207,"address":null,"length":0,"stats":{"Line":0}},{"line":208,"address":null,"length":0,"stats":{"Line":0}},{"line":209,"address":null,"length":0,"stats":{"Line":0}},{"line":210,"address":null,"length":0,"stats":{"Line":0}},{"line":223,"address":4963520,"length":1,"stats":{"Line":2}},{"line":224,"address":5523213,"length":1,"stats":{"Line":1}},{"line":225,"address":5523158,"length":1,"stats":{"Line":1}},{"line":227,"address":5522999,"length":1,"stats":{"Line":1}}],"covered":9,"coverable":89},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_segment","discontinuity.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.2.3. EXT-X-DISCONTINUITY]\n/// The [ExtXDiscontinuity] tag indicates a discontinuity between the\n/// [Media Segment] that follows it and the one that preceded it.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-DISCONTINUITY\n/// ```\n///\n/// [Media Segment]: crate::MediaSegment\n/// [4.4.2.3. EXT-X-DISCONTINUITY]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.2.3\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ExtXDiscontinuity;\n\nimpl ExtXDiscontinuity {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-DISCONTINUITY\";\n}\n\nimpl RequiredVersion for ExtXDiscontinuity {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXDiscontinuity {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Self::PREFIX.fmt(f)\n    }\n}\n\nimpl FromStr for ExtXDiscontinuity {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        tag(input, Self::PREFIX)?;\n        Ok(ExtXDiscontinuity)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXDiscontinuity.to_string(),\n            \"#EXT-X-DISCONTINUITY\".to_string(),\n        )\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(ExtXDiscontinuity, \"#EXT-X-DISCONTINUITY\".parse().unwrap())\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(ExtXDiscontinuity.required_version(), ProtocolVersion::V1)\n    }\n}\n","traces":[{"line":28,"address":4889840,"length":1,"stats":{"Line":1}},{"line":29,"address":4889848,"length":1,"stats":{"Line":1}},{"line":34,"address":4889872,"length":1,"stats":{"Line":1}},{"line":35,"address":4889893,"length":1,"stats":{"Line":1}},{"line":42,"address":4889936,"length":1,"stats":{"Line":1}},{"line":43,"address":4889963,"length":1,"stats":{"Line":1}},{"line":44,"address":4890384,"length":1,"stats":{"Line":1}},{"line":53,"address":4254096,"length":1,"stats":{"Line":2}},{"line":54,"address":4254164,"length":1,"stats":{"Line":1}},{"line":55,"address":4254103,"length":1,"stats":{"Line":1}},{"line":56,"address":4254135,"length":1,"stats":{"Line":1}},{"line":61,"address":4254640,"length":1,"stats":{"Line":2}},{"line":62,"address":4254654,"length":1,"stats":{"Line":1}},{"line":66,"address":4255056,"length":1,"stats":{"Line":2}},{"line":67,"address":4255063,"length":1,"stats":{"Line":1}}],"covered":15,"coverable":15},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_segment","inf.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\nuse std::time::Duration;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.2.1. EXTINF]\n///\n/// The [ExtInf] tag specifies the duration of a [Media Segment]. It applies\n/// only to the next [Media Segment].\n///\n/// Its format is:\n/// ```text\n/// #EXTINF:\u003cduration\u003e,[\u003ctitle\u003e]\n/// ```\n/// The title is an optional informative title about the [Media Segment].\n///\n/// [Media Segment]: crate::media_segment::MediaSegment\n/// [4.4.2.1. EXTINF]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.2.1\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct ExtInf {\n    duration: Duration,\n    title: Option\u003cString\u003e,\n}\n\nimpl ExtInf {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXTINF:\";\n\n    /// Makes a new [ExtInf] tag.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtInf;\n    /// use std::time::Duration;\n    ///\n    /// let ext_inf = ExtInf::new(Duration::from_secs(5));\n    /// ```\n    pub const fn new(duration: Duration) -\u003e Self {\n        Self {\n            duration,\n            title: None,\n        }\n    }\n\n    /// Makes a new [ExtInf] tag with the given title.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtInf;\n    /// use std::time::Duration;\n    ///\n    /// let ext_inf = ExtInf::with_title(Duration::from_secs(5), \"title\");\n    /// ```\n    pub fn with_title\u003cT: ToString\u003e(duration: Duration, title: T) -\u003e Self {\n        Self {\n            duration,\n            title: Some(title.to_string()),\n        }\n    }\n\n    /// Returns the duration of the associated media segment.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtInf;\n    /// use std::time::Duration;\n    ///\n    /// let ext_inf = ExtInf::new(Duration::from_secs(5));\n    ///\n    /// assert_eq!(\n    ///     ext_inf.duration(),\n    ///     Duration::from_secs(5)\n    /// );\n    /// ```\n    pub const fn duration(\u0026self) -\u003e Duration {\n        self.duration\n    }\n\n    /// Sets the duration of the associated media segment.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtInf;\n    /// use std::time::Duration;\n    ///\n    /// let mut ext_inf = ExtInf::new(Duration::from_secs(5));\n    ///\n    /// ext_inf.set_duration(Duration::from_secs(10));\n    ///\n    /// assert_eq!(\n    ///     ext_inf.duration(),\n    ///     Duration::from_secs(10)\n    /// );\n    /// ```\n    pub fn set_duration(\u0026mut self, value: Duration) -\u003e \u0026mut Self {\n        self.duration = value;\n        self\n    }\n\n    /// Returns the title of the associated media segment.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtInf;\n    /// use std::time::Duration;\n    ///\n    /// let ext_inf = ExtInf::with_title(Duration::from_secs(5), \"title\");\n    ///\n    /// assert_eq!(\n    ///     ext_inf.title(),\n    ///     \u0026Some(\"title\".to_string())\n    /// );\n    /// ```\n    pub const fn title(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.title\n    }\n\n    /// Sets the title of the associated media segment.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::tags::ExtInf;\n    /// use std::time::Duration;\n    ///\n    /// let mut ext_inf = ExtInf::with_title(Duration::from_secs(5), \"title\");\n    ///\n    /// ext_inf.set_title(Some(\"better title\"));\n    ///\n    /// assert_eq!(\n    ///     ext_inf.title(),\n    ///     \u0026Some(\"better title\".to_string())\n    /// );\n    /// ```\n    pub fn set_title\u003cT: ToString\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.title = value.map(|v| v.to_string());\n        self\n    }\n}\n\nimpl RequiredVersion for ExtInf {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        if self.duration.subsec_nanos() == 0 {\n            ProtocolVersion::V1\n        } else {\n            ProtocolVersion::V3\n        }\n    }\n}\n\nimpl fmt::Display for ExtInf {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n\n        let duration = (self.duration.as_secs() as f64)\n            + (f64::from(self.duration.subsec_nanos()) / 1_000_000_000.0);\n        write!(f, \"{},\", duration)?;\n\n        if let Some(value) = \u0026self.title {\n            write!(f, \"{}\", value)?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtInf {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n        let tokens = input.splitn(2, ',').collect::\u003cVec\u003c_\u003e\u003e();\n\n        if tokens.is_empty() {\n            return Err(Error::custom(format!(\n                \"failed to parse #EXTINF tag, couldn't split input: {:?}\",\n                input\n            )));\n        }\n\n        let duration = Duration::from_secs_f64(tokens[0].parse()?);\n\n        let title = {\n            if tokens.len() \u003e= 2 {\n                if tokens[1].trim().is_empty() {\n                    None\n                } else {\n                    Some(tokens[1].to_string())\n                }\n            } else {\n                None\n            }\n        };\n\n        Ok(Self { duration, title })\n    }\n}\n\nimpl From\u003cDuration\u003e for ExtInf {\n    fn from(value: Duration) -\u003e Self {\n        Self::new(value)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            \"#EXTINF:5,\".to_string(),\n            ExtInf::new(Duration::from_secs(5)).to_string()\n        );\n        assert_eq!(\n            \"#EXTINF:5.5,\".to_string(),\n            ExtInf::new(Duration::from_millis(5500)).to_string()\n        );\n        assert_eq!(\n            \"#EXTINF:5.5,title\".to_string(),\n            ExtInf::with_title(Duration::from_millis(5500), \"title\").to_string()\n        );\n        assert_eq!(\n            \"#EXTINF:5,title\".to_string(),\n            ExtInf::with_title(Duration::from_secs(5), \"title\").to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        // #EXTINF:\u003cduration\u003e,[\u003ctitle\u003e]\n        assert_eq!(\n            \"#EXTINF:5\".parse::\u003cExtInf\u003e().unwrap(),\n            ExtInf::new(Duration::from_secs(5))\n        );\n        assert_eq!(\n            \"#EXTINF:5,\".parse::\u003cExtInf\u003e().unwrap(),\n            ExtInf::new(Duration::from_secs(5))\n        );\n        assert_eq!(\n            \"#EXTINF:5.5\".parse::\u003cExtInf\u003e().unwrap(),\n            ExtInf::new(Duration::from_millis(5500))\n        );\n        assert_eq!(\n            \"#EXTINF:5.5,\".parse::\u003cExtInf\u003e().unwrap(),\n            ExtInf::new(Duration::from_millis(5500))\n        );\n        assert_eq!(\n            \"#EXTINF:5.5,title\".parse::\u003cExtInf\u003e().unwrap(),\n            ExtInf::with_title(Duration::from_millis(5500), \"title\")\n        );\n        assert_eq!(\n            \"#EXTINF:5,title\".parse::\u003cExtInf\u003e().unwrap(),\n            ExtInf::with_title(Duration::from_secs(5), \"title\")\n        );\n    }\n\n    #[test]\n    fn test_title() {\n        assert_eq!(ExtInf::new(Duration::from_secs(5)).title(), \u0026None);\n        assert_eq!(\n            ExtInf::with_title(Duration::from_secs(5), \"title\").title(),\n            \u0026Some(\"title\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtInf::new(Duration::from_secs(4)).required_version(),\n            ProtocolVersion::V1\n        );\n        assert_eq!(\n            ExtInf::new(Duration::from_millis(4400)).required_version(),\n            ProtocolVersion::V3\n        );\n    }\n}\n","traces":[{"line":41,"address":4212128,"length":1,"stats":{"Line":5}},{"line":57,"address":null,"length":0,"stats":{"Line":4}},{"line":60,"address":null,"length":0,"stats":{"Line":4}},{"line":78,"address":4212208,"length":1,"stats":{"Line":5}},{"line":79,"address":4212213,"length":1,"stats":{"Line":5}},{"line":98,"address":4212240,"length":1,"stats":{"Line":1}},{"line":99,"address":4212257,"length":1,"stats":{"Line":1}},{"line":100,"address":4212276,"length":1,"stats":{"Line":1}},{"line":117,"address":4212288,"length":1,"stats":{"Line":3}},{"line":118,"address":4212293,"length":1,"stats":{"Line":3}},{"line":137,"address":null,"length":0,"stats":{"Line":1}},{"line":138,"address":null,"length":0,"stats":{"Line":2}},{"line":139,"address":null,"length":0,"stats":{"Line":1}},{"line":144,"address":4212320,"length":1,"stats":{"Line":3}},{"line":145,"address":4212329,"length":1,"stats":{"Line":3}},{"line":146,"address":4212362,"length":1,"stats":{"Line":2}},{"line":148,"address":4212355,"length":1,"stats":{"Line":2}},{"line":154,"address":4212384,"length":1,"stats":{"Line":1}},{"line":155,"address":4212421,"length":1,"stats":{"Line":1}},{"line":157,"address":4212709,"length":1,"stats":{"Line":1}},{"line":158,"address":4212774,"length":1,"stats":{"Line":1}},{"line":159,"address":4212859,"length":1,"stats":{"Line":1}},{"line":161,"address":4213115,"length":1,"stats":{"Line":1}},{"line":162,"address":4213192,"length":1,"stats":{"Line":1}},{"line":164,"address":4213444,"length":1,"stats":{"Line":1}},{"line":171,"address":4213472,"length":1,"stats":{"Line":3}},{"line":172,"address":4213505,"length":1,"stats":{"Line":3}},{"line":173,"address":4214019,"length":1,"stats":{"Line":3}},{"line":175,"address":4214082,"length":1,"stats":{"Line":3}},{"line":176,"address":4214181,"length":1,"stats":{"Line":0}},{"line":177,"address":4214173,"length":1,"stats":{"Line":0}},{"line":178,"address":null,"length":0,"stats":{"Line":0}},{"line":182,"address":4214134,"length":1,"stats":{"Line":3}},{"line":184,"address":null,"length":0,"stats":{"Line":0}},{"line":185,"address":4214636,"length":1,"stats":{"Line":3}},{"line":186,"address":4214688,"length":1,"stats":{"Line":3}},{"line":187,"address":4214810,"length":1,"stats":{"Line":3}},{"line":189,"address":4214781,"length":1,"stats":{"Line":1}},{"line":192,"address":4214671,"length":1,"stats":{"Line":1}},{"line":196,"address":4214901,"length":1,"stats":{"Line":3}},{"line":201,"address":4215184,"length":1,"stats":{"Line":0}},{"line":202,"address":4215200,"length":1,"stats":{"Line":0}},{"line":211,"address":4480736,"length":1,"stats":{"Line":2}},{"line":212,"address":4663389,"length":1,"stats":{"Line":0}},{"line":213,"address":4663294,"length":1,"stats":{"Line":1}},{"line":214,"address":4663337,"length":1,"stats":{"Line":1}},{"line":216,"address":4664038,"length":1,"stats":{"Line":0}},{"line":217,"address":4663960,"length":1,"stats":{"Line":1}},{"line":218,"address":4663986,"length":1,"stats":{"Line":1}},{"line":220,"address":4664703,"length":1,"stats":{"Line":0}},{"line":221,"address":4664612,"length":1,"stats":{"Line":1}},{"line":222,"address":4664638,"length":1,"stats":{"Line":1}},{"line":224,"address":4665320,"length":1,"stats":{"Line":0}},{"line":225,"address":4665241,"length":1,"stats":{"Line":1}},{"line":226,"address":4665267,"length":1,"stats":{"Line":1}},{"line":231,"address":4480768,"length":1,"stats":{"Line":2}},{"line":233,"address":4666196,"length":1,"stats":{"Line":0}},{"line":234,"address":4666110,"length":1,"stats":{"Line":1}},{"line":235,"address":4666174,"length":1,"stats":{"Line":1}},{"line":237,"address":4666813,"length":1,"stats":{"Line":0}},{"line":238,"address":4666744,"length":1,"stats":{"Line":1}},{"line":239,"address":4666791,"length":1,"stats":{"Line":1}},{"line":241,"address":4667433,"length":1,"stats":{"Line":0}},{"line":242,"address":4667364,"length":1,"stats":{"Line":1}},{"line":243,"address":4667411,"length":1,"stats":{"Line":1}},{"line":245,"address":4668053,"length":1,"stats":{"Line":0}},{"line":246,"address":4667984,"length":1,"stats":{"Line":1}},{"line":247,"address":4668031,"length":1,"stats":{"Line":1}},{"line":249,"address":4668673,"length":1,"stats":{"Line":0}},{"line":250,"address":4668604,"length":1,"stats":{"Line":1}},{"line":251,"address":4668651,"length":1,"stats":{"Line":1}},{"line":253,"address":4669264,"length":1,"stats":{"Line":0}},{"line":254,"address":4669201,"length":1,"stats":{"Line":1}},{"line":255,"address":4669248,"length":1,"stats":{"Line":1}},{"line":260,"address":4480800,"length":1,"stats":{"Line":2}},{"line":261,"address":4670039,"length":1,"stats":{"Line":1}},{"line":262,"address":4670715,"length":1,"stats":{"Line":0}},{"line":263,"address":4670598,"length":1,"stats":{"Line":1}},{"line":264,"address":4670688,"length":1,"stats":{"Line":1}},{"line":269,"address":4480832,"length":1,"stats":{"Line":2}},{"line":270,"address":4671421,"length":1,"stats":{"Line":1}},{"line":271,"address":4671319,"length":1,"stats":{"Line":1}},{"line":274,"address":4671930,"length":1,"stats":{"Line":1}},{"line":275,"address":4671851,"length":1,"stats":{"Line":1}}],"covered":67,"coverable":84},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_segment","key.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::types::{DecryptionKey, EncryptionMethod};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.4.2.4. EXT-X-KEY]\n/// [Media Segment]s may be encrypted. The [ExtXKey] tag specifies how to\n/// decrypt them. It applies to every [Media Segment] and to every Media\n/// Initialization Section declared by an [ExtXMap] tag, that appears\n/// between it and the next [ExtXKey] tag in the Playlist file with the\n/// same [KeyFormat] attribute (or the end of the Playlist file).\n///\n/// The format is:\n/// ```text\n/// #EXT-X-KEY:\u003cattribute-list\u003e\n/// ```\n///\n/// # Note\n/// In case of an empty key (`EncryptionMethod::None`), all attributes will be ignored.\n///\n/// [KeyFormat]: crate::types::KeyFormat\n/// [ExtXMap]: crate::tags::ExtXMap\n/// [Media Segment]: crate::MediaSegment\n/// [4.4.2.4. EXT-X-KEY]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.2.4\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ExtXKey(DecryptionKey);\n\nimpl ExtXKey {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-KEY:\";\n\n    /// Makes a new `ExtXKey` tag.\n    /// # Examples\n    /// ```\n    /// use hls_m3u8::tags::ExtXKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let key = ExtXKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// assert_eq!(\n    ///     key.to_string(),\n    ///     \"#EXT-X-KEY:METHOD=AES-128,URI=\\\"https://www.example.com/\\\"\"\n    /// );\n    /// ```\n    pub fn new\u003cT: ToString\u003e(method: EncryptionMethod, uri: T) -\u003e Self {\n        Self(DecryptionKey::new(method, uri))\n    }\n\n    /// Makes a new `ExtXKey` tag without a decryption key.\n    /// # Examples\n    /// ```\n    /// use hls_m3u8::tags::ExtXKey;\n    ///\n    /// let key = ExtXKey::empty();\n    ///\n    /// assert_eq!(\n    ///     key.to_string(),\n    ///     \"#EXT-X-KEY:METHOD=NONE\"\n    /// );\n    /// ```\n    pub const fn empty() -\u003e Self {\n        Self(DecryptionKey {\n            method: EncryptionMethod::None,\n            uri: None,\n            iv: None,\n            key_format: None,\n            key_format_versions: None,\n        })\n    }\n\n    /// Returns whether the [EncryptionMethod] is [None](EncryptionMethod::None).\n    /// # Examples\n    /// ```\n    /// use hls_m3u8::tags::ExtXKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let key = ExtXKey::empty();\n    ///\n    /// assert_eq!(\n    ///     key.method() == EncryptionMethod::None,\n    ///     key.is_empty()\n    /// );\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.method() == EncryptionMethod::None\n    }\n}\n\nimpl FromStr for ExtXKey {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n        Ok(Self(input.parse()?))\n    }\n}\n\nimpl fmt::Display for ExtXKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", Self::PREFIX, self.0)\n    }\n}\n\nimpl Deref for ExtXKey {\n    type Target = DecryptionKey;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for ExtXKey {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::types::{EncryptionMethod, KeyFormat};\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXKey::empty().to_string(),\n            \"#EXT-X-KEY:METHOD=NONE\".to_string()\n        );\n\n        let mut key = ExtXKey::empty();\n        // it is expected, that all attributes will be ignored for an empty key!\n        key.set_key_format(Some(KeyFormat::Identity));\n        key.set_iv(Some([\n            16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n        ]));\n        key.set_uri(Some(\"https://www.example.com\"));\n        key.set_key_format_versions(Some(vec![1, 2, 3]));\n\n        assert_eq!(key.to_string(), \"#EXT-X-KEY:METHOD=NONE\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            \"#EXT-X-KEY:\\\n             METHOD=AES-128,\\\n             URI=\\\"https://priv.example.com/key.php?r=52\\\"\"\n                .parse::\u003cExtXKey\u003e()\n                .unwrap(),\n            ExtXKey::new(\n                EncryptionMethod::Aes128,\n                \"https://priv.example.com/key.php?r=52\"\n            )\n        );\n\n        let mut key = ExtXKey::new(\n            EncryptionMethod::Aes128,\n            \"https://www.example.com/hls-key/key.bin\",\n        );\n        key.set_iv(Some([\n            16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n        ]));\n    }\n}\n","traces":[{"line":51,"address":null,"length":0,"stats":{"Line":2}},{"line":52,"address":null,"length":0,"stats":{"Line":2}},{"line":67,"address":4315904,"length":1,"stats":{"Line":3}},{"line":68,"address":4315953,"length":1,"stats":{"Line":3}},{"line":69,"address":4315914,"length":1,"stats":{"Line":3}},{"line":70,"address":4315919,"length":1,"stats":{"Line":3}},{"line":71,"address":4315928,"length":1,"stats":{"Line":3}},{"line":72,"address":4315933,"length":1,"stats":{"Line":3}},{"line":73,"address":4315941,"length":1,"stats":{"Line":3}},{"line":90,"address":4316128,"length":1,"stats":{"Line":1}},{"line":91,"address":4316137,"length":1,"stats":{"Line":1}},{"line":98,"address":4316192,"length":1,"stats":{"Line":1}},{"line":99,"address":4316219,"length":1,"stats":{"Line":1}},{"line":100,"address":4316689,"length":1,"stats":{"Line":1}},{"line":105,"address":4317424,"length":1,"stats":{"Line":3}},{"line":106,"address":4317455,"length":1,"stats":{"Line":3}},{"line":113,"address":4317712,"length":1,"stats":{"Line":1}},{"line":114,"address":4317717,"length":1,"stats":{"Line":1}},{"line":119,"address":4317728,"length":1,"stats":{"Line":1}},{"line":120,"address":4317733,"length":1,"stats":{"Line":1}},{"line":130,"address":5246688,"length":1,"stats":{"Line":2}},{"line":131,"address":5508455,"length":1,"stats":{"Line":0}},{"line":132,"address":5508375,"length":1,"stats":{"Line":1}},{"line":133,"address":5508428,"length":1,"stats":{"Line":1}},{"line":136,"address":5508969,"length":1,"stats":{"Line":1}},{"line":138,"address":5508990,"length":1,"stats":{"Line":1}},{"line":139,"address":5509056,"length":1,"stats":{"Line":1}},{"line":142,"address":5509248,"length":1,"stats":{"Line":1}},{"line":143,"address":5509323,"length":1,"stats":{"Line":1}},{"line":145,"address":5509464,"length":1,"stats":{"Line":1}},{"line":148,"address":5246725,"length":1,"stats":{"Line":1}},{"line":149,"address":5246720,"length":1,"stats":{"Line":2}},{"line":150,"address":5510225,"length":1,"stats":{"Line":0}},{"line":156,"address":5510190,"length":1,"stats":{"Line":1}},{"line":157,"address":5510182,"length":1,"stats":{"Line":1}},{"line":162,"address":5510685,"length":1,"stats":{"Line":1}},{"line":163,"address":5510677,"length":1,"stats":{"Line":1}},{"line":166,"address":5510722,"length":1,"stats":{"Line":1}}],"covered":36,"coverable":38},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_segment","map.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{ByteRange, ProtocolVersion, RequiredVersion};\nuse crate::utils::{quote, tag, unquote};\nuse crate::Error;\n\n/// # [4.4.2.5. EXT-X-MAP]\n/// The [ExtXMap] tag specifies how to obtain the Media Initialization\n/// Section, required to parse the applicable [Media Segment]s.\n///\n/// Its format is:\n/// ```text\n/// #EXT-X-MAP:\u003cattribute-list\u003e\n/// ```\n///\n/// [Media Segment]: crate::MediaSegment\n/// [4.4.2.5. EXT-X-MAP]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.2.5\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ExtXMap {\n    uri: String,\n    range: Option\u003cByteRange\u003e,\n}\n\nimpl ExtXMap {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-MAP:\";\n\n    /// Makes a new `ExtXMap` tag.\n    pub fn new\u003cT: ToString\u003e(uri: T) -\u003e Self {\n        ExtXMap {\n            uri: uri.to_string(),\n            range: None,\n        }\n    }\n\n    /// Makes a new `ExtXMap` tag with the given range.\n    pub fn with_range\u003cT: ToString\u003e(uri: T, range: ByteRange) -\u003e Self {\n        ExtXMap {\n            uri: uri.to_string(),\n            range: Some(range),\n        }\n    }\n\n    /// Returns the URI that identifies a resource that contains the media initialization section.\n    pub const fn uri(\u0026self) -\u003e \u0026String {\n        \u0026self.uri\n    }\n\n    /// Returns the range of the media initialization section.\n    pub const fn range(\u0026self) -\u003e Option\u003cByteRange\u003e {\n        self.range\n    }\n}\n\nimpl RequiredVersion for ExtXMap {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V6\n    }\n}\n\nimpl fmt::Display for ExtXMap {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n        write!(f, \"URI={}\", quote(\u0026self.uri))?;\n        if let Some(value) = \u0026self.range {\n            write!(f, \",BYTERANGE={}\", quote(value))?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXMap {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let mut uri = None;\n        let mut range = None;\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"URI\" =\u003e uri = Some(unquote(value)),\n                \"BYTERANGE\" =\u003e {\n                    range = Some((unquote(value).parse())?);\n                }\n                _ =\u003e {\n                    // [6.3.1. General Client Responsibilities]\n                    // \u003e ignore any attribute/value pair with an unrecognized AttributeName.\n                }\n            }\n        }\n\n        let uri = uri.ok_or_else(|| Error::missing_value(\"EXT-X-URI\"))?;\n        Ok(ExtXMap { uri, range })\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXMap::new(\"foo\").to_string(),\n            \"#EXT-X-MAP:URI=\\\"foo\\\"\".to_string(),\n        );\n\n        assert_eq!(\n            ExtXMap::with_range(\"foo\", ByteRange::new(9, Some(2))).to_string(),\n            \"#EXT-X-MAP:URI=\\\"foo\\\",BYTERANGE=\\\"9@2\\\"\".to_string(),\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ExtXMap::new(\"foo\"),\n            \"#EXT-X-MAP:URI=\\\"foo\\\"\".parse().unwrap()\n        );\n\n        assert_eq!(\n            ExtXMap::with_range(\"foo\", ByteRange::new(9, Some(2))),\n            \"#EXT-X-MAP:URI=\\\"foo\\\",BYTERANGE=\\\"9@2\\\"\".parse().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(ExtXMap::new(\"foo\").required_version(), ProtocolVersion::V6);\n        assert_eq!(\n            ExtXMap::with_range(\"foo\", ByteRange::new(9, Some(2))).required_version(),\n            ProtocolVersion::V6\n        );\n    }\n}\n","traces":[{"line":31,"address":null,"length":0,"stats":{"Line":1}},{"line":33,"address":null,"length":0,"stats":{"Line":1}},{"line":39,"address":null,"length":0,"stats":{"Line":1}},{"line":41,"address":null,"length":0,"stats":{"Line":1}},{"line":42,"address":null,"length":0,"stats":{"Line":1}},{"line":47,"address":4858816,"length":1,"stats":{"Line":0}},{"line":48,"address":4858821,"length":1,"stats":{"Line":0}},{"line":52,"address":4858832,"length":1,"stats":{"Line":0}},{"line":53,"address":4858840,"length":1,"stats":{"Line":0}},{"line":58,"address":4858880,"length":1,"stats":{"Line":1}},{"line":59,"address":4858888,"length":1,"stats":{"Line":1}},{"line":64,"address":4858912,"length":1,"stats":{"Line":1}},{"line":65,"address":4858949,"length":1,"stats":{"Line":1}},{"line":66,"address":4859230,"length":1,"stats":{"Line":1}},{"line":67,"address":4859593,"length":1,"stats":{"Line":1}},{"line":68,"address":4859674,"length":1,"stats":{"Line":1}},{"line":70,"address":4860032,"length":1,"stats":{"Line":1}},{"line":77,"address":4860096,"length":1,"stats":{"Line":1}},{"line":78,"address":4860123,"length":1,"stats":{"Line":1}},{"line":80,"address":4860681,"length":1,"stats":{"Line":1}},{"line":81,"address":4860701,"length":1,"stats":{"Line":1}},{"line":83,"address":4860713,"length":1,"stats":{"Line":1}},{"line":84,"address":4861658,"length":1,"stats":{"Line":1}},{"line":85,"address":4861679,"length":1,"stats":{"Line":1}},{"line":86,"address":4861886,"length":1,"stats":{"Line":1}},{"line":87,"address":4861806,"length":1,"stats":{"Line":1}},{"line":89,"address":null,"length":0,"stats":{"Line":0}},{"line":96,"address":4663152,"length":1,"stats":{"Line":1}},{"line":97,"address":4864193,"length":1,"stats":{"Line":1}},{"line":106,"address":4329120,"length":1,"stats":{"Line":2}},{"line":107,"address":5528262,"length":1,"stats":{"Line":0}},{"line":108,"address":5528174,"length":1,"stats":{"Line":1}},{"line":109,"address":5528235,"length":1,"stats":{"Line":1}},{"line":112,"address":5528890,"length":1,"stats":{"Line":0}},{"line":113,"address":5528746,"length":1,"stats":{"Line":1}},{"line":114,"address":5528863,"length":1,"stats":{"Line":1}},{"line":119,"address":4329152,"length":1,"stats":{"Line":2}},{"line":120,"address":5529622,"length":1,"stats":{"Line":0}},{"line":121,"address":5529534,"length":1,"stats":{"Line":1}},{"line":122,"address":5529572,"length":1,"stats":{"Line":1}},{"line":125,"address":5530218,"length":1,"stats":{"Line":0}},{"line":126,"address":5530074,"length":1,"stats":{"Line":1}},{"line":127,"address":5530168,"length":1,"stats":{"Line":1}},{"line":132,"address":4329184,"length":1,"stats":{"Line":2}},{"line":133,"address":5530798,"length":1,"stats":{"Line":1}},{"line":134,"address":5531424,"length":1,"stats":{"Line":1}},{"line":135,"address":5531292,"length":1,"stats":{"Line":1}}],"covered":38,"coverable":47},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","media_segment","program_date_time.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse chrono::{DateTime, FixedOffset};\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// # [4.3.2.6. EXT-X-PROGRAM-DATE-TIME]\n/// The [ExtXProgramDateTime] tag associates the first sample of a\n/// [Media Segment] with an absolute date and/or time.\n///\n/// [Media Segment]: crate::MediaSegment\n/// [4.3.2.6. EXT-X-PROGRAM-DATE-TIME]: https://tools.ietf.org/html/rfc8216#section-4.3.2.6\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct ExtXProgramDateTime(DateTime\u003cFixedOffset\u003e);\n\nimpl ExtXProgramDateTime {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-PROGRAM-DATE-TIME:\";\n\n    /// Makes a new `ExtXProgramDateTime` tag.\n    ///\n    /// # Example\n    /// ```\n    /// use hls_m3u8::tags::ExtXProgramDateTime;\n    /// use chrono::{FixedOffset, TimeZone};\n    ///\n    /// const HOURS_IN_SECS: i32 = 3600; // 1 hour = 3600 seconds\n    ///\n    /// let program_date_time = ExtXProgramDateTime::new(\n    ///     FixedOffset::east(8 * HOURS_IN_SECS)\n    ///         .ymd(2010, 2, 19)\n    ///         .and_hms_milli(14, 54, 23, 31)\n    /// );\n    /// ```\n    pub const fn new(date_time: DateTime\u003cFixedOffset\u003e) -\u003e Self {\n        Self(date_time)\n    }\n\n    /// Returns the date-time of the first sample of the associated media segment.\n    pub const fn date_time(\u0026self) -\u003e DateTime\u003cFixedOffset\u003e {\n        self.0\n    }\n\n    /// Sets the date-time of the first sample of the associated media segment.\n    pub fn set_date_time(\u0026mut self, value: DateTime\u003cFixedOffset\u003e) -\u003e \u0026mut Self {\n        self.0 = value;\n        self\n    }\n}\n\nimpl RequiredVersion for ExtXProgramDateTime {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXProgramDateTime {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let date_time = self.0.to_rfc3339();\n        write!(f, \"{}{}\", Self::PREFIX, date_time)\n    }\n}\n\nimpl FromStr for ExtXProgramDateTime {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let date_time = DateTime::parse_from_rfc3339(input)?;\n        Ok(Self::new(date_time))\n    }\n}\n\nimpl Deref for ExtXProgramDateTime {\n    type Target = DateTime\u003cFixedOffset\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for ExtXProgramDateTime {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use chrono::TimeZone;\n\n    const HOURS_IN_SECS: i32 = 3600; // 1 hour = 3600 seconds\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXProgramDateTime::new(\n                FixedOffset::east(8 * HOURS_IN_SECS)\n                    .ymd(2010, 2, 19)\n                    .and_hms_milli(14, 54, 23, 31)\n            )\n            .to_string(),\n            \"#EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ExtXProgramDateTime::new(\n                FixedOffset::east(8 * HOURS_IN_SECS)\n                    .ymd(2010, 2, 19)\n                    .and_hms_milli(14, 54, 23, 31)\n            ),\n            \"#EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00\"\n                .parse::\u003cExtXProgramDateTime\u003e()\n                .unwrap()\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXProgramDateTime::new(\n                FixedOffset::east(8 * HOURS_IN_SECS)\n                    .ymd(2010, 2, 19)\n                    .and_hms_milli(14, 54, 23, 31),\n            )\n            .required_version(),\n            ProtocolVersion::V1\n        );\n    }\n}\n","traces":[{"line":38,"address":4213568,"length":1,"stats":{"Line":2}},{"line":39,"address":4213575,"length":1,"stats":{"Line":2}},{"line":43,"address":4213616,"length":1,"stats":{"Line":0}},{"line":44,"address":4213624,"length":1,"stats":{"Line":0}},{"line":48,"address":4213648,"length":1,"stats":{"Line":0}},{"line":49,"address":4213656,"length":1,"stats":{"Line":0}},{"line":50,"address":4213694,"length":1,"stats":{"Line":0}},{"line":55,"address":4213712,"length":1,"stats":{"Line":1}},{"line":56,"address":4213720,"length":1,"stats":{"Line":1}},{"line":61,"address":4213744,"length":1,"stats":{"Line":1}},{"line":62,"address":4213761,"length":1,"stats":{"Line":1}},{"line":63,"address":4213797,"length":1,"stats":{"Line":1}},{"line":70,"address":4214144,"length":1,"stats":{"Line":1}},{"line":71,"address":4214171,"length":1,"stats":{"Line":1}},{"line":73,"address":4214635,"length":1,"stats":{"Line":1}},{"line":74,"address":4214826,"length":1,"stats":{"Line":1}},{"line":81,"address":4214976,"length":1,"stats":{"Line":0}},{"line":82,"address":4214981,"length":1,"stats":{"Line":0}},{"line":87,"address":4214992,"length":1,"stats":{"Line":0}},{"line":88,"address":4214997,"length":1,"stats":{"Line":0}},{"line":100,"address":4558352,"length":1,"stats":{"Line":2}},{"line":101,"address":4558570,"length":1,"stats":{"Line":1}},{"line":102,"address":4558508,"length":1,"stats":{"Line":1}},{"line":103,"address":4558359,"length":1,"stats":{"Line":1}},{"line":108,"address":4558538,"length":1,"stats":{"Line":1}},{"line":113,"address":4559088,"length":1,"stats":{"Line":2}},{"line":114,"address":4559273,"length":1,"stats":{"Line":1}},{"line":115,"address":4559212,"length":1,"stats":{"Line":1}},{"line":116,"address":4559095,"length":1,"stats":{"Line":1}},{"line":127,"address":4559664,"length":1,"stats":{"Line":2}},{"line":128,"address":4559817,"length":1,"stats":{"Line":1}},{"line":129,"address":4559788,"length":1,"stats":{"Line":1}},{"line":130,"address":4559671,"length":1,"stats":{"Line":1}}],"covered":24,"coverable":33},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","shared","independent_segments.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::tag;\nuse crate::Error;\n\n/// [4.3.5.1. EXT-X-INDEPENDENT-SEGMENTS]\n///\n/// [4.3.5.1. EXT-X-INDEPENDENT-SEGMENTS]: https://tools.ietf.org/html/rfc8216#section-4.3.5.1\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\npub struct ExtXIndependentSegments;\n\nimpl ExtXIndependentSegments {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-INDEPENDENT-SEGMENTS\";\n}\n\nimpl RequiredVersion for ExtXIndependentSegments {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXIndependentSegments {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Self::PREFIX.fmt(f)\n    }\n}\n\nimpl FromStr for ExtXIndependentSegments {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        tag(input, Self::PREFIX)?;\n        Ok(ExtXIndependentSegments)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXIndependentSegments.to_string(),\n            \"#EXT-X-INDEPENDENT-SEGMENTS\".to_string(),\n        )\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ExtXIndependentSegments,\n            \"#EXT-X-INDEPENDENT-SEGMENTS\".parse().unwrap(),\n        )\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXIndependentSegments.required_version(),\n            ProtocolVersion::V1\n        )\n    }\n}\n","traces":[{"line":19,"address":4375312,"length":1,"stats":{"Line":1}},{"line":20,"address":4375320,"length":1,"stats":{"Line":1}},{"line":25,"address":4375344,"length":1,"stats":{"Line":1}},{"line":26,"address":4375365,"length":1,"stats":{"Line":1}},{"line":33,"address":4375408,"length":1,"stats":{"Line":1}},{"line":34,"address":4375435,"length":1,"stats":{"Line":1}},{"line":35,"address":4375856,"length":1,"stats":{"Line":1}},{"line":44,"address":4674464,"length":1,"stats":{"Line":2}},{"line":45,"address":4674532,"length":1,"stats":{"Line":1}},{"line":46,"address":4674471,"length":1,"stats":{"Line":1}},{"line":47,"address":4674503,"length":1,"stats":{"Line":1}},{"line":52,"address":4675008,"length":1,"stats":{"Line":2}},{"line":53,"address":4675050,"length":1,"stats":{"Line":1}},{"line":55,"address":4675022,"length":1,"stats":{"Line":1}},{"line":60,"address":4675424,"length":1,"stats":{"Line":2}},{"line":61,"address":4675445,"length":1,"stats":{"Line":1}},{"line":62,"address":4675431,"length":1,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","media","hdd","home","projects","hls_m3u8","src","tags","shared","start.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{ProtocolVersion, RequiredVersion, SignedDecimalFloatingPoint};\nuse crate::utils::{parse_yes_or_no, tag};\nuse crate::Error;\n\n/// [4.3.5.2. EXT-X-START]\n///\n/// [4.3.5.2. EXT-X-START]: https://tools.ietf.org/html/rfc8216#section-4.3.5.2\n#[derive(PartialOrd, Debug, Clone, Copy, PartialEq, Eq)]\npub struct ExtXStart {\n    time_offset: SignedDecimalFloatingPoint,\n    precise: bool,\n}\n\nimpl ExtXStart {\n    pub(crate) const PREFIX: \u0026'static str = \"#EXT-X-START:\";\n\n    /// Makes a new `ExtXStart` tag.\n    ///\n    /// # Panic\n    /// Panics if the time_offset value is infinite.\n    pub fn new(time_offset: f64) -\u003e Self {\n        Self {\n            time_offset: SignedDecimalFloatingPoint::new(time_offset),\n            precise: false,\n        }\n    }\n\n    /// Makes a new `ExtXStart` tag with the given `precise` flag.\n    ///\n    /// # Panic\n    /// Panics if the time_offset value is infinite.\n    pub fn with_precise(time_offset: f64, precise: bool) -\u003e Self {\n        Self {\n            time_offset: SignedDecimalFloatingPoint::new(time_offset),\n            precise,\n        }\n    }\n\n    /// Returns the time offset of the media segments in the playlist.\n    pub const fn time_offset(\u0026self) -\u003e f64 {\n        self.time_offset.as_f64()\n    }\n\n    /// Returns whether clients should not render media stream whose presentation times are\n    /// prior to the specified time offset.\n    pub const fn precise(\u0026self) -\u003e bool {\n        self.precise\n    }\n}\n\nimpl RequiredVersion for ExtXStart {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V1\n    }\n}\n\nimpl fmt::Display for ExtXStart {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", Self::PREFIX)?;\n        write!(f, \"TIME-OFFSET={}\", self.time_offset)?;\n        if self.precise {\n            write!(f, \",PRECISE=YES\")?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for ExtXStart {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let input = tag(input, Self::PREFIX)?;\n\n        let mut time_offset = None;\n        let mut precise = false;\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"TIME-OFFSET\" =\u003e time_offset = Some((value.parse())?),\n                \"PRECISE\" =\u003e precise = (parse_yes_or_no(value))?,\n                _ =\u003e {\n                    // [6.3.1. General Client Responsibilities]\n                    // \u003e ignore any attribute/value pair with an unrecognized AttributeName.\n                }\n            }\n        }\n\n        let time_offset = time_offset.ok_or_else(|| Error::missing_value(\"EXT-X-TIME-OFFSET\"))?;\n\n        Ok(ExtXStart {\n            time_offset,\n            precise,\n        })\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            ExtXStart::new(-1.23).to_string(),\n            \"#EXT-X-START:TIME-OFFSET=-1.23\".to_string(),\n        );\n\n        assert_eq!(\n            ExtXStart::with_precise(1.23, true).to_string(),\n            \"#EXT-X-START:TIME-OFFSET=1.23,PRECISE=YES\".to_string(),\n        );\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            ExtXStart::new(-1.23).required_version(),\n            ProtocolVersion::V1,\n        );\n\n        assert_eq!(\n            ExtXStart::with_precise(1.23, true).required_version(),\n            ProtocolVersion::V1,\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ExtXStart::new(-1.23),\n            \"#EXT-X-START:TIME-OFFSET=-1.23\".parse().unwrap(),\n        );\n\n        assert_eq!(\n            ExtXStart::with_precise(1.23, true),\n            \"#EXT-X-START:TIME-OFFSET=1.23,PRECISE=YES\".parse().unwrap(),\n        );\n    }\n}\n","traces":[{"line":25,"address":4578464,"length":1,"stats":{"Line":1}},{"line":27,"address":4578474,"length":1,"stats":{"Line":1}},{"line":36,"address":4578528,"length":1,"stats":{"Line":1}},{"line":38,"address":4578547,"length":1,"stats":{"Line":1}},{"line":44,"address":4578608,"length":1,"stats":{"Line":0}},{"line":45,"address":4578617,"length":1,"stats":{"Line":0}},{"line":50,"address":4578656,"length":1,"stats":{"Line":0}},{"line":51,"address":4578661,"length":1,"stats":{"Line":0}},{"line":56,"address":4578688,"length":1,"stats":{"Line":1}},{"line":57,"address":4578696,"length":1,"stats":{"Line":1}},{"line":62,"address":4578720,"length":1,"stats":{"Line":1}},{"line":63,"address":4578751,"length":1,"stats":{"Line":1}},{"line":64,"address":4579000,"length":1,"stats":{"Line":1}},{"line":65,"address":4579247,"length":1,"stats":{"Line":1}},{"line":66,"address":4579274,"length":1,"stats":{"Line":1}},{"line":68,"address":4579412,"length":1,"stats":{"Line":1}},{"line":75,"address":4579424,"length":1,"stats":{"Line":1}},{"line":76,"address":4579451,"length":1,"stats":{"Line":1}},{"line":78,"address":4579991,"length":1,"stats":{"Line":1}},{"line":79,"address":4580003,"length":1,"stats":{"Line":1}},{"line":81,"address":4580011,"length":1,"stats":{"Line":1}},{"line":82,"address":4580898,"length":1,"stats":{"Line":1}},{"line":83,"address":4580919,"length":1,"stats":{"Line":1}},{"line":84,"address":4581004,"length":1,"stats":{"Line":1}},{"line":85,"address":null,"length":0,"stats":{"Line":0}},{"line":92,"address":4347488,"length":1,"stats":{"Line":1}},{"line":94,"address":4582341,"length":1,"stats":{"Line":1}},{"line":95,"address":4582325,"length":1,"stats":{"Line":1}},{"line":96,"address":4582334,"length":1,"stats":{"Line":1}},{"line":106,"address":4372304,"length":1,"stats":{"Line":2}},{"line":107,"address":4372413,"length":1,"stats":{"Line":1}},{"line":108,"address":4372319,"length":1,"stats":{"Line":1}},{"line":109,"address":4372378,"length":1,"stats":{"Line":1}},{"line":112,"address":4372958,"length":1,"stats":{"Line":1}},{"line":113,"address":4372881,"length":1,"stats":{"Line":1}},{"line":114,"address":4372923,"length":1,"stats":{"Line":1}},{"line":119,"address":4373520,"length":1,"stats":{"Line":2}},{"line":120,"address":4373564,"length":1,"stats":{"Line":1}},{"line":121,"address":4373535,"length":1,"stats":{"Line":1}},{"line":125,"address":4373985,"length":1,"stats":{"Line":1}},{"line":126,"address":4373660,"length":1,"stats":{"Line":1}},{"line":132,"address":4374384,"length":1,"stats":{"Line":2}},{"line":133,"address":4374468,"length":1,"stats":{"Line":1}},{"line":134,"address":4374399,"length":1,"stats":{"Line":1}},{"line":135,"address":4374421,"length":1,"stats":{"Line":1}},{"line":138,"address":4374924,"length":1,"stats":{"Line":1}},{"line":139,"address":4374562,"length":1,"stats":{"Line":1}},{"line":140,"address":4374874,"length":1,"stats":{"Line":1}}],"covered":43,"coverable":48},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","byte_range.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::Error;\n\n/// Byte range.\n///\n/// See: [4.3.2.2. EXT-X-BYTERANGE]\n///\n/// [4.3.2.2. EXT-X-BYTERANGE]: https://tools.ietf.org/html/rfc8216#section-4.3.2.2\n#[derive(Copy, Hash, Eq, Ord, Debug, PartialEq, Clone, PartialOrd)]\npub struct ByteRange {\n    length: usize,\n    start: Option\u003cusize\u003e,\n}\n\nimpl ByteRange {\n    /// Creates a new [ByteRange].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::ByteRange;\n    /// ByteRange::new(22, Some(12));\n    /// ```\n    pub const fn new(length: usize, start: Option\u003cusize\u003e) -\u003e Self {\n        Self { length, start }\n    }\n\n    /// Returns the length of the range.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::ByteRange;\n    /// #\n    /// assert_eq!(ByteRange::new(20, Some(3)).length(), 20);\n    /// ```\n    pub const fn length(\u0026self) -\u003e usize {\n        self.length\n    }\n\n    /// Sets the length of the range.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::ByteRange;\n    /// #\n    /// let mut range = ByteRange::new(20, Some(3));\n    ///\n    /// # assert_eq!(range.length(), 20);\n    /// range.set_length(10);\n    /// assert_eq!(range.length(), 10);\n    /// ```\n    pub fn set_length(\u0026mut self, value: usize) -\u003e \u0026mut Self {\n        self.length = value;\n        self\n    }\n\n    /// Returns the start of the range.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::ByteRange;\n    /// #\n    /// assert_eq!(ByteRange::new(20, Some(3)).start(), Some(3));\n    /// ```\n    pub const fn start(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.start\n    }\n\n    /// Sets the start of the range.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::ByteRange;\n    /// #\n    /// let mut range = ByteRange::new(20, None);\n    ///\n    /// # assert_eq!(range.start(), None);\n    /// range.set_start(Some(3));\n    /// assert_eq!(range.start(), Some(3));\n    /// ```\n    pub fn set_start(\u0026mut self, value: Option\u003cusize\u003e) -\u003e \u0026mut Self {\n        self.start = value;\n        self\n    }\n}\n\nimpl fmt::Display for ByteRange {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.length)?;\n        if let Some(x) = self.start {\n            write!(f, \"@{}\", x)?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for ByteRange {\n    type Err = Error;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let tokens = s.splitn(2, '@').collect::\u003cVec\u003c_\u003e\u003e();\n        if tokens.is_empty() {\n            return Err(Error::invalid_input());\n        }\n\n        let length = tokens[0].parse()?;\n\n        let start = {\n            if tokens.len() == 2 {\n                Some(tokens[1].parse()?)\n            } else {\n                None\n            }\n        };\n        Ok(Self::new(length, start))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let byte_range = ByteRange {\n            length: 0,\n            start: Some(5),\n        };\n        assert_eq!(byte_range.to_string(), \"0@5\".to_string());\n\n        let byte_range = ByteRange {\n            length: 99999,\n            start: Some(2),\n        };\n        assert_eq!(byte_range.to_string(), \"99999@2\".to_string());\n\n        let byte_range = ByteRange {\n            length: 99999,\n            start: None,\n        };\n        assert_eq!(byte_range.to_string(), \"99999\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ByteRange {\n                length: 99999,\n                start: Some(2),\n            },\n            \"99999@2\".parse::\u003cByteRange\u003e().unwrap()\n        );\n\n        assert_eq!(\n            ByteRange {\n                length: 99999,\n                start: Some(2),\n            },\n            \"99999@2\".parse::\u003cByteRange\u003e().unwrap()\n        );\n\n        assert_eq!(\n            ByteRange {\n                length: 99999,\n                start: None,\n            },\n            \"99999\".parse::\u003cByteRange\u003e().unwrap()\n        );\n\n        assert!(\"\".parse::\u003cByteRange\u003e().is_err());\n    }\n}\n","traces":[{"line":25,"address":4211856,"length":1,"stats":{"Line":8}},{"line":37,"address":4211920,"length":1,"stats":{"Line":3}},{"line":38,"address":4211925,"length":1,"stats":{"Line":3}},{"line":53,"address":4211936,"length":1,"stats":{"Line":2}},{"line":54,"address":4211949,"length":1,"stats":{"Line":2}},{"line":55,"address":4211961,"length":1,"stats":{"Line":2}},{"line":66,"address":4211984,"length":1,"stats":{"Line":3}},{"line":67,"address":4211989,"length":1,"stats":{"Line":3}},{"line":82,"address":4212016,"length":1,"stats":{"Line":2}},{"line":83,"address":4212034,"length":1,"stats":{"Line":2}},{"line":84,"address":4212056,"length":1,"stats":{"Line":2}},{"line":89,"address":4212080,"length":1,"stats":{"Line":1}},{"line":90,"address":4212104,"length":1,"stats":{"Line":1}},{"line":91,"address":4212352,"length":1,"stats":{"Line":1}},{"line":92,"address":4212392,"length":1,"stats":{"Line":1}},{"line":94,"address":4212638,"length":1,"stats":{"Line":1}},{"line":101,"address":4212656,"length":1,"stats":{"Line":1}},{"line":102,"address":4212676,"length":1,"stats":{"Line":1}},{"line":103,"address":4212754,"length":1,"stats":{"Line":1}},{"line":104,"address":4212830,"length":1,"stats":{"Line":0}},{"line":107,"address":4212797,"length":1,"stats":{"Line":1}},{"line":109,"address":null,"length":0,"stats":{"Line":0}},{"line":110,"address":4213093,"length":1,"stats":{"Line":1}},{"line":111,"address":4213142,"length":1,"stats":{"Line":1}},{"line":113,"address":4213125,"length":1,"stats":{"Line":1}},{"line":116,"address":4213359,"length":1,"stats":{"Line":1}},{"line":125,"address":4315024,"length":1,"stats":{"Line":2}},{"line":126,"address":5220239,"length":1,"stats":{"Line":1}},{"line":128,"address":5220215,"length":1,"stats":{"Line":1}},{"line":130,"address":5220283,"length":1,"stats":{"Line":1}},{"line":132,"address":5220877,"length":1,"stats":{"Line":1}},{"line":134,"address":5220853,"length":1,"stats":{"Line":1}},{"line":136,"address":5220921,"length":1,"stats":{"Line":1}},{"line":138,"address":5221450,"length":1,"stats":{"Line":1}},{"line":140,"address":5221438,"length":1,"stats":{"Line":1}},{"line":142,"address":5221494,"length":1,"stats":{"Line":1}},{"line":146,"address":4315056,"length":1,"stats":{"Line":2}},{"line":147,"address":5222224,"length":1,"stats":{"Line":1}},{"line":152,"address":5222158,"length":1,"stats":{"Line":1}},{"line":155,"address":5222655,"length":1,"stats":{"Line":1}},{"line":160,"address":5222322,"length":1,"stats":{"Line":1}},{"line":163,"address":5223086,"length":1,"stats":{"Line":1}},{"line":168,"address":5222753,"length":1,"stats":{"Line":1}},{"line":171,"address":5223181,"length":1,"stats":{"Line":1}}],"covered":42,"coverable":44},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","closed_captions.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::utils::{quote, unquote};\nuse crate::Error;\n\n/// The identifier of a closed captions group or its absence.\n///\n/// See: [4.3.4.2. EXT-X-STREAM-INF]\n///\n/// [4.3.4.2. EXT-X-STREAM-INF]: https://tools.ietf.org/html/rfc8216#section-4.3.4.2\n#[allow(missing_docs)]\n#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]\npub enum ClosedCaptions {\n    GroupId(String),\n    None,\n}\n\nimpl fmt::Display for ClosedCaptions {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match \u0026self {\n            Self::GroupId(value) =\u003e write!(f, \"{}\", quote(value)),\n            Self::None =\u003e write!(f, \"NONE\"),\n        }\n    }\n}\n\nimpl FromStr for ClosedCaptions {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if input.trim() == \"NONE\" {\n            Ok(Self::None)\n        } else {\n            Ok(Self::GroupId(unquote(input)))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(ClosedCaptions::None.to_string(), \"NONE\".to_string());\n\n        assert_eq!(\n            ClosedCaptions::GroupId(\"value\".into()).to_string(),\n            \"\\\"value\\\"\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            ClosedCaptions::None,\n            \"NONE\".parse::\u003cClosedCaptions\u003e().unwrap()\n        );\n\n        assert_eq!(\n            ClosedCaptions::GroupId(\"value\".into()),\n            \"\\\"value\\\"\".parse::\u003cClosedCaptions\u003e().unwrap()\n        );\n    }\n}\n","traces":[{"line":20,"address":4682496,"length":1,"stats":{"Line":1}},{"line":21,"address":4682518,"length":1,"stats":{"Line":1}},{"line":22,"address":4682523,"length":1,"stats":{"Line":1}},{"line":23,"address":4682578,"length":1,"stats":{"Line":1}},{"line":31,"address":4682944,"length":1,"stats":{"Line":1}},{"line":32,"address":4682964,"length":1,"stats":{"Line":1}},{"line":33,"address":4683063,"length":1,"stats":{"Line":1}},{"line":35,"address":4683041,"length":1,"stats":{"Line":1}},{"line":45,"address":4527216,"length":1,"stats":{"Line":2}},{"line":46,"address":4527230,"length":1,"stats":{"Line":1}},{"line":48,"address":4527836,"length":1,"stats":{"Line":0}},{"line":49,"address":4527760,"length":1,"stats":{"Line":1}},{"line":50,"address":4527854,"length":1,"stats":{"Line":1}},{"line":55,"address":4528480,"length":1,"stats":{"Line":2}},{"line":56,"address":4528553,"length":1,"stats":{"Line":1}},{"line":58,"address":4528494,"length":1,"stats":{"Line":1}},{"line":61,"address":4529066,"length":1,"stats":{"Line":0}},{"line":62,"address":4528986,"length":1,"stats":{"Line":1}},{"line":63,"address":4529039,"length":1,"stats":{"Line":1}}],"covered":17,"coverable":19},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","decimal_floating_point.rs"],"content":"use core::ops::Deref;\nuse core::str::FromStr;\n\nuse derive_more::Display;\n\nuse crate::Error;\n\n/// Non-negative decimal floating-point number.\n///\n/// See: [4.2. Attribute Lists]\n///\n/// [4.2. Attribute Lists]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-05#section-4.2\n#[derive(Default, Debug, Clone, Copy, PartialEq, PartialOrd, Display)]\npub(crate) struct DecimalFloatingPoint(f64);\n\nimpl DecimalFloatingPoint {\n    /// Makes a new [DecimalFloatingPoint] instance.\n    ///\n    /// # Errors\n    ///\n    /// The given value must have a positive sign and be finite,\n    /// otherwise this function will return an error that has the kind `ErrorKind::InvalidInput`.\n    pub fn new(value: f64) -\u003e crate::Result\u003cSelf\u003e {\n        if value.is_sign_negative() || value.is_infinite() {\n            return Err(Error::invalid_input());\n        }\n        Ok(Self(value))\n    }\n\n    pub(crate) const fn from_f64_unchecked(value: f64) -\u003e Self {\n        Self(value)\n    }\n\n    /// Converts [DecimalFloatingPoint] to [f64].\n    pub const fn as_f64(self) -\u003e f64 {\n        self.0\n    }\n}\n\nimpl Eq for DecimalFloatingPoint {}\n\n// this trait is implemented manually, so it doesn't construct a [DecimalFloatingPoint],\n// with a negative value.\nimpl FromStr for DecimalFloatingPoint {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        Self::new(input.parse()?)\n    }\n}\n\nimpl Deref for DecimalFloatingPoint {\n    type Target = f64;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl From\u003cf64\u003e for DecimalFloatingPoint {\n    fn from(value: f64) -\u003e Self {\n        let mut result = value;\n\n        // guard against the unlikely case of an infinite value...\n        if result.is_infinite() {\n            result = 0.0;\n        }\n\n        Self(result.abs())\n    }\n}\n\nimpl From\u003cf32\u003e for DecimalFloatingPoint {\n    fn from(value: f32) -\u003e Self {\n        (value as f64).into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    macro_rules! test_from {\n        ( $($input:expr),* ) =\u003e {\n            use ::core::convert::From;\n\n            #[test]\n            fn test_from() {\n                $(\n                    assert_eq!(\n                        DecimalFloatingPoint::from($input),\n                        DecimalFloatingPoint::new(1.0).unwrap(),\n                    );\n                )*\n            }\n        }\n    }\n\n    test_from![1u8, 1u16, 1u32, 1.0f32, -1.0f32, 1.0f64, -1.0f64];\n\n    #[test]\n    pub fn test_display() {\n        let decimal_floating_point = DecimalFloatingPoint::new(22.0).unwrap();\n        assert_eq!(decimal_floating_point.to_string(), \"22\".to_string());\n\n        let decimal_floating_point = DecimalFloatingPoint::new(4.1).unwrap();\n        assert_eq!(decimal_floating_point.to_string(), \"4.1\".to_string());\n    }\n\n    #[test]\n    pub fn test_parser() {\n        let decimal_floating_point = DecimalFloatingPoint::new(22.0).unwrap();\n        assert_eq!(\n            decimal_floating_point,\n            \"22\".parse::\u003cDecimalFloatingPoint\u003e().unwrap()\n        );\n\n        let decimal_floating_point = DecimalFloatingPoint::new(4.1).unwrap();\n        assert_eq!(\n            decimal_floating_point,\n            \"4.1\".parse::\u003cDecimalFloatingPoint\u003e().unwrap()\n        );\n\n        assert!(\"1#\".parse::\u003cDecimalFloatingPoint\u003e().is_err());\n        assert!(\"-1.0\".parse::\u003cDecimalFloatingPoint\u003e().is_err());\n    }\n\n    #[test]\n    fn test_new() {\n        assert!(DecimalFloatingPoint::new(::std::f64::INFINITY).is_err());\n        assert!(DecimalFloatingPoint::new(-1.0).is_err());\n    }\n\n    #[test]\n    fn test_as_f64() {\n        assert_eq!(DecimalFloatingPoint::new(1.0).unwrap().as_f64(), 1.0);\n    }\n\n    #[test]\n    fn test_from_inf() {\n        assert_eq!(\n            DecimalFloatingPoint::from(::std::f64::INFINITY),\n            DecimalFloatingPoint::new(0.0).unwrap()\n        );\n    }\n\n    #[test]\n    fn test_deref() {\n        assert_eq!(DecimalFloatingPoint::from(0.1).floor(), 0.0);\n    }\n}\n","traces":[{"line":24,"address":null,"length":0,"stats":{"Line":1}},{"line":25,"address":4416256,"length":1,"stats":{"Line":1}},{"line":26,"address":4416386,"length":1,"stats":{"Line":1}},{"line":28,"address":null,"length":0,"stats":{"Line":1}},{"line":31,"address":null,"length":0,"stats":{"Line":1}},{"line":32,"address":4416473,"length":1,"stats":{"Line":1}},{"line":36,"address":null,"length":0,"stats":{"Line":1}},{"line":37,"address":4416502,"length":1,"stats":{"Line":1}},{"line":41,"address":4472064,"length":1,"stats":{"Line":0}},{"line":43,"address":4472103,"length":1,"stats":{"Line":0}},{"line":45,"address":4472112,"length":1,"stats":{"Line":0}},{"line":46,"address":4472125,"length":1,"stats":{"Line":0}},{"line":48,"address":null,"length":0,"stats":{"Line":1}},{"line":49,"address":null,"length":0,"stats":{"Line":1}},{"line":56,"address":null,"length":0,"stats":{"Line":1}},{"line":57,"address":null,"length":0,"stats":{"Line":1}},{"line":62,"address":null,"length":0,"stats":{"Line":1}},{"line":63,"address":null,"length":0,"stats":{"Line":1}},{"line":65,"address":4472352,"length":1,"stats":{"Line":0}},{"line":66,"address":4416742,"length":1,"stats":{"Line":1}},{"line":67,"address":4416767,"length":1,"stats":{"Line":1}},{"line":70,"address":null,"length":0,"stats":{"Line":1}},{"line":74,"address":4723673,"length":1,"stats":{"Line":0}},{"line":75,"address":null,"length":0,"stats":{"Line":1}},{"line":76,"address":null,"length":0,"stats":{"Line":1}},{"line":85,"address":4472488,"length":1,"stats":{"Line":0}},{"line":86,"address":4472515,"length":1,"stats":{"Line":0}},{"line":89,"address":4793376,"length":1,"stats":{"Line":2}},{"line":90,"address":4472528,"length":1,"stats":{"Line":0}},{"line":91,"address":4472538,"length":1,"stats":{"Line":1}},{"line":92,"address":4472566,"length":1,"stats":{"Line":1}},{"line":93,"address":4723830,"length":1,"stats":{"Line":1}},{"line":103,"address":4793408,"length":1,"stats":{"Line":2}},{"line":104,"address":5214351,"length":1,"stats":{"Line":1}},{"line":105,"address":5214400,"length":1,"stats":{"Line":1}},{"line":107,"address":5214922,"length":1,"stats":{"Line":1}},{"line":108,"address":5214957,"length":1,"stats":{"Line":1}},{"line":112,"address":4793440,"length":1,"stats":{"Line":2}},{"line":113,"address":5215583,"length":1,"stats":{"Line":1}},{"line":114,"address":5215676,"length":1,"stats":{"Line":1}},{"line":116,"address":5215633,"length":1,"stats":{"Line":1}},{"line":119,"address":5215780,"length":1,"stats":{"Line":1}},{"line":120,"address":5216149,"length":1,"stats":{"Line":1}},{"line":122,"address":5216106,"length":1,"stats":{"Line":1}},{"line":125,"address":5216255,"length":1,"stats":{"Line":1}},{"line":126,"address":5216639,"length":1,"stats":{"Line":1}},{"line":130,"address":4793472,"length":1,"stats":{"Line":2}},{"line":131,"address":5216863,"length":1,"stats":{"Line":1}},{"line":132,"address":5216958,"length":1,"stats":{"Line":1}},{"line":136,"address":4793504,"length":1,"stats":{"Line":2}},{"line":137,"address":5217167,"length":1,"stats":{"Line":1}},{"line":141,"address":4793536,"length":1,"stats":{"Line":2}},{"line":142,"address":5217655,"length":1,"stats":{"Line":1}},{"line":143,"address":5217615,"length":1,"stats":{"Line":1}},{"line":144,"address":5217626,"length":1,"stats":{"Line":1}},{"line":149,"address":4793568,"length":1,"stats":{"Line":2}},{"line":150,"address":5218047,"length":1,"stats":{"Line":1}}],"covered":48,"coverable":57},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","decimal_resolution.rs"],"content":"use std::str::FromStr;\n\nuse derive_more::Display;\n\nuse crate::Error;\n\n/// Decimal resolution.\n///\n/// See: [4.2. Attribute Lists]\n///\n/// [4.2. Attribute Lists]: https://tools.ietf.org/html/rfc8216#section-4.2\n#[derive(Ord, PartialOrd, Debug, Clone, Copy, PartialEq, Eq, Hash, Display)]\n#[display(fmt = \"{}x{}\", width, height)]\npub(crate) struct DecimalResolution {\n    width: usize,\n    height: usize,\n}\n\nimpl DecimalResolution {\n    /// Creates a new DecimalResolution.\n    pub const fn new(width: usize, height: usize) -\u003e Self {\n        Self { width, height }\n    }\n\n    /// Horizontal pixel dimension.\n    pub const fn width(\u0026self) -\u003e usize {\n        self.width\n    }\n\n    /// Sets Horizontal pixel dimension.\n    pub fn set_width(\u0026mut self, value: usize) -\u003e \u0026mut Self {\n        self.width = value;\n        self\n    }\n\n    /// Vertical pixel dimension.\n    pub const fn height(\u0026self) -\u003e usize {\n        self.height\n    }\n\n    /// Sets Vertical pixel dimension.\n    pub fn set_height(\u0026mut self, value: usize) -\u003e \u0026mut Self {\n        self.height = value;\n        self\n    }\n}\n\n/// [DecimalResolution] can be constructed from a tuple; `(width, height)`.\nimpl From\u003c(usize, usize)\u003e for DecimalResolution {\n    fn from(value: (usize, usize)) -\u003e Self {\n        DecimalResolution::new(value.0, value.1)\n    }\n}\n\nimpl FromStr for DecimalResolution {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let tokens = input.splitn(2, 'x').collect::\u003cVec\u003c_\u003e\u003e();\n\n        if tokens.len() != 2 {\n            return Err(Error::custom(format!(\n                \"InvalidInput: Expected input format: [width]x[height] (ex. 1920x1080), got {:?}\",\n                input,\n            )));\n        }\n\n        Ok(Self {\n            width: tokens[0].parse()?,\n            height: tokens[1].parse()?,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            DecimalResolution::new(1920, 1080).to_string(),\n            \"1920x1080\".to_string()\n        );\n\n        assert_eq!(\n            DecimalResolution::new(1280, 720).to_string(),\n            \"1280x720\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            DecimalResolution::new(1920, 1080),\n            \"1920x1080\".parse::\u003cDecimalResolution\u003e().unwrap()\n        );\n\n        assert_eq!(\n            DecimalResolution::new(1280, 720),\n            \"1280x720\".parse::\u003cDecimalResolution\u003e().unwrap()\n        );\n\n        assert!(\"1280\".parse::\u003cDecimalResolution\u003e().is_err());\n    }\n\n    #[test]\n    fn test_width() {\n        assert_eq!(DecimalResolution::new(1920, 1080).width(), 1920);\n        assert_eq!(DecimalResolution::new(1920, 1080).set_width(12).width(), 12);\n    }\n\n    #[test]\n    fn test_height() {\n        assert_eq!(DecimalResolution::new(1920, 1080).height(), 1080);\n        assert_eq!(\n            DecimalResolution::new(1920, 1080).set_height(12).height(),\n            12\n        );\n    }\n\n    #[test]\n    fn test_from() {\n        assert_eq!(\n            DecimalResolution::from((1920, 1080)),\n            DecimalResolution::new(1920, 1080)\n        );\n    }\n}\n","traces":[{"line":21,"address":4278032,"length":1,"stats":{"Line":2}},{"line":26,"address":4278080,"length":1,"stats":{"Line":2}},{"line":27,"address":4278085,"length":1,"stats":{"Line":2}},{"line":31,"address":4278096,"length":1,"stats":{"Line":2}},{"line":32,"address":4278109,"length":1,"stats":{"Line":2}},{"line":33,"address":4278121,"length":1,"stats":{"Line":2}},{"line":37,"address":4278144,"length":1,"stats":{"Line":2}},{"line":38,"address":4278149,"length":1,"stats":{"Line":2}},{"line":42,"address":4278160,"length":1,"stats":{"Line":2}},{"line":43,"address":4278173,"length":1,"stats":{"Line":2}},{"line":44,"address":4278186,"length":1,"stats":{"Line":2}},{"line":50,"address":null,"length":0,"stats":{"Line":1}},{"line":51,"address":null,"length":0,"stats":{"Line":1}},{"line":58,"address":null,"length":0,"stats":{"Line":1}},{"line":59,"address":null,"length":0,"stats":{"Line":1}},{"line":61,"address":null,"length":0,"stats":{"Line":1}},{"line":62,"address":4278458,"length":1,"stats":{"Line":1}},{"line":63,"address":4278450,"length":1,"stats":{"Line":1}},{"line":64,"address":null,"length":0,"stats":{"Line":0}},{"line":68,"address":null,"length":0,"stats":{"Line":1}},{"line":69,"address":null,"length":0,"stats":{"Line":1}},{"line":70,"address":null,"length":0,"stats":{"Line":1}},{"line":80,"address":5206688,"length":1,"stats":{"Line":2}},{"line":81,"address":5523791,"length":1,"stats":{"Line":1}},{"line":82,"address":5523697,"length":1,"stats":{"Line":1}},{"line":83,"address":5523756,"length":1,"stats":{"Line":1}},{"line":86,"address":5524333,"length":1,"stats":{"Line":1}},{"line":87,"address":5524256,"length":1,"stats":{"Line":1}},{"line":88,"address":5524298,"length":1,"stats":{"Line":1}},{"line":93,"address":5206720,"length":1,"stats":{"Line":2}},{"line":94,"address":5525002,"length":1,"stats":{"Line":1}},{"line":95,"address":5524913,"length":1,"stats":{"Line":1}},{"line":96,"address":5524952,"length":1,"stats":{"Line":1}},{"line":99,"address":5525458,"length":1,"stats":{"Line":1}},{"line":100,"address":5525096,"length":1,"stats":{"Line":1}},{"line":101,"address":5525408,"length":1,"stats":{"Line":1}},{"line":104,"address":5525564,"length":1,"stats":{"Line":1}},{"line":108,"address":5206752,"length":1,"stats":{"Line":2}},{"line":109,"address":5526017,"length":1,"stats":{"Line":1}},{"line":110,"address":5526126,"length":1,"stats":{"Line":1}},{"line":114,"address":5206784,"length":1,"stats":{"Line":2}},{"line":115,"address":5526881,"length":1,"stats":{"Line":1}},{"line":116,"address":5527339,"length":1,"stats":{"Line":1}},{"line":117,"address":5526990,"length":1,"stats":{"Line":1}},{"line":123,"address":5206816,"length":1,"stats":{"Line":2}},{"line":124,"address":5527803,"length":1,"stats":{"Line":1}},{"line":125,"address":5527735,"length":1,"stats":{"Line":1}},{"line":126,"address":5527788,"length":1,"stats":{"Line":1}}],"covered":47,"coverable":48},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","decryption_key.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse derive_builder::Builder;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{\n    EncryptionMethod, InitializationVector, KeyFormat, KeyFormatVersions, ProtocolVersion,\n    RequiredVersion,\n};\nuse crate::utils::{quote, unquote};\nuse crate::Error;\n\n#[derive(Builder, Debug, Clone, PartialEq, Eq, Hash)]\n#[builder(setter(into), build_fn(validate = \"Self::validate\"))]\n/// [DecryptionKey] contains data, that is shared between [ExtXSessionKey] and [ExtXKey].\n///\n/// [ExtXSessionKey]: crate::tags::ExtXSessionKey\n/// [ExtXKey]: crate::tags::ExtXKey\npub struct DecryptionKey {\n    /// The [EncryptionMethod].\n    pub(crate) method: EncryptionMethod,\n    #[builder(setter(into, strip_option), default)]\n    /// An `URI`, that specifies how to obtain the key.\n    pub(crate) uri: Option\u003cString\u003e,\n    #[builder(setter(into, strip_option), default)]\n    /// The IV (Initialization Vector) attribute.\n    pub(crate) iv: Option\u003cInitializationVector\u003e,\n    #[builder(setter(into, strip_option), default)]\n    /// A string that specifies how the key is\n    /// represented in the resource identified by the `URI`.\n    pub(crate) key_format: Option\u003cKeyFormat\u003e,\n    #[builder(setter(into, strip_option), default)]\n    /// The [KeyFormatVersions] attribute.\n    pub(crate) key_format_versions: Option\u003cKeyFormatVersions\u003e,\n}\n\nimpl DecryptionKeyBuilder {\n    fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n        if self.method != Some(EncryptionMethod::None) \u0026\u0026 self.uri.is_none() {\n            return Err(Error::custom(\"Missing URL\").to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl DecryptionKey {\n    /// Makes a new [DecryptionKey].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    /// ```\n    pub fn new\u003cT: ToString\u003e(method: EncryptionMethod, uri: T) -\u003e Self {\n        Self {\n            method,\n            uri: Some(uri.to_string()),\n            iv: None,\n            key_format: None,\n            key_format_versions: None,\n        }\n    }\n\n    /// Returns the [EncryptionMethod].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// assert_eq!(\n    ///     key.method(),\n    ///     EncryptionMethod::Aes128\n    /// );\n    /// ```\n    pub const fn method(\u0026self) -\u003e EncryptionMethod {\n        self.method\n    }\n\n    /// Returns a Builder to build a [DecryptionKey].\n    pub fn builder() -\u003e DecryptionKeyBuilder {\n        DecryptionKeyBuilder::default()\n    }\n\n    /// Sets the [EncryptionMethod].\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// key.set_method(EncryptionMethod::SampleAes);\n    ///\n    /// assert_eq!(\n    ///     key.to_string(),\n    ///     \"METHOD=SAMPLE-AES,URI=\\\"https://www.example.com/\\\"\".to_string()\n    /// );\n    /// ```\n    pub fn set_method(\u0026mut self, value: EncryptionMethod) -\u003e \u0026mut Self {\n        self.method = value;\n        self\n    }\n\n    /// Returns an `URI`, that specifies how to obtain the key.\n    ///\n    /// # Note\n    /// This attribute is required, if the [EncryptionMethod] is not `None`.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// assert_eq!(\n    ///     key.uri(),\n    ///     \u0026Some(\"https://www.example.com/\".to_string())\n    /// );\n    /// ```\n    pub const fn uri(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.uri\n    }\n\n    /// Sets the `URI` attribute.\n    ///\n    /// # Note\n    /// This attribute is required, if the [EncryptionMethod] is not `None`.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// key.set_uri(Some(\"http://www.google.com/\"));\n    ///\n    /// assert_eq!(\n    ///     key.to_string(),\n    ///     \"METHOD=AES-128,URI=\\\"http://www.google.com/\\\"\".to_string()\n    /// );\n    /// ```\n    pub fn set_uri\u003cT: ToString\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.uri = value.map(|v| v.to_string());\n        self\n    }\n\n    /// Returns the IV (Initialization Vector) attribute.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// # assert_eq!(key.iv(), None);\n    /// key.set_iv(Some([\n    ///    1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7\n    /// ]));\n    ///\n    /// assert_eq!(\n    ///     key.iv(),\n    ///     Some([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7])\n    /// );\n    /// ```\n    pub fn iv(\u0026self) -\u003e Option\u003c[u8; 16]\u003e {\n        if let Some(iv) = \u0026self.iv {\n            Some(iv.to_slice())\n        } else {\n            None\n        }\n    }\n\n    /// Sets the `IV` attribute.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// key.set_iv(Some([\n    ///    1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7\n    /// ]));\n    ///\n    /// assert_eq!(\n    ///     key.to_string(),\n    ///     \"METHOD=AES-128,URI=\\\"https://www.example.com/\\\",IV=0x01020304050607080901020304050607\".to_string()\n    /// );\n    /// ```\n    pub fn set_iv\u003cT\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self\n    where\n        T: Into\u003c[u8; 16]\u003e,\n    {\n        self.iv = value.map(|v| InitializationVector(v.into()));\n        self\n    }\n\n    /// Returns a string that specifies how the key is\n    /// represented in the resource identified by the `URI`.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::{KeyFormat, EncryptionMethod};\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// key.set_key_format(Some(KeyFormat::Identity));\n    ///\n    /// assert_eq!(\n    ///     key.key_format(),\n    ///     Some(KeyFormat::Identity)\n    /// );\n    /// ```\n    pub const fn key_format(\u0026self) -\u003e Option\u003cKeyFormat\u003e {\n        self.key_format\n    }\n\n    /// Sets the [KeyFormat] attribute.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::{KeyFormat, EncryptionMethod};\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// key.set_key_format(Some(KeyFormat::Identity));\n    ///\n    /// assert_eq!(\n    ///     key.key_format(),\n    ///     Some(KeyFormat::Identity)\n    /// );\n    /// ```\n    pub fn set_key_format\u003cT: Into\u003cKeyFormat\u003e\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.key_format = value.map(|v| v.into());\n        self\n    }\n\n    /// Returns the [KeyFormatVersions] attribute.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::{KeyFormatVersions, EncryptionMethod};\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// key.set_key_format_versions(Some(vec![1, 2, 3, 4, 5]));\n    ///\n    /// assert_eq!(\n    ///     key.key_format_versions(),\n    ///     \u0026Some(KeyFormatVersions::from(vec![1, 2, 3, 4, 5]))\n    /// );\n    /// ```\n    pub const fn key_format_versions(\u0026self) -\u003e \u0026Option\u003cKeyFormatVersions\u003e {\n        \u0026self.key_format_versions\n    }\n\n    /// Sets the [KeyFormatVersions] attribute.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::DecryptionKey;\n    /// use hls_m3u8::types::EncryptionMethod;\n    ///\n    /// let mut key = DecryptionKey::new(\n    ///     EncryptionMethod::Aes128,\n    ///     \"https://www.example.com/\"\n    /// );\n    ///\n    /// key.set_key_format_versions(Some(vec![1, 2, 3, 4, 5]));\n    ///\n    /// assert_eq!(\n    ///     key.to_string(),\n    ///     \"METHOD=AES-128,URI=\\\"https://www.example.com/\\\",KEYFORMATVERSIONS=\\\"1/2/3/4/5\\\"\".to_string()\n    /// );\n    /// ```\n    pub fn set_key_format_versions\u003cT: Into\u003cKeyFormatVersions\u003e\u003e(\n        \u0026mut self,\n        value: Option\u003cT\u003e,\n    ) -\u003e \u0026mut Self {\n        self.key_format_versions = value.map(|v| v.into());\n        self\n    }\n}\n\nimpl RequiredVersion for DecryptionKey {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        if self.key_format.is_some() || self.key_format_versions.is_some() {\n            ProtocolVersion::V5\n        } else if self.iv.is_some() {\n            ProtocolVersion::V2\n        } else {\n            ProtocolVersion::V1\n        }\n    }\n}\n\nimpl FromStr for DecryptionKey {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut method = None;\n        let mut uri = None;\n        let mut iv = None;\n        let mut key_format = None;\n        let mut key_format_versions = None;\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"METHOD\" =\u003e method = Some(value.parse()?),\n                \"URI\" =\u003e uri = Some(unquote(value)),\n                \"IV\" =\u003e iv = Some(value.parse()?),\n                \"KEYFORMAT\" =\u003e key_format = Some(value.parse()?),\n                \"KEYFORMATVERSIONS\" =\u003e key_format_versions = Some(value.parse()?),\n                _ =\u003e {\n                    // [6.3.1. General Client Responsibilities]\n                    // \u003e ignore any attribute/value pair with an unrecognized AttributeName.\n                }\n            }\n        }\n\n        let method = method.ok_or_else(|| Error::missing_value(\"METHOD\"))?;\n        if method != EncryptionMethod::None \u0026\u0026 uri.is_none() {\n            return Err(Error::missing_value(\"URI\"));\n        }\n\n        Ok(Self {\n            method,\n            uri,\n            iv,\n            key_format,\n            key_format_versions,\n        })\n    }\n}\n\nimpl fmt::Display for DecryptionKey {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"METHOD={}\", self.method)?;\n\n        if self.method == EncryptionMethod::None {\n            return Ok(());\n        }\n        if let Some(uri) = \u0026self.uri {\n            write!(f, \",URI={}\", quote(uri))?;\n        }\n        if let Some(value) = \u0026self.iv {\n            write!(f, \",IV={}\", value)?;\n        }\n        if let Some(value) = \u0026self.key_format {\n            write!(f, \",KEYFORMAT={}\", quote(value))?;\n        }\n\n        if let Some(key_format_versions) = \u0026self.key_format_versions {\n            if !key_format_versions.is_default() {\n                write!(f, \",KEYFORMATVERSIONS={}\", key_format_versions)?;\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::types::EncryptionMethod;\n\n    #[test]\n    fn test_builder() {\n        let key = DecryptionKey::builder()\n            .method(EncryptionMethod::Aes128)\n            .uri(\"https://www.example.com/\")\n            .iv([\n                16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n            ])\n            .key_format(KeyFormat::Identity)\n            .key_format_versions(vec![1, 2, 3, 4, 5])\n            .build()\n            .unwrap();\n\n        assert_eq!(\n            key.to_string(),\n            \"METHOD=AES-128,\\\n             URI=\\\"https://www.example.com/\\\",\\\n             IV=0x10ef8f758ca555115584bb5b3c687f52,\\\n             KEYFORMAT=\\\"identity\\\",\\\n             KEYFORMATVERSIONS=\\\"1/2/3/4/5\\\"\\\n             \"\n            .to_string()\n        );\n\n        assert!(DecryptionKey::builder().build().is_err());\n        assert!(DecryptionKey::builder()\n            .method(EncryptionMethod::Aes128)\n            .build()\n            .is_err());\n    }\n\n    #[test]\n    fn test_display() {\n        let mut key = DecryptionKey::new(\n            EncryptionMethod::Aes128,\n            \"https://www.example.com/hls-key/key.bin\",\n        );\n        key.set_iv(Some([\n            16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n        ]));\n\n        assert_eq!(\n            key.to_string(),\n            \"METHOD=AES-128,\\\n             URI=\\\"https://www.example.com/hls-key/key.bin\\\",\\\n             IV=0x10ef8f758ca555115584bb5b3c687f52\"\n                .to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            \"METHOD=AES-128,\\\n             URI=\\\"https://priv.example.com/key.php?r=52\\\"\"\n                .parse::\u003cDecryptionKey\u003e()\n                .unwrap(),\n            DecryptionKey::new(\n                EncryptionMethod::Aes128,\n                \"https://priv.example.com/key.php?r=52\"\n            )\n        );\n\n        let mut key = DecryptionKey::new(\n            EncryptionMethod::Aes128,\n            \"https://www.example.com/hls-key/key.bin\",\n        );\n        key.set_iv(Some([\n            16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n        ]));\n\n        assert_eq!(\n            \"METHOD=AES-128,\\\n             URI=\\\"https://www.example.com/hls-key/key.bin\\\",\\\n             IV=0X10ef8f758ca555115584bb5b3c687f52\"\n                .parse::\u003cDecryptionKey\u003e()\n                .unwrap(),\n            key\n        );\n\n        let mut key = DecryptionKey::new(EncryptionMethod::Aes128, \"http://www.example.com\");\n        key.set_iv(Some([\n            16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82,\n        ]));\n        key.set_key_format(Some(KeyFormat::Identity));\n\n        assert_eq!(\n            \"METHOD=AES-128,\\\n             URI=\\\"http://www.example.com\\\",\\\n             IV=0x10ef8f758ca555115584bb5b3c687f52,\\\n             KEYFORMAT=\\\"identity\\\"\"\n                .parse::\u003cDecryptionKey\u003e()\n                .unwrap(),\n            key\n        );\n\n        key.set_key_format_versions(Some(vec![1, 2, 3]));\n        assert_eq!(\n            \"METHOD=AES-128,\\\n             URI=\\\"http://www.example.com\\\",\\\n             IV=0x10ef8f758ca555115584bb5b3c687f52,\\\n             KEYFORMAT=\\\"identity\\\",\\\n             KEYFORMATVERSIONS=\\\"1/2/3\\\"\"\n                .parse::\u003cDecryptionKey\u003e()\n                .unwrap(),\n            key\n        );\n\n        assert_eq!(\n            \"METHOD=AES-128,\\\n             URI=\\\"http://www.example.com\\\",\\\n             UNKNOWNTAG=abcd\"\n                .parse::\u003cDecryptionKey\u003e()\n                .unwrap(),\n            DecryptionKey::new(EncryptionMethod::Aes128, \"http://www.example.com\")\n        );\n        assert!(\"METHOD=AES-128,URI=\".parse::\u003cDecryptionKey\u003e().is_err());\n        assert!(\"garbage\".parse::\u003cDecryptionKey\u003e().is_err());\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            DecryptionKey::new(EncryptionMethod::Aes128, \"https://www.example.com/\")\n                .required_version(),\n            ProtocolVersion::V1\n        );\n\n        assert_eq!(\n            DecryptionKey::builder()\n                .method(EncryptionMethod::Aes128)\n                .uri(\"https://www.example.com/\")\n                .key_format(KeyFormat::Identity)\n                .key_format_versions(vec![1, 2, 3])\n                .build()\n                .unwrap()\n                .required_version(),\n            ProtocolVersion::V5\n        );\n\n        assert_eq!(\n            DecryptionKey::builder()\n                .method(EncryptionMethod::Aes128)\n                .uri(\"https://www.example.com/\")\n                .iv([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7])\n                .build()\n                .unwrap()\n                .required_version(),\n            ProtocolVersion::V2\n        );\n    }\n}\n","traces":[{"line":39,"address":null,"length":0,"stats":{"Line":1}},{"line":40,"address":null,"length":0,"stats":{"Line":1}},{"line":41,"address":null,"length":0,"stats":{"Line":1}},{"line":43,"address":null,"length":0,"stats":{"Line":1}},{"line":60,"address":null,"length":0,"stats":{"Line":14}},{"line":63,"address":null,"length":0,"stats":{"Line":14}},{"line":87,"address":null,"length":0,"stats":{"Line":3}},{"line":88,"address":null,"length":0,"stats":{"Line":3}},{"line":92,"address":null,"length":0,"stats":{"Line":1}},{"line":115,"address":null,"length":0,"stats":{"Line":2}},{"line":116,"address":null,"length":0,"stats":{"Line":2}},{"line":117,"address":null,"length":0,"stats":{"Line":2}},{"line":140,"address":null,"length":0,"stats":{"Line":2}},{"line":141,"address":null,"length":0,"stats":{"Line":2}},{"line":166,"address":null,"length":0,"stats":{"Line":2}},{"line":167,"address":null,"length":0,"stats":{"Line":4}},{"line":168,"address":null,"length":0,"stats":{"Line":2}},{"line":193,"address":null,"length":0,"stats":{"Line":1}},{"line":194,"address":null,"length":0,"stats":{"Line":1}},{"line":195,"address":null,"length":0,"stats":{"Line":1}},{"line":197,"address":null,"length":0,"stats":{"Line":1}},{"line":222,"address":4213616,"length":1,"stats":{"Line":3}},{"line":226,"address":null,"length":0,"stats":{"Line":6}},{"line":227,"address":null,"length":0,"stats":{"Line":3}},{"line":250,"address":null,"length":0,"stats":{"Line":2}},{"line":251,"address":null,"length":0,"stats":{"Line":2}},{"line":273,"address":null,"length":0,"stats":{"Line":3}},{"line":274,"address":null,"length":0,"stats":{"Line":6}},{"line":275,"address":null,"length":0,"stats":{"Line":3}},{"line":297,"address":null,"length":0,"stats":{"Line":1}},{"line":298,"address":null,"length":0,"stats":{"Line":1}},{"line":320,"address":null,"length":0,"stats":{"Line":3}},{"line":324,"address":null,"length":0,"stats":{"Line":6}},{"line":325,"address":null,"length":0,"stats":{"Line":3}},{"line":329,"address":4252737,"length":1,"stats":{"Line":0}},{"line":330,"address":null,"length":0,"stats":{"Line":1}},{"line":331,"address":null,"length":0,"stats":{"Line":1}},{"line":332,"address":null,"length":0,"stats":{"Line":1}},{"line":333,"address":null,"length":0,"stats":{"Line":1}},{"line":334,"address":null,"length":0,"stats":{"Line":1}},{"line":336,"address":null,"length":0,"stats":{"Line":1}},{"line":341,"address":4257508,"length":1,"stats":{"Line":0}},{"line":342,"address":4252896,"length":1,"stats":{"Line":0}},{"line":344,"address":4252848,"length":1,"stats":{"Line":1}},{"line":345,"address":4252880,"length":1,"stats":{"Line":1}},{"line":346,"address":4252952,"length":1,"stats":{"Line":1}},{"line":347,"address":4252964,"length":1,"stats":{"Line":1}},{"line":348,"address":4252972,"length":1,"stats":{"Line":1}},{"line":349,"address":null,"length":0,"stats":{"Line":1}},{"line":351,"address":null,"length":0,"stats":{"Line":1}},{"line":352,"address":null,"length":0,"stats":{"Line":1}},{"line":353,"address":null,"length":0,"stats":{"Line":1}},{"line":354,"address":null,"length":0,"stats":{"Line":1}},{"line":355,"address":null,"length":0,"stats":{"Line":1}},{"line":356,"address":4254248,"length":1,"stats":{"Line":1}},{"line":357,"address":null,"length":0,"stats":{"Line":1}},{"line":358,"address":null,"length":0,"stats":{"Line":0}},{"line":359,"address":4261533,"length":1,"stats":{"Line":0}},{"line":360,"address":4261801,"length":1,"stats":{"Line":0}},{"line":365,"address":4256499,"length":1,"stats":{"Line":2}},{"line":366,"address":4256939,"length":1,"stats":{"Line":1}},{"line":367,"address":null,"length":0,"stats":{"Line":1}},{"line":370,"address":null,"length":0,"stats":{"Line":1}},{"line":371,"address":null,"length":0,"stats":{"Line":1}},{"line":372,"address":null,"length":0,"stats":{"Line":5}},{"line":373,"address":null,"length":0,"stats":{"Line":5}},{"line":374,"address":null,"length":0,"stats":{"Line":3}},{"line":375,"address":4257154,"length":1,"stats":{"Line":7}},{"line":380,"address":4264025,"length":1,"stats":{"Line":2}},{"line":381,"address":4258880,"length":1,"stats":{"Line":13}},{"line":382,"address":null,"length":0,"stats":{"Line":8}},{"line":384,"address":4259236,"length":1,"stats":{"Line":11}},{"line":385,"address":null,"length":0,"stats":{"Line":2}},{"line":387,"address":null,"length":0,"stats":{"Line":6}},{"line":388,"address":null,"length":0,"stats":{"Line":10}},{"line":390,"address":4259766,"length":1,"stats":{"Line":8}},{"line":391,"address":null,"length":0,"stats":{"Line":2}},{"line":393,"address":4260097,"length":1,"stats":{"Line":12}},{"line":394,"address":null,"length":0,"stats":{"Line":5}},{"line":397,"address":null,"length":0,"stats":{"Line":6}},{"line":398,"address":null,"length":0,"stats":{"Line":2}},{"line":399,"address":null,"length":0,"stats":{"Line":2}},{"line":402,"address":null,"length":0,"stats":{"Line":6}},{"line":412,"address":5241296,"length":1,"stats":{"Line":2}},{"line":413,"address":5297415,"length":1,"stats":{"Line":1}},{"line":414,"address":5297445,"length":1,"stats":{"Line":1}},{"line":416,"address":5297525,"length":1,"stats":{"Line":1}},{"line":420,"address":5297705,"length":1,"stats":{"Line":1}},{"line":422,"address":5297510,"length":1,"stats":{"Line":0}},{"line":424,"address":5297922,"length":1,"stats":{"Line":1}},{"line":425,"address":5297880,"length":1,"stats":{"Line":1}},{"line":435,"address":5298393,"length":1,"stats":{"Line":1}},{"line":436,"address":5298533,"length":1,"stats":{"Line":1}},{"line":437,"address":5298573,"length":1,"stats":{"Line":1}},{"line":443,"address":5241328,"length":1,"stats":{"Line":2}},{"line":444,"address":5298966,"length":1,"stats":{"Line":1}},{"line":445,"address":5298958,"length":1,"stats":{"Line":1}},{"line":448,"address":5299009,"length":1,"stats":{"Line":1}},{"line":452,"address":5299251,"length":1,"stats":{"Line":1}},{"line":453,"address":5299194,"length":1,"stats":{"Line":1}},{"line":462,"address":5241360,"length":1,"stats":{"Line":2}},{"line":463,"address":5299908,"length":1,"stats":{"Line":0}},{"line":468,"address":5299873,"length":1,"stats":{"Line":1}},{"line":469,"address":5299865,"length":1,"stats":{"Line":1}},{"line":474,"address":5300434,"length":1,"stats":{"Line":1}},{"line":475,"address":5300426,"length":1,"stats":{"Line":1}},{"line":478,"address":5300463,"length":1,"stats":{"Line":1}},{"line":482,"address":5300714,"length":1,"stats":{"Line":1}},{"line":491,"address":5301187,"length":1,"stats":{"Line":1}},{"line":492,"address":5301230,"length":1,"stats":{"Line":1}},{"line":495,"address":5301405,"length":1,"stats":{"Line":1}},{"line":497,"address":5301512,"length":1,"stats":{"Line":1}},{"line":507,"address":5301995,"length":1,"stats":{"Line":1}},{"line":508,"address":5302159,"length":1,"stats":{"Line":1}},{"line":519,"address":5302683,"length":1,"stats":{"Line":0}},{"line":525,"address":5302640,"length":1,"stats":{"Line":1}},{"line":527,"address":5303157,"length":1,"stats":{"Line":1}},{"line":528,"address":5303256,"length":1,"stats":{"Line":1}},{"line":532,"address":5241392,"length":1,"stats":{"Line":2}},{"line":533,"address":5303792,"length":1,"stats":{"Line":1}},{"line":534,"address":5303694,"length":1,"stats":{"Line":1}},{"line":539,"address":5304351,"length":1,"stats":{"Line":0}},{"line":540,"address":5304264,"length":1,"stats":{"Line":1}},{"line":541,"address":5304277,"length":1,"stats":{"Line":1}},{"line":544,"address":5304402,"length":1,"stats":{"Line":1}},{"line":551,"address":5305101,"length":1,"stats":{"Line":0}},{"line":552,"address":5305023,"length":1,"stats":{"Line":1}},{"line":553,"address":5305036,"length":1,"stats":{"Line":1}},{"line":555,"address":5305119,"length":1,"stats":{"Line":1}}],"covered":118,"coverable":129},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","encryption_method.rs"],"content":"use strum::{Display, EnumString};\n\n/// Encryption method.\n///\n/// See: [4.3.2.4. EXT-X-KEY]\n///\n/// [4.3.2.4. EXT-X-KEY]: https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n#[allow(missing_docs)]\n#[derive(Ord, PartialOrd, Debug, Clone, Copy, PartialEq, Eq, Hash, Display, EnumString)]\n#[strum(serialize_all = \"SCREAMING-KEBAB-CASE\")]\npub enum EncryptionMethod {\n    /// `None` means that [MediaSegment]s are not encrypted.\n    ///\n    /// [MediaSegment]: crate::MediaSegment\n    None,\n    /// `Aes128` signals that the [MediaSegment]s are completely encrypted\n    /// using the Advanced Encryption Standard ([AES_128]) with a 128-bit\n    /// key, Cipher Block Chaining (CBC), and\n    /// [Public-Key Cryptography Standards #7 (PKCS7)] padding.\n    /// CBC is restarted on each segment boundary, using either the\n    /// Initialization Vector (IV) attribute value or the Media Sequence\n    /// Number as the IV.\n    ///\n    /// [MediaSegment]: crate::MediaSegment\n    /// [AES_128]: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf\n    /// [Public-Key Cryptography Standards #7 (PKCS7)]: https://tools.ietf.org/html/rfc5652\n    #[strum(serialize = \"AES-128\")]\n    Aes128,\n    /// `SampleAes` means that the [MediaSegment]s\n    /// contain media samples, such as audio or video, that are encrypted\n    /// using the Advanced Encryption Standard ([AES_128]). How these media\n    /// streams are encrypted and encapsulated in a segment depends on the\n    /// media encoding and the media format of the segment. fMP4 Media\n    /// Segments are encrypted using the 'cbcs' scheme of\n    /// [Common Encryption].  Encryption of other Media Segment\n    /// formats containing [H.264], [AAC], [AC-3],\n    /// and Enhanced [AC-3] media streams is described in the HTTP\n    /// Live Streaming (HLS) [SampleEncryption specification].\n    ///\n    /// [MediaSegment]: crate::MediaSegment\n    /// [AES_128]: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf\n    /// [Common Encryption]: https://tools.ietf.org/html/rfc8216#ref-COMMON_ENC\n    /// [H.264]: https://tools.ietf.org/html/rfc8216#ref-H_264\n    /// [AAC]: https://tools.ietf.org/html/rfc8216#ref-ISO_14496\n    /// [AC-3]: https://tools.ietf.org/html/rfc8216#ref-AC_3\n    /// [SampleEncryption specification]: https://tools.ietf.org/html/rfc8216#ref-SampleEnc\n    SampleAes,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(EncryptionMethod::Aes128.to_string(), \"AES-128\".to_string());\n        assert_eq!(\n            EncryptionMethod::SampleAes.to_string(),\n            \"SAMPLE-AES\".to_string()\n        );\n        assert_eq!(EncryptionMethod::None.to_string(), \"NONE\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            EncryptionMethod::Aes128,\n            \"AES-128\".parse::\u003cEncryptionMethod\u003e().unwrap()\n        );\n\n        assert_eq!(\n            EncryptionMethod::SampleAes,\n            \"SAMPLE-AES\".parse::\u003cEncryptionMethod\u003e().unwrap()\n        );\n\n        assert_eq!(\n            EncryptionMethod::None,\n            \"NONE\".parse::\u003cEncryptionMethod\u003e().unwrap()\n        );\n\n        assert!(\"unknown\".parse::\u003cEncryptionMethod\u003e().is_err());\n    }\n}\n","traces":[{"line":55,"address":4789104,"length":1,"stats":{"Line":2}},{"line":56,"address":4907735,"length":1,"stats":{"Line":1}},{"line":57,"address":4908353,"length":1,"stats":{"Line":1}},{"line":58,"address":4908298,"length":1,"stats":{"Line":1}},{"line":59,"address":4908318,"length":1,"stats":{"Line":1}},{"line":61,"address":4908814,"length":1,"stats":{"Line":1}},{"line":65,"address":4789136,"length":1,"stats":{"Line":2}},{"line":66,"address":4909512,"length":1,"stats":{"Line":1}},{"line":68,"address":4909470,"length":1,"stats":{"Line":1}},{"line":71,"address":4909949,"length":1,"stats":{"Line":1}},{"line":73,"address":4909623,"length":1,"stats":{"Line":1}},{"line":76,"address":4910374,"length":1,"stats":{"Line":1}},{"line":78,"address":4910054,"length":1,"stats":{"Line":1}},{"line":81,"address":4910479,"length":1,"stats":{"Line":1}}],"covered":14,"coverable":14},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","hdcp_level.rs"],"content":"use strum::{Display, EnumString};\n\n/// HDCP level.\n///\n/// See: [4.3.4.2. EXT-X-STREAM-INF]\n///\n/// [4.3.4.2. EXT-X-STREAM-INF]: https://tools.ietf.org/html/rfc8216#section-4.3.4.2\n#[allow(missing_docs)]\n#[derive(Ord, PartialOrd, Debug, Clone, Copy, PartialEq, Eq, Hash, Display, EnumString)]\n#[strum(serialize_all = \"SCREAMING-KEBAB-CASE\")]\npub enum HdcpLevel {\n    #[strum(serialize = \"TYPE-0\")]\n    Type0,\n    None,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let level = HdcpLevel::Type0;\n        assert_eq!(level.to_string(), \"TYPE-0\".to_string());\n\n        let level = HdcpLevel::None;\n        assert_eq!(level.to_string(), \"NONE\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        let level = HdcpLevel::Type0;\n        assert_eq!(level, \"TYPE-0\".parse::\u003cHdcpLevel\u003e().unwrap());\n\n        let level = HdcpLevel::None;\n        assert_eq!(level, \"NONE\".parse::\u003cHdcpLevel\u003e().unwrap());\n\n        assert!(\"unk\".parse::\u003cHdcpLevel\u003e().is_err());\n    }\n}\n","traces":[{"line":22,"address":4312928,"length":1,"stats":{"Line":2}},{"line":23,"address":4312935,"length":1,"stats":{"Line":1}},{"line":24,"address":4312940,"length":1,"stats":{"Line":1}},{"line":26,"address":4313459,"length":1,"stats":{"Line":1}},{"line":27,"address":4313467,"length":1,"stats":{"Line":1}},{"line":31,"address":4314080,"length":1,"stats":{"Line":2}},{"line":32,"address":4314094,"length":1,"stats":{"Line":1}},{"line":33,"address":4314099,"length":1,"stats":{"Line":1}},{"line":35,"address":4314210,"length":1,"stats":{"Line":1}},{"line":36,"address":4314218,"length":1,"stats":{"Line":1}},{"line":38,"address":4314640,"length":1,"stats":{"Line":1}}],"covered":11,"coverable":11},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","in_stream_id.rs"],"content":"use strum::{Display, EnumString};\n\n/// Identifier of a rendition within the segments in a media playlist.\n///\n/// See: [4.3.4.1. EXT-X-MEDIA]\n///\n/// [4.3.4.1. EXT-X-MEDIA]: https://tools.ietf.org/html/rfc8216#section-4.3.4.1\n#[allow(missing_docs)]\n#[derive(Ord, PartialOrd, Debug, Clone, Copy, PartialEq, Eq, Hash, Display, EnumString)]\n#[strum(serialize_all = \"UPPERCASE\")]\npub enum InStreamId {\n    Cc1,\n    Cc2,\n    Cc3,\n    Cc4,\n    Service1,\n    Service2,\n    Service3,\n    Service4,\n    Service5,\n    Service6,\n    Service7,\n    Service8,\n    Service9,\n    Service10,\n    Service11,\n    Service12,\n    Service13,\n    Service14,\n    Service15,\n    Service16,\n    Service17,\n    Service18,\n    Service19,\n    Service20,\n    Service21,\n    Service22,\n    Service23,\n    Service24,\n    Service25,\n    Service26,\n    Service27,\n    Service28,\n    Service29,\n    Service30,\n    Service31,\n    Service32,\n    Service33,\n    Service34,\n    Service35,\n    Service36,\n    Service37,\n    Service38,\n    Service39,\n    Service40,\n    Service41,\n    Service42,\n    Service43,\n    Service44,\n    Service45,\n    Service46,\n    Service47,\n    Service48,\n    Service49,\n    Service50,\n    Service51,\n    Service52,\n    Service53,\n    Service54,\n    Service55,\n    Service56,\n    Service57,\n    Service58,\n    Service59,\n    Service60,\n    Service61,\n    Service62,\n    Service63,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    macro_rules! gen_tests {\n        ( $($string:expr =\u003e $enum:expr),* ) =\u003e {\n            #[test]\n            fn test_display() {\n                $(\n                    assert_eq!($enum.to_string(), $string.to_string());\n                )*\n            }\n\n            #[test]\n            fn test_parser() {\n                $(\n                    assert_eq!($enum, $string.parse::\u003cInStreamId\u003e().unwrap());\n                )*\n                assert!(\"invalid_input\".parse::\u003cInStreamId\u003e().is_err());\n            }\n        };\n    }\n\n    gen_tests![\n        \"CC1\" =\u003e InStreamId::Cc1,\n        \"CC2\" =\u003e InStreamId::Cc2,\n        \"CC3\" =\u003e InStreamId::Cc3,\n        \"CC4\" =\u003e InStreamId::Cc4,\n        \"SERVICE1\" =\u003e InStreamId::Service1,\n        \"SERVICE2\" =\u003e InStreamId::Service2,\n        \"SERVICE3\" =\u003e InStreamId::Service3,\n        \"SERVICE4\" =\u003e InStreamId::Service4,\n        \"SERVICE5\" =\u003e InStreamId::Service5,\n        \"SERVICE6\" =\u003e InStreamId::Service6,\n        \"SERVICE7\" =\u003e InStreamId::Service7,\n        \"SERVICE8\" =\u003e InStreamId::Service8,\n        \"SERVICE9\" =\u003e InStreamId::Service9,\n        \"SERVICE10\" =\u003e InStreamId::Service10,\n        \"SERVICE11\" =\u003e InStreamId::Service11,\n        \"SERVICE12\" =\u003e InStreamId::Service12,\n        \"SERVICE13\" =\u003e InStreamId::Service13,\n        \"SERVICE14\" =\u003e InStreamId::Service14,\n        \"SERVICE15\" =\u003e InStreamId::Service15,\n        \"SERVICE16\" =\u003e InStreamId::Service16,\n        \"SERVICE17\" =\u003e InStreamId::Service17,\n        \"SERVICE18\" =\u003e InStreamId::Service18,\n        \"SERVICE19\" =\u003e InStreamId::Service19,\n        \"SERVICE20\" =\u003e InStreamId::Service20,\n        \"SERVICE21\" =\u003e InStreamId::Service21,\n        \"SERVICE22\" =\u003e InStreamId::Service22,\n        \"SERVICE23\" =\u003e InStreamId::Service23,\n        \"SERVICE24\" =\u003e InStreamId::Service24,\n        \"SERVICE25\" =\u003e InStreamId::Service25,\n        \"SERVICE26\" =\u003e InStreamId::Service26,\n        \"SERVICE27\" =\u003e InStreamId::Service27,\n        \"SERVICE28\" =\u003e InStreamId::Service28,\n        \"SERVICE29\" =\u003e InStreamId::Service29,\n        \"SERVICE30\" =\u003e InStreamId::Service30,\n        \"SERVICE31\" =\u003e InStreamId::Service31,\n        \"SERVICE32\" =\u003e InStreamId::Service32,\n        \"SERVICE33\" =\u003e InStreamId::Service33,\n        \"SERVICE34\" =\u003e InStreamId::Service34,\n        \"SERVICE35\" =\u003e InStreamId::Service35,\n        \"SERVICE36\" =\u003e InStreamId::Service36,\n        \"SERVICE37\" =\u003e InStreamId::Service37,\n        \"SERVICE38\" =\u003e InStreamId::Service38,\n        \"SERVICE39\" =\u003e InStreamId::Service39,\n        \"SERVICE40\" =\u003e InStreamId::Service40,\n        \"SERVICE41\" =\u003e InStreamId::Service41,\n        \"SERVICE42\" =\u003e InStreamId::Service42,\n        \"SERVICE43\" =\u003e InStreamId::Service43,\n        \"SERVICE44\" =\u003e InStreamId::Service44,\n        \"SERVICE45\" =\u003e InStreamId::Service45,\n        \"SERVICE46\" =\u003e InStreamId::Service46,\n        \"SERVICE47\" =\u003e InStreamId::Service47,\n        \"SERVICE48\" =\u003e InStreamId::Service48,\n        \"SERVICE49\" =\u003e InStreamId::Service49,\n        \"SERVICE50\" =\u003e InStreamId::Service50,\n        \"SERVICE51\" =\u003e InStreamId::Service51,\n        \"SERVICE52\" =\u003e InStreamId::Service52,\n        \"SERVICE53\" =\u003e InStreamId::Service53,\n        \"SERVICE54\" =\u003e InStreamId::Service54,\n        \"SERVICE55\" =\u003e InStreamId::Service55,\n        \"SERVICE56\" =\u003e InStreamId::Service56,\n        \"SERVICE57\" =\u003e InStreamId::Service57,\n        \"SERVICE58\" =\u003e InStreamId::Service58,\n        \"SERVICE59\" =\u003e InStreamId::Service59,\n        \"SERVICE60\" =\u003e InStreamId::Service60,\n        \"SERVICE61\" =\u003e InStreamId::Service61,\n        \"SERVICE62\" =\u003e InStreamId::Service62,\n        \"SERVICE63\" =\u003e InStreamId::Service63\n    ];\n}\n","traces":[{"line":88,"address":4556496,"length":1,"stats":{"Line":2}},{"line":90,"address":5435661,"length":1,"stats":{"Line":1}},{"line":95,"address":4556528,"length":1,"stats":{"Line":2}},{"line":97,"address":5475684,"length":1,"stats":{"Line":1}},{"line":99,"address":5506197,"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","initialization_vector.rs"],"content":"use std::fmt;\nuse std::ops::Deref;\nuse std::str::FromStr;\n\nuse crate::Error;\n\n/// Initialization vector.\n///\n/// See: [4.3.2.4. EXT-X-KEY]\n///\n/// [4.3.2.4. EXT-X-KEY]: https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct InitializationVector(pub [u8; 16]);\n\nimpl InitializationVector {\n    /// Converts the [InitializationVector] to a slice.\n    pub const fn to_slice(\u0026self) -\u003e [u8; 16] {\n        self.0\n    }\n}\n\nimpl From\u003c[u8; 16]\u003e for InitializationVector {\n    fn from(value: [u8; 16]) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl Deref for InitializationVector {\n    type Target = [u8];\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl AsRef\u003c[u8]\u003e for InitializationVector {\n    fn as_ref(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.0\n    }\n}\n\nimpl fmt::Display for InitializationVector {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"0x\")?;\n        for b in \u0026self.0 {\n            write!(f, \"{:02x}\", b)?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for InitializationVector {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if !(input.starts_with(\"0x\") || input.starts_with(\"0X\")) {\n            return Err(Error::invalid_input());\n        }\n        if input.len() - 2 != 32 {\n            return Err(Error::invalid_input());\n        }\n\n        let mut result = [0; 16];\n        for (i, c) in input.as_bytes().chunks(2).skip(1).enumerate() {\n            let d = std::str::from_utf8(c).map_err(Error::custom)?;\n            let b = u8::from_str_radix(d, 16).map_err(Error::custom)?;\n            result[i] = b;\n        }\n\n        Ok(Self(result))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            \"0x10ef8f758ca555115584bb5b3c687f52\".to_string(),\n            InitializationVector([\n                16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82\n            ])\n            .to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            \"0x10ef8f758ca555115584bb5b3c687f52\"\n                .parse::\u003cInitializationVector\u003e()\n                .unwrap(),\n            InitializationVector([\n                16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82\n            ])\n        );\n\n        assert_eq!(\n            \"0X10ef8f758ca555115584bb5b3c687f52\"\n                .parse::\u003cInitializationVector\u003e()\n                .unwrap(),\n            InitializationVector([\n                16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82\n            ])\n        );\n\n        assert_eq!(\n            \"0X10EF8F758CA555115584BB5B3C687F52\"\n                .parse::\u003cInitializationVector\u003e()\n                .unwrap(),\n            InitializationVector([\n                16, 239, 143, 117, 140, 165, 85, 17, 85, 132, 187, 91, 60, 104, 127, 82\n            ])\n        );\n\n        assert!(\"garbage\".parse::\u003cInitializationVector\u003e().is_err());\n        assert!(\"0xgarbage\".parse::\u003cInitializationVector\u003e().is_err());\n        assert!(\"0x12\".parse::\u003cInitializationVector\u003e().is_err());\n        assert!(\"0X10EF8F758CA555115584BB5B3C687F5Z\"\n            .parse::\u003cInitializationVector\u003e()\n            .is_err());\n    }\n\n    #[test]\n    fn test_as_ref() {\n        assert_eq!(\n            InitializationVector([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]).as_ref(),\n            \u0026[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        );\n    }\n\n    #[test]\n    fn test_deref() {\n        assert_eq!(\n            InitializationVector([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]).deref(),\n            \u0026[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        );\n    }\n\n    #[test]\n    fn test_from() {\n        assert_eq!(\n            InitializationVector::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n            InitializationVector([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n        );\n    }\n\n    #[test]\n    fn test_to_slice() {\n        assert_eq!(\n            InitializationVector([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]).to_slice(),\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        );\n    }\n}\n","traces":[{"line":17,"address":4527936,"length":1,"stats":{"Line":4}},{"line":18,"address":4527944,"length":1,"stats":{"Line":4}},{"line":23,"address":4527968,"length":1,"stats":{"Line":1}},{"line":24,"address":4527975,"length":1,"stats":{"Line":1}},{"line":30,"address":4528016,"length":1,"stats":{"Line":1}},{"line":31,"address":4528021,"length":1,"stats":{"Line":1}},{"line":36,"address":4528032,"length":1,"stats":{"Line":1}},{"line":37,"address":4528037,"length":1,"stats":{"Line":1}},{"line":42,"address":4528048,"length":1,"stats":{"Line":3}},{"line":43,"address":4528077,"length":1,"stats":{"Line":3}},{"line":44,"address":4528217,"length":1,"stats":{"Line":3}},{"line":45,"address":4528381,"length":1,"stats":{"Line":3}},{"line":47,"address":4528314,"length":1,"stats":{"Line":3}},{"line":54,"address":4528672,"length":1,"stats":{"Line":1}},{"line":55,"address":4528699,"length":1,"stats":{"Line":1}},{"line":56,"address":4528862,"length":1,"stats":{"Line":1}},{"line":58,"address":4528840,"length":1,"stats":{"Line":1}},{"line":59,"address":4529065,"length":1,"stats":{"Line":1}},{"line":62,"address":4528968,"length":1,"stats":{"Line":1}},{"line":63,"address":4528979,"length":1,"stats":{"Line":1}},{"line":64,"address":4529600,"length":1,"stats":{"Line":1}},{"line":65,"address":4530095,"length":1,"stats":{"Line":1}},{"line":66,"address":4530600,"length":1,"stats":{"Line":1}},{"line":69,"address":4529305,"length":1,"stats":{"Line":1}},{"line":78,"address":4407680,"length":1,"stats":{"Line":2}},{"line":79,"address":5310201,"length":1,"stats":{"Line":1}},{"line":80,"address":5310142,"length":1,"stats":{"Line":1}},{"line":81,"address":5310177,"length":1,"stats":{"Line":1}},{"line":89,"address":4407712,"length":1,"stats":{"Line":2}},{"line":90,"address":5310752,"length":1,"stats":{"Line":1}},{"line":99,"address":5311183,"length":1,"stats":{"Line":1}},{"line":108,"address":5311614,"length":1,"stats":{"Line":1}},{"line":117,"address":5311712,"length":1,"stats":{"Line":1}},{"line":118,"address":5312096,"length":1,"stats":{"Line":1}},{"line":119,"address":5312228,"length":1,"stats":{"Line":1}},{"line":120,"address":5312360,"length":1,"stats":{"Line":1}},{"line":126,"address":4407744,"length":1,"stats":{"Line":2}},{"line":127,"address":5312644,"length":1,"stats":{"Line":1}},{"line":128,"address":5312615,"length":1,"stats":{"Line":1}},{"line":134,"address":4407776,"length":1,"stats":{"Line":2}},{"line":135,"address":5313028,"length":1,"stats":{"Line":1}},{"line":136,"address":5312999,"length":1,"stats":{"Line":1}},{"line":142,"address":4407808,"length":1,"stats":{"Line":2}},{"line":143,"address":5313485,"length":1,"stats":{"Line":1}},{"line":144,"address":5313383,"length":1,"stats":{"Line":1}},{"line":150,"address":4407840,"length":1,"stats":{"Line":2}},{"line":151,"address":5313851,"length":1,"stats":{"Line":1}},{"line":152,"address":5313838,"length":1,"stats":{"Line":1}}],"covered":48,"coverable":48},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","key_format.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::{quote, tag, unquote};\nuse crate::Error;\n\n#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]\n/// KeyFormat specifies, how the key is represented in the resource identified by the URI\npub enum KeyFormat {\n    /// The key is a single packed array of 16 octets in binary format.\n    Identity,\n}\n\nimpl Default for KeyFormat {\n    fn default() -\u003e Self {\n        Self::Identity\n    }\n}\n\nimpl FromStr for KeyFormat {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        tag(\u0026unquote(input), \"identity\")?; // currently only KeyFormat::Identity exists!\n\n        Ok(Self::Identity)\n    }\n}\n\nimpl fmt::Display for KeyFormat {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", quote(\"identity\"))\n    }\n}\n\nimpl RequiredVersion for KeyFormat {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V5\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(KeyFormat::Identity.to_string(), quote(\"identity\"));\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(KeyFormat::Identity, quote(\"identity\").parse().unwrap());\n\n        assert_eq!(KeyFormat::Identity, \"identity\".parse().unwrap());\n\n        assert!(\"garbage\".parse::\u003cKeyFormat\u003e().is_err());\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(KeyFormat::Identity.required_version(), ProtocolVersion::V5)\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq!(KeyFormat::Identity, KeyFormat::default());\n    }\n}\n","traces":[{"line":16,"address":4219632,"length":1,"stats":{"Line":1}},{"line":17,"address":null,"length":0,"stats":{"Line":0}},{"line":24,"address":4219648,"length":1,"stats":{"Line":1}},{"line":25,"address":4219668,"length":1,"stats":{"Line":1}},{"line":27,"address":4220188,"length":1,"stats":{"Line":1}},{"line":32,"address":4220288,"length":1,"stats":{"Line":1}},{"line":33,"address":4220312,"length":1,"stats":{"Line":1}},{"line":38,"address":4220576,"length":1,"stats":{"Line":1}},{"line":39,"address":4220584,"length":1,"stats":{"Line":1}},{"line":48,"address":4412896,"length":1,"stats":{"Line":2}},{"line":49,"address":4675895,"length":1,"stats":{"Line":1}},{"line":53,"address":4412928,"length":1,"stats":{"Line":2}},{"line":54,"address":4676446,"length":1,"stats":{"Line":1}},{"line":56,"address":4676988,"length":1,"stats":{"Line":1}},{"line":58,"address":4677125,"length":1,"stats":{"Line":1}},{"line":62,"address":4412960,"length":1,"stats":{"Line":2}},{"line":63,"address":4677591,"length":1,"stats":{"Line":1}},{"line":67,"address":4412992,"length":1,"stats":{"Line":2}},{"line":68,"address":4677959,"length":1,"stats":{"Line":1}}],"covered":18,"coverable":19},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","key_format_versions.rs"],"content":"use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\n\nuse crate::types::{ProtocolVersion, RequiredVersion};\nuse crate::utils::{quote, unquote};\nuse crate::Error;\n\n/// A list of [usize], that can be used to indicate which version(s)\n/// this instance complies with, if more than one version of a particular\n/// [KeyFormat] is defined.\n///\n/// [KeyFormat]: crate::types::KeyFormat\n#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]\npub struct KeyFormatVersions(Vec\u003cusize\u003e);\n\nimpl Default for KeyFormatVersions {\n    fn default() -\u003e Self {\n        Self(vec![1])\n    }\n}\n\nimpl KeyFormatVersions {\n    /// Makes a new [KeyFormatVersions].\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Add a value to the [KeyFormatVersions].\n    pub fn push(\u0026mut self, value: usize) {\n        if self.is_default() {\n            self.0 = vec![value];\n        } else {\n            self.0.push(value);\n        }\n    }\n\n    /// Returns `true`, if [KeyFormatVersions] has the default value of `vec![1]`.\n    pub fn is_default(\u0026self) -\u003e bool {\n        self.0 == vec![1] \u0026\u0026 self.0.len() == 1 || self.0.is_empty()\n    }\n}\n\nimpl Deref for KeyFormatVersions {\n    type Target = Vec\u003cusize\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for KeyFormatVersions {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\nimpl RequiredVersion for KeyFormatVersions {\n    fn required_version(\u0026self) -\u003e ProtocolVersion {\n        ProtocolVersion::V5\n    }\n}\n\nimpl FromStr for KeyFormatVersions {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut result = unquote(input)\n            .split('/')\n            .filter_map(|v| v.parse().ok())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        if result.is_empty() {\n            result.push(1);\n        }\n\n        Ok(Self(result))\n    }\n}\n\nimpl fmt::Display for KeyFormatVersions {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if self.is_default() {\n            return write!(f, \"{}\", quote(\"1\"));\n        }\n\n        write!(\n            f,\n            \"{}\",\n            quote(\n                // vec![1, 2, 3] -\u003e \"1/2/3\"\n                self.0\n                    .iter()\n                    .map(|v| v.to_string())\n                    .collect::\u003cVec\u003cString\u003e\u003e()\n                    .join(\"/\")\n            )\n        )\n    }\n}\n\nimpl\u003cT: Into\u003cVec\u003cusize\u003e\u003e\u003e From\u003cT\u003e for KeyFormatVersions {\n    fn from(value: T) -\u003e Self {\n        Self(value.into())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            KeyFormatVersions::from(vec![1, 2, 3, 4, 5]).to_string(),\n            quote(\"1/2/3/4/5\")\n        );\n\n        assert_eq!(KeyFormatVersions::from(vec![]).to_string(), quote(\"1\"));\n\n        assert_eq!(KeyFormatVersions::new().to_string(), quote(\"1\"));\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            KeyFormatVersions::from(vec![1, 2, 3, 4, 5]),\n            quote(\"1/2/3/4/5\").parse().unwrap()\n        );\n\n        assert_eq!(KeyFormatVersions::from(vec![1]), \"1\".parse().unwrap());\n\n        assert_eq!(KeyFormatVersions::from(vec![1, 2]), \"1/2\".parse().unwrap());\n    }\n\n    #[test]\n    fn test_required_version() {\n        assert_eq!(\n            KeyFormatVersions::new().required_version(),\n            ProtocolVersion::V5\n        )\n    }\n\n    #[test]\n    fn test_is_default() {\n        assert!(KeyFormatVersions::new().is_default());\n        assert!(KeyFormatVersions::from(vec![]).is_default());\n        assert!(!KeyFormatVersions::from(vec![1, 2, 3]).is_default());\n    }\n\n    #[test]\n    fn test_push() {\n        let mut key_format_versions = KeyFormatVersions::from(vec![]);\n\n        key_format_versions.push(2);\n        assert_eq!(KeyFormatVersions::from(vec![2]), key_format_versions);\n    }\n\n    #[test]\n    fn test_deref() {\n        assert!(!KeyFormatVersions::new().is_empty());\n    }\n\n    #[test]\n    fn test_deref_mut() {\n        let mut key_format_versions = KeyFormatVersions::from(vec![1, 2, 3]);\n        key_format_versions.pop();\n        assert_eq!(key_format_versions, KeyFormatVersions::from(vec![1, 2]));\n    }\n}\n","traces":[{"line":18,"address":4252160,"length":1,"stats":{"Line":8}},{"line":19,"address":4252167,"length":1,"stats":{"Line":8}},{"line":25,"address":4252272,"length":1,"stats":{"Line":8}},{"line":30,"address":4252304,"length":1,"stats":{"Line":1}},{"line":31,"address":4252318,"length":1,"stats":{"Line":1}},{"line":32,"address":4252364,"length":1,"stats":{"Line":1}},{"line":34,"address":4252343,"length":1,"stats":{"Line":0}},{"line":39,"address":4252512,"length":1,"stats":{"Line":5}},{"line":40,"address":4252521,"length":1,"stats":{"Line":5}},{"line":47,"address":4252800,"length":1,"stats":{"Line":1}},{"line":48,"address":4252805,"length":1,"stats":{"Line":1}},{"line":53,"address":4252816,"length":1,"stats":{"Line":1}},{"line":54,"address":4252821,"length":1,"stats":{"Line":1}},{"line":59,"address":4252832,"length":1,"stats":{"Line":1}},{"line":60,"address":4252840,"length":1,"stats":{"Line":1}},{"line":67,"address":4252864,"length":1,"stats":{"Line":1}},{"line":68,"address":4252884,"length":1,"stats":{"Line":1}},{"line":69,"address":null,"length":0,"stats":{"Line":0}},{"line":70,"address":4254512,"length":1,"stats":{"Line":1}},{"line":71,"address":4252996,"length":1,"stats":{"Line":0}},{"line":73,"address":4253092,"length":1,"stats":{"Line":1}},{"line":74,"address":4253122,"length":1,"stats":{"Line":0}},{"line":77,"address":4253145,"length":1,"stats":{"Line":1}},{"line":82,"address":4253344,"length":1,"stats":{"Line":4}},{"line":83,"address":4253367,"length":1,"stats":{"Line":4}},{"line":84,"address":4253476,"length":1,"stats":{"Line":1}},{"line":87,"address":4253961,"length":1,"stats":{"Line":4}},{"line":88,"address":4253418,"length":1,"stats":{"Line":4}},{"line":90,"address":4253938,"length":1,"stats":{"Line":4}},{"line":92,"address":4253426,"length":1,"stats":{"Line":4}},{"line":93,"address":null,"length":0,"stats":{"Line":0}},{"line":94,"address":4254592,"length":1,"stats":{"Line":4}},{"line":95,"address":null,"length":0,"stats":{"Line":0}},{"line":96,"address":null,"length":0,"stats":{"Line":0}},{"line":103,"address":null,"length":0,"stats":{"Line":7}},{"line":104,"address":null,"length":0,"stats":{"Line":7}},{"line":113,"address":4907504,"length":1,"stats":{"Line":2}},{"line":114,"address":5267314,"length":1,"stats":{"Line":0}},{"line":115,"address":5267175,"length":1,"stats":{"Line":1}},{"line":116,"address":5267329,"length":1,"stats":{"Line":1}},{"line":119,"address":5267880,"length":1,"stats":{"Line":1}},{"line":121,"address":5268483,"length":1,"stats":{"Line":1}},{"line":125,"address":4907536,"length":1,"stats":{"Line":2}},{"line":126,"address":5269382,"length":1,"stats":{"Line":0}},{"line":127,"address":5269239,"length":1,"stats":{"Line":1}},{"line":128,"address":5269355,"length":1,"stats":{"Line":1}},{"line":131,"address":5270000,"length":1,"stats":{"Line":1}},{"line":133,"address":5270588,"length":1,"stats":{"Line":1}},{"line":137,"address":4907568,"length":1,"stats":{"Line":2}},{"line":138,"address":5271407,"length":1,"stats":{"Line":1}},{"line":139,"address":5271351,"length":1,"stats":{"Line":1}},{"line":145,"address":4907600,"length":1,"stats":{"Line":2}},{"line":146,"address":5271831,"length":1,"stats":{"Line":1}},{"line":147,"address":5271922,"length":1,"stats":{"Line":1}},{"line":148,"address":5272057,"length":1,"stats":{"Line":1}},{"line":152,"address":4907632,"length":1,"stats":{"Line":2}},{"line":153,"address":5272347,"length":1,"stats":{"Line":1}},{"line":155,"address":5272416,"length":1,"stats":{"Line":1}},{"line":156,"address":5272428,"length":1,"stats":{"Line":1}},{"line":160,"address":4907664,"length":1,"stats":{"Line":2}},{"line":161,"address":5272980,"length":1,"stats":{"Line":1}},{"line":165,"address":4907696,"length":1,"stats":{"Line":2}},{"line":166,"address":5273143,"length":1,"stats":{"Line":1}},{"line":167,"address":5273239,"length":1,"stats":{"Line":1}},{"line":168,"address":5273285,"length":1,"stats":{"Line":1}}],"covered":56,"coverable":65},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","media_type.rs"],"content":"use strum::{Display, EnumString};\n\n/// Specifies the media type.\n#[allow(missing_docs)]\n#[derive(Ord, PartialOrd, Display, EnumString, Debug, Clone, Copy, PartialEq, Eq, Hash)]\n#[strum(serialize_all = \"SCREAMING-KEBAB-CASE\")]\npub enum MediaType {\n    Audio,\n    Video,\n    Subtitles,\n    ClosedCaptions,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(MediaType::Audio, \"AUDIO\".parse().unwrap());\n        assert_eq!(MediaType::Video, \"VIDEO\".parse().unwrap());\n        assert_eq!(MediaType::Subtitles, \"SUBTITLES\".parse().unwrap());\n        assert_eq!(\n            MediaType::ClosedCaptions,\n            \"CLOSED-CAPTIONS\".parse().unwrap()\n        );\n    }\n\n    #[test]\n    fn test_display() {\n        assert_eq!(MediaType::Audio.to_string(), \"AUDIO\".to_string());\n        assert_eq!(MediaType::Video.to_string(), \"VIDEO\".to_string());\n        assert_eq!(MediaType::Subtitles.to_string(), \"SUBTITLES\".to_string());\n        assert_eq!(\n            MediaType::ClosedCaptions.to_string(),\n            \"CLOSED-CAPTIONS\".to_string()\n        );\n    }\n}\n","traces":[{"line":19,"address":5157600,"length":1,"stats":{"Line":2}},{"line":20,"address":5315758,"length":1,"stats":{"Line":1}},{"line":21,"address":5315911,"length":1,"stats":{"Line":1}},{"line":22,"address":5316366,"length":1,"stats":{"Line":1}},{"line":23,"address":5317111,"length":1,"stats":{"Line":1}},{"line":25,"address":5316791,"length":1,"stats":{"Line":1}},{"line":30,"address":5157632,"length":1,"stats":{"Line":2}},{"line":31,"address":5317511,"length":1,"stats":{"Line":1}},{"line":32,"address":5318086,"length":1,"stats":{"Line":1}},{"line":33,"address":5318638,"length":1,"stats":{"Line":1}},{"line":34,"address":5319209,"length":1,"stats":{"Line":1}},{"line":35,"address":5319154,"length":1,"stats":{"Line":1}},{"line":36,"address":5319174,"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","protocol_version.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::Error;\n\n/// # Example\n/// Implementing it:\n/// ```\n/// # use hls_m3u8::types::{ProtocolVersion, RequiredVersion};\n/// #\n/// struct NewTag(u64);\n///\n/// impl RequiredVersion for NewTag {\n///     fn required_version(\u0026self) -\u003e ProtocolVersion {\n///         if self.0 == 5 {\n///             ProtocolVersion::V4\n///         } else {\n///             ProtocolVersion::V1\n///         }\n///     }\n/// }\n/// assert_eq!(NewTag(5).required_version(), ProtocolVersion::V4);\n/// assert_eq!(NewTag(2).required_version(), ProtocolVersion::V1);\n/// ```\npub trait RequiredVersion {\n    /// Returns the protocol compatibility version that this tag requires.\n    fn required_version(\u0026self) -\u003e ProtocolVersion;\n}\n\n/// # [7. Protocol Version Compatibility]\n/// The [ProtocolVersion] specifies, which m3u8 revision is required, to parse\n/// a certain tag correctly.\n///\n/// [7. Protocol Version Compatibility]:\n/// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-05#section-7\n#[allow(missing_docs)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum ProtocolVersion {\n    V1,\n    V2,\n    V3,\n    V4,\n    V5,\n    V6,\n    V7,\n}\n\nimpl ProtocolVersion {\n    /// Returns the newest [ProtocolVersion], that is supported by this library.\n    ///\n    /// # Example\n    /// ```\n    /// # use hls_m3u8::types::ProtocolVersion;\n    /// assert_eq!(ProtocolVersion::latest(), ProtocolVersion::V7);\n    /// ```\n    pub const fn latest() -\u003e Self {\n        Self::V7\n    }\n}\n\nimpl fmt::Display for ProtocolVersion {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match \u0026self {\n            Self::V1 =\u003e write!(f, \"1\"),\n            Self::V2 =\u003e write!(f, \"2\"),\n            Self::V3 =\u003e write!(f, \"3\"),\n            Self::V4 =\u003e write!(f, \"4\"),\n            Self::V5 =\u003e write!(f, \"5\"),\n            Self::V6 =\u003e write!(f, \"6\"),\n            Self::V7 =\u003e write!(f, \"7\"),\n        }\n    }\n}\n\nimpl FromStr for ProtocolVersion {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        Ok({\n            match input.trim() {\n                \"1\" =\u003e Self::V1,\n                \"2\" =\u003e Self::V2,\n                \"3\" =\u003e Self::V3,\n                \"4\" =\u003e Self::V4,\n                \"5\" =\u003e Self::V5,\n                \"6\" =\u003e Self::V6,\n                \"7\" =\u003e Self::V7,\n                _ =\u003e return Err(Error::unknown_protocol_version(input)),\n            }\n        })\n    }\n}\n\nimpl Default for ProtocolVersion {\n    fn default() -\u003e Self {\n        Self::V1\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        assert_eq!(ProtocolVersion::V1.to_string(), \"1\".to_string());\n        assert_eq!(ProtocolVersion::V2.to_string(), \"2\".to_string());\n        assert_eq!(ProtocolVersion::V3.to_string(), \"3\".to_string());\n        assert_eq!(ProtocolVersion::V4.to_string(), \"4\".to_string());\n        assert_eq!(ProtocolVersion::V5.to_string(), \"5\".to_string());\n        assert_eq!(ProtocolVersion::V6.to_string(), \"6\".to_string());\n        assert_eq!(ProtocolVersion::V7.to_string(), \"7\".to_string());\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(ProtocolVersion::V1, \"1\".parse().unwrap());\n        assert_eq!(ProtocolVersion::V2, \"2\".parse().unwrap());\n        assert_eq!(ProtocolVersion::V3, \"3\".parse().unwrap());\n        assert_eq!(ProtocolVersion::V4, \"4\".parse().unwrap());\n        assert_eq!(ProtocolVersion::V5, \"5\".parse().unwrap());\n        assert_eq!(ProtocolVersion::V6, \"6\".parse().unwrap());\n        assert_eq!(ProtocolVersion::V7, \"7\".parse().unwrap());\n\n        assert_eq!(ProtocolVersion::V7, \" 7 \".parse().unwrap());\n        assert!(\"garbage\".parse::\u003cProtocolVersion\u003e().is_err());\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq!(ProtocolVersion::default(), ProtocolVersion::V1);\n    }\n\n    #[test]\n    fn test_latest() {\n        assert_eq!(ProtocolVersion::latest(), ProtocolVersion::V7);\n    }\n}\n","traces":[{"line":56,"address":4212416,"length":1,"stats":{"Line":2}},{"line":57,"address":4212420,"length":1,"stats":{"Line":2}},{"line":62,"address":4212432,"length":1,"stats":{"Line":1}},{"line":63,"address":4212541,"length":1,"stats":{"Line":0}},{"line":64,"address":4212449,"length":1,"stats":{"Line":1}},{"line":65,"address":4212630,"length":1,"stats":{"Line":1}},{"line":66,"address":4212711,"length":1,"stats":{"Line":1}},{"line":67,"address":4212792,"length":1,"stats":{"Line":1}},{"line":68,"address":4212873,"length":1,"stats":{"Line":1}},{"line":69,"address":4212951,"length":1,"stats":{"Line":1}},{"line":70,"address":4212497,"length":1,"stats":{"Line":1}},{"line":78,"address":4213072,"length":1,"stats":{"Line":2}},{"line":79,"address":4213618,"length":1,"stats":{"Line":2}},{"line":80,"address":4213092,"length":1,"stats":{"Line":2}},{"line":81,"address":4213148,"length":1,"stats":{"Line":2}},{"line":82,"address":4213177,"length":1,"stats":{"Line":1}},{"line":83,"address":4213187,"length":1,"stats":{"Line":2}},{"line":84,"address":4213197,"length":1,"stats":{"Line":1}},{"line":85,"address":4213207,"length":1,"stats":{"Line":1}},{"line":86,"address":4213217,"length":1,"stats":{"Line":1}},{"line":87,"address":4213227,"length":1,"stats":{"Line":1}},{"line":88,"address":4213237,"length":1,"stats":{"Line":1}},{"line":95,"address":4213648,"length":1,"stats":{"Line":1}},{"line":96,"address":4213652,"length":1,"stats":{"Line":1}},{"line":105,"address":4329216,"length":1,"stats":{"Line":2}},{"line":106,"address":4560215,"length":1,"stats":{"Line":1}},{"line":107,"address":4560790,"length":1,"stats":{"Line":1}},{"line":108,"address":4561348,"length":1,"stats":{"Line":1}},{"line":109,"address":4561906,"length":1,"stats":{"Line":1}},{"line":110,"address":4562464,"length":1,"stats":{"Line":1}},{"line":111,"address":4563010,"length":1,"stats":{"Line":1}},{"line":112,"address":4563526,"length":1,"stats":{"Line":1}},{"line":116,"address":4329248,"length":1,"stats":{"Line":2}},{"line":117,"address":4564350,"length":1,"stats":{"Line":1}},{"line":118,"address":4564519,"length":1,"stats":{"Line":1}},{"line":119,"address":4564979,"length":1,"stats":{"Line":1}},{"line":120,"address":4565439,"length":1,"stats":{"Line":1}},{"line":121,"address":4565899,"length":1,"stats":{"Line":1}},{"line":122,"address":4566359,"length":1,"stats":{"Line":1}},{"line":123,"address":4566819,"length":1,"stats":{"Line":1}},{"line":125,"address":4567249,"length":1,"stats":{"Line":1}},{"line":126,"address":4567679,"length":1,"stats":{"Line":1}},{"line":130,"address":4329280,"length":1,"stats":{"Line":2}},{"line":131,"address":4568119,"length":1,"stats":{"Line":1}},{"line":135,"address":4329312,"length":1,"stats":{"Line":2}},{"line":136,"address":4568487,"length":1,"stats":{"Line":1}}],"covered":45,"coverable":46},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","signed_decimal_floating_point.rs"],"content":"use core::ops::Deref;\nuse derive_more::{Display, FromStr};\n\n/// Signed decimal floating-point number.\n///\n/// See: [4.2. Attribute Lists]\n///\n/// [4.2. Attribute Lists]: https://tools.ietf.org/html/rfc8216#section-4.2\n#[derive(Default, Debug, Clone, Copy, PartialEq, PartialOrd, Display, FromStr)]\npub(crate) struct SignedDecimalFloatingPoint(f64);\n\nimpl SignedDecimalFloatingPoint {\n    /// Makes a new [SignedDecimalFloatingPoint] instance.\n    ///\n    /// # Panics\n    /// The given value must be finite, otherwise this function will panic!\n    pub fn new(value: f64) -\u003e Self {\n        if value.is_infinite() {\n            panic!(\"Floating point value must be finite!\");\n        }\n        Self(value)\n    }\n\n    pub(crate) const fn from_f64_unchecked(value: f64) -\u003e Self {\n        Self(value)\n    }\n\n    /// Converts [DecimalFloatingPoint] to [f64].\n    pub const fn as_f64(self) -\u003e f64 {\n        self.0\n    }\n}\n\nimpl Deref for SignedDecimalFloatingPoint {\n    type Target = f64;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl Eq for SignedDecimalFloatingPoint {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    macro_rules! test_from {\n        ( $( $input:expr =\u003e $output:expr ),* ) =\u003e {\n            use ::core::convert::From;\n\n            #[test]\n            fn test_from() {\n                $(\n                    assert_eq!(\n                        $input,\n                        $output,\n                    );\n                )*\n            }\n        }\n    }\n\n    test_from![\n        SignedDecimalFloatingPoint::from(1u8) =\u003e SignedDecimalFloatingPoint::new(1.0),\n        SignedDecimalFloatingPoint::from(1i8) =\u003e SignedDecimalFloatingPoint::new(1.0),\n        SignedDecimalFloatingPoint::from(1u16) =\u003e SignedDecimalFloatingPoint::new(1.0),\n        SignedDecimalFloatingPoint::from(1i16) =\u003e SignedDecimalFloatingPoint::new(1.0),\n        SignedDecimalFloatingPoint::from(1u32) =\u003e SignedDecimalFloatingPoint::new(1.0),\n        SignedDecimalFloatingPoint::from(1i32) =\u003e SignedDecimalFloatingPoint::new(1.0),\n        SignedDecimalFloatingPoint::from(1.0f32) =\u003e SignedDecimalFloatingPoint::new(1.0),\n        SignedDecimalFloatingPoint::from(1.0f64) =\u003e SignedDecimalFloatingPoint::new(1.0)\n    ];\n\n    #[test]\n    fn test_display() {\n        assert_eq!(\n            SignedDecimalFloatingPoint::new(1.0).to_string(),\n            1.0f64.to_string()\n        );\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_new_panic() {\n        SignedDecimalFloatingPoint::new(::std::f64::INFINITY);\n    }\n\n    #[test]\n    fn test_parser() {\n        assert_eq!(\n            SignedDecimalFloatingPoint::new(1.0),\n            \"1.0\".parse::\u003cSignedDecimalFloatingPoint\u003e().unwrap()\n        );\n\n        assert!(\"garbage\".parse::\u003cSignedDecimalFloatingPoint\u003e().is_err());\n    }\n\n    #[test]\n    fn test_as_f64() {\n        assert_eq!(SignedDecimalFloatingPoint::new(1.0).as_f64(), 1.0);\n    }\n\n    #[test]\n    fn test_deref() {\n        assert_eq!(SignedDecimalFloatingPoint::from(0.1).floor(), 0.0);\n    }\n}\n","traces":[{"line":17,"address":4366352,"length":1,"stats":{"Line":1}},{"line":18,"address":4366362,"length":1,"stats":{"Line":1}},{"line":19,"address":null,"length":0,"stats":{"Line":1}},{"line":21,"address":4366387,"length":1,"stats":{"Line":1}},{"line":24,"address":4366448,"length":1,"stats":{"Line":1}},{"line":25,"address":4366457,"length":1,"stats":{"Line":1}},{"line":29,"address":4366480,"length":1,"stats":{"Line":1}},{"line":30,"address":4366486,"length":1,"stats":{"Line":1}},{"line":37,"address":null,"length":0,"stats":{"Line":1}},{"line":38,"address":null,"length":0,"stats":{"Line":1}},{"line":53,"address":4480864,"length":1,"stats":{"Line":2}},{"line":55,"address":4480912,"length":1,"stats":{"Line":1}},{"line":65,"address":4480871,"length":1,"stats":{"Line":1}},{"line":66,"address":4481017,"length":1,"stats":{"Line":1}},{"line":67,"address":4481471,"length":1,"stats":{"Line":1}},{"line":68,"address":4481925,"length":1,"stats":{"Line":1}},{"line":69,"address":4482379,"length":1,"stats":{"Line":1}},{"line":70,"address":4482833,"length":1,"stats":{"Line":1}},{"line":71,"address":4483289,"length":1,"stats":{"Line":1}},{"line":72,"address":4483716,"length":1,"stats":{"Line":1}},{"line":76,"address":4484432,"length":1,"stats":{"Line":2}},{"line":77,"address":4484514,"length":1,"stats":{"Line":1}},{"line":78,"address":4484447,"length":1,"stats":{"Line":1}},{"line":79,"address":4484490,"length":1,"stats":{"Line":1}},{"line":85,"address":4485008,"length":1,"stats":{"Line":2}},{"line":86,"address":4485017,"length":1,"stats":{"Line":1}},{"line":90,"address":4485024,"length":1,"stats":{"Line":2}},{"line":91,"address":4485091,"length":1,"stats":{"Line":1}},{"line":92,"address":4485039,"length":1,"stats":{"Line":1}},{"line":93,"address":4485057,"length":1,"stats":{"Line":1}},{"line":96,"address":4485167,"length":1,"stats":{"Line":1}},{"line":100,"address":4485536,"length":1,"stats":{"Line":2}},{"line":101,"address":4485551,"length":1,"stats":{"Line":1}},{"line":105,"address":4485936,"length":1,"stats":{"Line":2}},{"line":106,"address":4485951,"length":1,"stats":{"Line":1}}],"covered":35,"coverable":35},{"path":["/","media","hdd","home","projects","hls_m3u8","src","types","stream_inf.rs"],"content":"use std::fmt;\nuse std::str::FromStr;\n\nuse crate::attribute::AttributePairs;\nuse crate::types::{DecimalResolution, HdcpLevel};\nuse crate::utils::{quote, unquote};\nuse crate::Error;\n\n/// [4.3.4.2. EXT-X-STREAM-INF]\n///\n/// [4.3.4.2. EXT-X-STREAM-INF]: https://tools.ietf.org/html/rfc8216#section-4.3.4.2\n#[derive(PartialOrd, Debug, Clone, PartialEq, Eq, Hash)]\npub struct StreamInf {\n    bandwidth: u64,\n    average_bandwidth: Option\u003cu64\u003e,\n    codecs: Option\u003cString\u003e,\n    resolution: Option\u003cDecimalResolution\u003e,\n    hdcp_level: Option\u003cHdcpLevel\u003e,\n    video: Option\u003cString\u003e,\n}\n\nimpl StreamInf {\n    /// Creates a new [StreamInf].\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let stream = StreamInf::new(20);\n    /// ```\n    pub const fn new(bandwidth: u64) -\u003e Self {\n        Self {\n            bandwidth,\n            average_bandwidth: None,\n            codecs: None,\n            resolution: None,\n            hdcp_level: None,\n            video: None,\n        }\n    }\n\n    /// Returns the peak segment bit rate of the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let stream = StreamInf::new(20);\n    /// assert_eq!(stream.bandwidth(), 20);\n    /// ```\n    pub const fn bandwidth(\u0026self) -\u003e u64 {\n        self.bandwidth\n    }\n\n    /// Sets the peak segment bit rate of the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let mut stream = StreamInf::new(20);\n    ///\n    /// stream.set_bandwidth(5);\n    /// assert_eq!(stream.bandwidth(), 5);\n    /// ```\n    pub fn set_bandwidth(\u0026mut self, value: u64) -\u003e \u0026mut Self {\n        self.bandwidth = value;\n        self\n    }\n\n    /// Returns the group identifier for the video in the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let stream = StreamInf::new(20);\n    /// assert_eq!(stream.video(), \u0026None);\n    /// ```\n    pub const fn video(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.video\n    }\n\n    /// Sets the group identifier for the video in the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let mut stream = StreamInf::new(20);\n    ///\n    /// stream.set_video(Some(\"video\"));\n    /// assert_eq!(stream.video(), \u0026Some(\"video\".to_string()));\n    /// ```\n    pub fn set_video\u003cT: ToString\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.video = value.map(|v| v.to_string());\n        self\n    }\n\n    /// Returns the average segment bit rate of the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let stream = StreamInf::new(20);\n    /// assert_eq!(stream.average_bandwidth(), None);\n    /// ```\n    pub const fn average_bandwidth(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.average_bandwidth\n    }\n\n    /// Sets the average segment bit rate of the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let mut stream = StreamInf::new(20);\n    ///\n    /// stream.set_average_bandwidth(Some(300));\n    /// assert_eq!(stream.average_bandwidth(), Some(300));\n    /// ```\n    pub fn set_average_bandwidth(\u0026mut self, value: Option\u003cu64\u003e) -\u003e \u0026mut Self {\n        self.average_bandwidth = value;\n        self\n    }\n\n    /// A string that represents the list of codec types contained the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let stream = StreamInf::new(20);\n    /// assert_eq!(stream.codecs(), \u0026None);\n    /// ```\n    pub const fn codecs(\u0026self) -\u003e \u0026Option\u003cString\u003e {\n        \u0026self.codecs\n    }\n\n    /// A string that represents the list of codec types contained the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let mut stream = StreamInf::new(20);\n    ///\n    /// stream.set_codecs(Some(\"mp4a.40.2,avc1.4d401e\"));\n    /// assert_eq!(stream.codecs(), \u0026Some(\"mp4a.40.2,avc1.4d401e\".to_string()));\n    /// ```\n    pub fn set_codecs\u003cT: ToString\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.codecs = value.map(|v| v.to_string());\n        self\n    }\n\n    /// Returns the resolution of the stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let stream = StreamInf::new(20);\n    /// assert_eq!(stream.resolution(), None);\n    /// ```\n    pub fn resolution(\u0026self) -\u003e Option\u003c(usize, usize)\u003e {\n        if let Some(res) = \u0026self.resolution {\n            Some((res.width(), res.height()))\n        } else {\n            None\n        }\n    }\n\n    /// Sets the resolution of the stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let mut stream = StreamInf::new(20);\n    ///\n    /// stream.set_resolution(1920, 1080);\n    /// assert_eq!(stream.resolution(), Some((1920, 1080)));\n    /// # stream.set_resolution(1280, 10);\n    /// # assert_eq!(stream.resolution(), Some((1280, 10)));\n    /// ```\n    pub fn set_resolution(\u0026mut self, width: usize, height: usize) -\u003e \u0026mut Self {\n        if let Some(res) = \u0026mut self.resolution {\n            res.set_width(width);\n            res.set_height(height);\n        } else {\n            self.resolution = Some(DecimalResolution::new(width, height));\n        }\n        self\n    }\n\n    /// The HDCP level of the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::StreamInf;\n    /// #\n    /// let stream = StreamInf::new(20);\n    /// assert_eq!(stream.hdcp_level(), None);\n    /// ```\n    pub const fn hdcp_level(\u0026self) -\u003e Option\u003cHdcpLevel\u003e {\n        self.hdcp_level\n    }\n\n    /// The HDCP level of the variant stream.\n    ///\n    /// # Examples\n    /// ```\n    /// # use hls_m3u8::types::{HdcpLevel, StreamInf};\n    /// #\n    /// let mut stream = StreamInf::new(20);\n    ///\n    /// stream.set_hdcp_level(Some(HdcpLevel::None));\n    /// assert_eq!(stream.hdcp_level(), Some(HdcpLevel::None));\n    /// ```\n    pub fn set_hdcp_level\u003cT: Into\u003cHdcpLevel\u003e\u003e(\u0026mut self, value: Option\u003cT\u003e) -\u003e \u0026mut Self {\n        self.hdcp_level = value.map(|v| v.into());\n        self\n    }\n}\n\nimpl fmt::Display for StreamInf {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"BANDWIDTH={}\", self.bandwidth)?;\n\n        if let Some(value) = \u0026self.average_bandwidth {\n            write!(f, \",AVERAGE-BANDWIDTH={}\", value)?;\n        }\n        if let Some(value) = \u0026self.codecs {\n            write!(f, \",CODECS={}\", quote(value))?;\n        }\n        if let Some(value) = \u0026self.resolution {\n            write!(f, \",RESOLUTION={}\", value)?;\n        }\n        if let Some(value) = \u0026self.hdcp_level {\n            write!(f, \",HDCP-LEVEL={}\", value)?;\n        }\n        if let Some(value) = \u0026self.video {\n            write!(f, \",VIDEO={}\", quote(value))?;\n        }\n        Ok(())\n    }\n}\n\nimpl FromStr for StreamInf {\n    type Err = Error;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut bandwidth = None;\n        let mut average_bandwidth = None;\n        let mut codecs = None;\n        let mut resolution = None;\n        let mut hdcp_level = None;\n        let mut video = None;\n\n        for (key, value) in input.parse::\u003cAttributePairs\u003e()? {\n            match key.as_str() {\n                \"BANDWIDTH\" =\u003e bandwidth = Some(value.parse::\u003cu64\u003e()?),\n                \"AVERAGE-BANDWIDTH\" =\u003e average_bandwidth = Some(value.parse::\u003cu64\u003e()?),\n                \"CODECS\" =\u003e codecs = Some(unquote(value)),\n                \"RESOLUTION\" =\u003e resolution = Some(value.parse()?),\n                \"HDCP-LEVEL\" =\u003e hdcp_level = Some(value.parse()?),\n                \"VIDEO\" =\u003e video = Some(unquote(value)),\n                _ =\u003e {\n                    // [6.3.1. General Client Responsibilities]\n                    // \u003e ignore any attribute/value pair with an unrecognized AttributeName.\n                }\n            }\n        }\n\n        let bandwidth = bandwidth.ok_or_else(|| Error::missing_value(\"BANDWIDTH\"))?;\n\n        Ok(Self {\n            bandwidth,\n            average_bandwidth,\n            codecs,\n            resolution,\n            hdcp_level,\n            video,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let mut stream_inf = StreamInf::new(200);\n        stream_inf.set_average_bandwidth(Some(15));\n        stream_inf.set_codecs(Some(\"mp4a.40.2,avc1.4d401e\"));\n        stream_inf.set_resolution(1920, 1080);\n        stream_inf.set_hdcp_level(Some(HdcpLevel::Type0));\n        stream_inf.set_video(Some(\"video\"));\n\n        assert_eq!(\n            stream_inf.to_string(),\n            \"BANDWIDTH=200,\\\n             AVERAGE-BANDWIDTH=15,\\\n             CODECS=\\\"mp4a.40.2,avc1.4d401e\\\",\\\n             RESOLUTION=1920x1080,\\\n             HDCP-LEVEL=TYPE-0,\\\n             VIDEO=\\\"video\\\"\"\n                .to_string()\n        );\n    }\n\n    #[test]\n    fn test_parser() {\n        let mut stream_inf = StreamInf::new(200);\n        stream_inf.set_average_bandwidth(Some(15));\n        stream_inf.set_codecs(Some(\"mp4a.40.2,avc1.4d401e\"));\n        stream_inf.set_resolution(1920, 1080);\n        stream_inf.set_hdcp_level(Some(HdcpLevel::Type0));\n        stream_inf.set_video(Some(\"video\"));\n\n        assert_eq!(\n            stream_inf,\n            \"BANDWIDTH=200,\\\n             AVERAGE-BANDWIDTH=15,\\\n             CODECS=\\\"mp4a.40.2,avc1.4d401e\\\",\\\n             RESOLUTION=1920x1080,\\\n             HDCP-LEVEL=TYPE-0,\\\n             VIDEO=\\\"video\\\"\"\n                .parse()\n                .unwrap()\n        );\n\n        assert_eq!(\n            stream_inf,\n            \"BANDWIDTH=200,\\\n             AVERAGE-BANDWIDTH=15,\\\n             CODECS=\\\"mp4a.40.2,avc1.4d401e\\\",\\\n             RESOLUTION=1920x1080,\\\n             HDCP-LEVEL=TYPE-0,\\\n             VIDEO=\\\"video\\\",\\\n             UNKNOWN=\\\"value\\\"\"\n                .parse()\n                .unwrap()\n        );\n\n        assert!(\"garbage\".parse::\u003cStreamInf\u003e().is_err());\n    }\n}\n","traces":[{"line":30,"address":4212112,"length":1,"stats":{"Line":19}},{"line":50,"address":4212288,"length":1,"stats":{"Line":2}},{"line":51,"address":4212293,"length":1,"stats":{"Line":2}},{"line":65,"address":4212304,"length":1,"stats":{"Line":1}},{"line":66,"address":4212317,"length":1,"stats":{"Line":1}},{"line":67,"address":4212329,"length":1,"stats":{"Line":1}},{"line":79,"address":4212352,"length":1,"stats":{"Line":3}},{"line":80,"address":4212357,"length":1,"stats":{"Line":3}},{"line":94,"address":null,"length":0,"stats":{"Line":2}},{"line":95,"address":null,"length":0,"stats":{"Line":4}},{"line":96,"address":null,"length":0,"stats":{"Line":2}},{"line":108,"address":4212384,"length":1,"stats":{"Line":2}},{"line":109,"address":4212389,"length":1,"stats":{"Line":2}},{"line":123,"address":4212416,"length":1,"stats":{"Line":2}},{"line":124,"address":4212434,"length":1,"stats":{"Line":2}},{"line":125,"address":4212456,"length":1,"stats":{"Line":2}},{"line":137,"address":4212480,"length":1,"stats":{"Line":2}},{"line":138,"address":4212485,"length":1,"stats":{"Line":2}},{"line":152,"address":null,"length":0,"stats":{"Line":2}},{"line":153,"address":null,"length":0,"stats":{"Line":4}},{"line":154,"address":null,"length":0,"stats":{"Line":2}},{"line":166,"address":4212512,"length":1,"stats":{"Line":2}},{"line":167,"address":4212524,"length":1,"stats":{"Line":2}},{"line":168,"address":4212592,"length":1,"stats":{"Line":1}},{"line":170,"address":4212567,"length":1,"stats":{"Line":1}},{"line":187,"address":4212688,"length":1,"stats":{"Line":2}},{"line":188,"address":4212707,"length":1,"stats":{"Line":2}},{"line":189,"address":null,"length":0,"stats":{"Line":1}},{"line":190,"address":4212791,"length":1,"stats":{"Line":1}},{"line":192,"address":4212734,"length":1,"stats":{"Line":2}},{"line":194,"address":null,"length":0,"stats":{"Line":2}},{"line":206,"address":4212864,"length":1,"stats":{"Line":4}},{"line":207,"address":null,"length":0,"stats":{"Line":2}},{"line":221,"address":null,"length":0,"stats":{"Line":3}},{"line":222,"address":null,"length":0,"stats":{"Line":5}},{"line":223,"address":null,"length":0,"stats":{"Line":2}},{"line":227,"address":4603598,"length":1,"stats":{"Line":0}},{"line":228,"address":null,"length":0,"stats":{"Line":1}},{"line":229,"address":4212910,"length":1,"stats":{"Line":1}},{"line":231,"address":null,"length":0,"stats":{"Line":1}},{"line":232,"address":4213298,"length":1,"stats":{"Line":1}},{"line":234,"address":null,"length":0,"stats":{"Line":1}},{"line":235,"address":4213654,"length":1,"stats":{"Line":1}},{"line":237,"address":null,"length":0,"stats":{"Line":1}},{"line":238,"address":4214105,"length":1,"stats":{"Line":1}},{"line":240,"address":null,"length":0,"stats":{"Line":1}},{"line":241,"address":4214445,"length":1,"stats":{"Line":1}},{"line":243,"address":null,"length":0,"stats":{"Line":1}},{"line":244,"address":4214771,"length":1,"stats":{"Line":1}},{"line":246,"address":null,"length":0,"stats":{"Line":1}},{"line":251,"address":4605872,"length":1,"stats":{"Line":0}},{"line":253,"address":4215184,"length":1,"stats":{"Line":1}},{"line":254,"address":4215210,"length":1,"stats":{"Line":1}},{"line":255,"address":4215270,"length":1,"stats":{"Line":1}},{"line":256,"address":4215282,"length":1,"stats":{"Line":1}},{"line":257,"address":4215294,"length":1,"stats":{"Line":1}},{"line":258,"address":null,"length":0,"stats":{"Line":1}},{"line":259,"address":4215314,"length":1,"stats":{"Line":1}},{"line":261,"address":4215326,"length":1,"stats":{"Line":1}},{"line":262,"address":4216370,"length":1,"stats":{"Line":1}},{"line":263,"address":4216391,"length":1,"stats":{"Line":1}},{"line":264,"address":4216488,"length":1,"stats":{"Line":1}},{"line":265,"address":4216508,"length":1,"stats":{"Line":1}},{"line":266,"address":4216582,"length":1,"stats":{"Line":1}},{"line":267,"address":null,"length":0,"stats":{"Line":1}},{"line":268,"address":null,"length":0,"stats":{"Line":1}},{"line":269,"address":null,"length":0,"stats":{"Line":0}},{"line":276,"address":4218366,"length":1,"stats":{"Line":2}},{"line":278,"address":4218961,"length":1,"stats":{"Line":1}},{"line":279,"address":4218785,"length":1,"stats":{"Line":1}},{"line":280,"address":4218793,"length":1,"stats":{"Line":1}},{"line":281,"address":4218809,"length":1,"stats":{"Line":1}},{"line":282,"address":4218857,"length":1,"stats":{"Line":1}},{"line":283,"address":null,"length":0,"stats":{"Line":1}},{"line":284,"address":4218913,"length":1,"stats":{"Line":1}},{"line":294,"address":4524816,"length":1,"stats":{"Line":2}},{"line":295,"address":4524823,"length":1,"stats":{"Line":1}},{"line":296,"address":4524855,"length":1,"stats":{"Line":1}},{"line":297,"address":4524907,"length":1,"stats":{"Line":1}},{"line":298,"address":4524992,"length":1,"stats":{"Line":1}},{"line":299,"address":4524999,"length":1,"stats":{"Line":1}},{"line":300,"address":4525041,"length":1,"stats":{"Line":1}},{"line":302,"address":4525151,"length":1,"stats":{"Line":1}},{"line":303,"address":4525109,"length":1,"stats":{"Line":1}},{"line":315,"address":4525696,"length":1,"stats":{"Line":2}},{"line":316,"address":4525703,"length":1,"stats":{"Line":1}},{"line":317,"address":4525738,"length":1,"stats":{"Line":1}},{"line":318,"address":4525793,"length":1,"stats":{"Line":1}},{"line":319,"address":4525887,"length":1,"stats":{"Line":1}},{"line":320,"address":4525894,"length":1,"stats":{"Line":1}},{"line":321,"address":4525939,"length":1,"stats":{"Line":1}},{"line":323,"address":4526055,"length":1,"stats":{"Line":1}},{"line":335,"address":4526544,"length":1,"stats":{"Line":1}},{"line":348,"address":4526975,"length":1,"stats":{"Line":1}}],"covered":91,"coverable":94},{"path":["/","media","hdd","home","projects","hls_m3u8","src","utils.rs"],"content":"use crate::Error;\n\nmacro_rules! impl_from {\n    ( $($( $type:tt ),* =\u003e $target:path ),* ) =\u003e {\n        use ::core::convert::From;\n\n        $( // repeat $target\n            $( // repeat $type\n                impl From\u003c$type\u003e for $target {\n                    fn from(value: $type) -\u003e Self {\n                        Self::from_f64_unchecked(value.into())\n                    }\n                }\n            )*\n        )*\n    };\n}\n\nimpl_from![\n    u8, u16, u32 =\u003e crate::types::DecimalFloatingPoint,\n    u8, i8, u16, i16, u32, i32, f32, f64 =\u003e crate::types::SignedDecimalFloatingPoint\n];\n\npub(crate) fn parse_yes_or_no\u003cT: AsRef\u003cstr\u003e\u003e(s: T) -\u003e crate::Result\u003cbool\u003e {\n    match s.as_ref() {\n        \"YES\" =\u003e Ok(true),\n        \"NO\" =\u003e Ok(false),\n        _ =\u003e Err(Error::invalid_input()),\n    }\n}\n\n/// According to the documentation the following characters are forbidden\n/// inside a quoted string:\n/// - carriage return (`\\r`)\n/// - new line (`\\n`)\n/// - double quotes (`\"`)\n///\n/// Therefore it is safe to simply remove any occurence of those characters.\n/// [rfc8216#section-4.2](https://tools.ietf.org/html/rfc8216#section-4.2)\npub(crate) fn unquote\u003cT: ToString\u003e(value: T) -\u003e String {\n    value\n        .to_string()\n        .replace(\"\\\"\", \"\")\n        .replace(\"\\n\", \"\")\n        .replace(\"\\r\", \"\")\n}\n\n/// Puts a string inside quotes.\npub(crate) fn quote\u003cT: ToString\u003e(value: T) -\u003e String {\n    // the replace is for the case, that quote is called on an already quoted string, which could\n    // cause problems!\n    format!(\"\\\"{}\\\"\", value.to_string().replace(\"\\\"\", \"\"))\n}\n\n/// Checks, if the given tag is at the start of the input. If this is the case, it will remove it\n/// and return the rest of the input.\n///\n/// # Error\n/// This function will return `Error::MissingTag`, if the input doesn't start with the tag, that\n/// has been passed to this function.\npub(crate) fn tag\u003cT\u003e(input: \u0026str, tag: T) -\u003e crate::Result\u003c\u0026str\u003e\nwhere\n    T: AsRef\u003cstr\u003e,\n{\n    if !input.trim().starts_with(tag.as_ref()) {\n        return Err(Error::missing_tag(tag.as_ref(), input));\n    }\n    let result = input.split_at(tag.as_ref().len()).1;\n    Ok(result)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_yes_or_no() {\n        assert!(parse_yes_or_no(\"YES\").unwrap());\n        assert!(!parse_yes_or_no(\"NO\").unwrap());\n        assert!(parse_yes_or_no(\"garbage\").is_err());\n    }\n\n    #[test]\n    fn test_unquote() {\n        assert_eq!(unquote(\"\\\"TestValue\\\"\"), \"TestValue\".to_string());\n        assert_eq!(unquote(\"\\\"TestValue\\n\\\"\"), \"TestValue\".to_string());\n        assert_eq!(unquote(\"\\\"TestValue\\n\\r\\\"\"), \"TestValue\".to_string());\n    }\n\n    #[test]\n    fn test_quote() {\n        assert_eq!(quote(\"value\"), \"\\\"value\\\"\".to_string());\n        assert_eq!(quote(\"\\\"value\\\"\"), \"\\\"value\\\"\".to_string());\n    }\n\n    #[test]\n    fn test_tag() {\n        let input = \"HelloMyFriendThisIsASampleString\";\n\n        let input = tag(input, \"Hello\").unwrap();\n        assert_eq!(input, \"MyFriendThisIsASampleString\");\n\n        let input = tag(input, \"My\").unwrap();\n        assert_eq!(input, \"FriendThisIsASampleString\");\n\n        let input = tag(input, \"FriendThisIs\").unwrap();\n        assert_eq!(input, \"ASampleString\");\n\n        let input = tag(input, \"A\").unwrap();\n        assert_eq!(input, \"SampleString\");\n\n        assert!(tag(input, \"B\").is_err());\n    }\n}\n","traces":[{"line":10,"address":4367792,"length":1,"stats":{"Line":11}},{"line":11,"address":4367801,"length":1,"stats":{"Line":11}},{"line":19,"address":4367929,"length":1,"stats":{"Line":1}},{"line":24,"address":4214576,"length":1,"stats":{"Line":2}},{"line":25,"address":4214591,"length":1,"stats":{"Line":2}},{"line":28,"address":4214751,"length":1,"stats":{"Line":1}},{"line":40,"address":4214896,"length":1,"stats":{"Line":2}},{"line":41,"address":4214919,"length":1,"stats":{"Line":2}},{"line":49,"address":4215920,"length":1,"stats":{"Line":19}},{"line":52,"address":4215940,"length":1,"stats":{"Line":19}},{"line":61,"address":4219088,"length":1,"stats":{"Line":3}},{"line":65,"address":4219130,"length":1,"stats":{"Line":3}},{"line":66,"address":4219352,"length":1,"stats":{"Line":1}},{"line":68,"address":4219294,"length":1,"stats":{"Line":3}},{"line":69,"address":4219574,"length":1,"stats":{"Line":3}},{"line":77,"address":5000112,"length":1,"stats":{"Line":2}},{"line":78,"address":5319854,"length":1,"stats":{"Line":1}},{"line":79,"address":5319920,"length":1,"stats":{"Line":1}},{"line":80,"address":5320009,"length":1,"stats":{"Line":1}},{"line":84,"address":5000144,"length":1,"stats":{"Line":2}},{"line":85,"address":5320206,"length":1,"stats":{"Line":1}},{"line":86,"address":5320777,"length":1,"stats":{"Line":1}},{"line":87,"address":5321301,"length":1,"stats":{"Line":1}},{"line":91,"address":5000176,"length":1,"stats":{"Line":2}},{"line":92,"address":5321966,"length":1,"stats":{"Line":1}},{"line":93,"address":5322501,"length":1,"stats":{"Line":1}},{"line":97,"address":5000208,"length":1,"stats":{"Line":2}},{"line":98,"address":5323141,"length":1,"stats":{"Line":1}},{"line":100,"address":5323161,"length":1,"stats":{"Line":1}},{"line":101,"address":5323252,"length":1,"stats":{"Line":1}},{"line":103,"address":5323357,"length":1,"stats":{"Line":1}},{"line":104,"address":5323739,"length":1,"stats":{"Line":1}},{"line":106,"address":5323844,"length":1,"stats":{"Line":1}},{"line":107,"address":5324202,"length":1,"stats":{"Line":1}},{"line":109,"address":5324301,"length":1,"stats":{"Line":1}},{"line":110,"address":5324659,"length":1,"stats":{"Line":1}},{"line":112,"address":5324758,"length":1,"stats":{"Line":1}}],"covered":37,"coverable":37},{"path":["/","media","hdd","home","projects","hls_m3u8","tests","playlist.rs"],"content":"//! Credits go to\n//! - https://github.com/globocom/m3u8/blob/master/tests/playlists.py\nuse hls_m3u8::tags::*;\nuse hls_m3u8::MediaPlaylist;\n\nuse std::time::Duration;\n\n#[test]\nfn test_simple_playlist() {\n    let playlist = r#\"\n    #EXTM3U\n    #EXT-X-TARGETDURATION:5220\n    #EXTINF:0,\n    http://media.example.com/entire1.ts\n    #EXTINF:5220,\n    http://media.example.com/entire2.ts\n    #EXT-X-ENDLIST\"#;\n\n    let media_playlist = playlist.parse::\u003cMediaPlaylist\u003e().unwrap();\n    assert_eq!(\n        media_playlist.target_duration_tag(),\n        ExtXTargetDuration::new(Duration::from_secs(5220))\n    );\n\n    assert_eq!(media_playlist.segments().len(), 2);\n\n    assert_eq!(\n        media_playlist.segments()[0].inf_tag(),\n        \u0026ExtInf::new(Duration::from_secs(0))\n    );\n\n    assert_eq!(\n        media_playlist.segments()[1].inf_tag(),\n        \u0026ExtInf::new(Duration::from_secs(5220))\n    );\n\n    assert_eq!(\n        media_playlist.segments()[0].uri(),\n        \u0026\"http://media.example.com/entire1.ts\".to_string()\n    );\n\n    assert_eq!(\n        media_playlist.segments()[1].uri(),\n        \u0026\"http://media.example.com/entire2.ts\".to_string()\n    );\n}\n","traces":[{"line":9,"address":4214000,"length":1,"stats":{"Line":2}},{"line":10,"address":4214014,"length":1,"stats":{"Line":1}},{"line":19,"address":4214034,"length":1,"stats":{"Line":1}},{"line":20,"address":4214289,"length":1,"stats":{"Line":1}},{"line":21,"address":4214101,"length":1,"stats":{"Line":1}},{"line":22,"address":4214170,"length":1,"stats":{"Line":1}},{"line":25,"address":4214388,"length":1,"stats":{"Line":1}},{"line":27,"address":4215495,"length":1,"stats":{"Line":1}},{"line":28,"address":4214914,"length":1,"stats":{"Line":1}},{"line":29,"address":4215415,"length":1,"stats":{"Line":1}},{"line":32,"address":4216213,"length":1,"stats":{"Line":1}},{"line":33,"address":4215970,"length":1,"stats":{"Line":1}},{"line":34,"address":4216133,"length":1,"stats":{"Line":1}},{"line":37,"address":4216887,"length":1,"stats":{"Line":1}},{"line":38,"address":4216688,"length":1,"stats":{"Line":1}},{"line":39,"address":4216836,"length":1,"stats":{"Line":1}},{"line":42,"address":4217538,"length":1,"stats":{"Line":1}},{"line":43,"address":4217350,"length":1,"stats":{"Line":1}},{"line":44,"address":4217487,"length":1,"stats":{"Line":1}}],"covered":19,"coverable":19}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>